<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang数据初始化，零值以及一些陷阱</title>
    <link href="/2020/07/07/goInitialize/"/>
    <url>/2020/07/07/goInitialize/</url>
    
    <content type="html"><![CDATA[<blockquote><p>基础不牢，地动山摇</p></blockquote><p>不像Python这种动态语言，遇见<strong>对象</strong>就是一言不合的赋给变一个<strong>变量</strong>，然后查看；而Go语言是静态类型语言，因此变量是有明确类型的，编译器也会检查变量类型的正确性。</p><h2 id="1-变量的初始化"><a href="#1-变量的初始化" class="headerlink" title="1. 变量的初始化"></a>1. 变量的初始化</h2><h3 id="1-1-声明"><a href="#1-1-声明" class="headerlink" title="1.1 声明"></a>1.1 声明</h3><p>声明变量的一般形式是使用 var 关键字：<code>var name type</code>，其中，var 是声明变量的关键字，name 是变量名，type 是变量的类型。<br>也可以进行批量声明：<br><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (    a <span class="hljs-keyword">int</span>    b <span class="hljs-keyword">string</span>    c []<span class="hljs-keyword">float32</span>    d <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span>    <span class="hljs-title">e</span> <span class="hljs-title">struct</span></span> &#123;        x <span class="hljs-keyword">int</span>    &#125;)</code></pre></div></p><h3 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h3><p>变量初始化的标准格式<code>var 变量名 类型 = 表达式</code>，例如<code>var age int = 25</code>；在标准格式的基础上，将 int 省略后，编译器会尝试根据等号右边的表达式推导 age 变量的类型：<code>var age  = 25</code>，这个很容易理解。</p><h3 id="1-3-短变量声明并初始化"><a href="#1-3-短变量声明并初始化" class="headerlink" title="1.3 短变量声明并初始化"></a>1.3 短变量声明并初始化</h3><p>var 的变量声明还有一种更为精简的写法，例如：<code>age := 100</code>，这是Go语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型，但只能在函数中使用。</p><h2 id="2-Go类型默认的零值"><a href="#2-Go类型默认的零值" class="headerlink" title="2. Go类型默认的零值"></a>2. Go类型默认的零值</h2><p><strong>不带初始值的变量声明会被设置为它们的零值：</strong></p><ul><li>0 for all <strong>integer</strong> types</li><li>0.0 for <strong>floating point</strong> numbers</li><li>false for <strong>booleans</strong></li><li>“” for <strong>strings</strong></li><li>nil for <strong>interfaces, slices, channels, maps, pointers</strong> and <strong>functions</strong></li></ul><p>如果<strong>array</strong>或<strong>struct</strong>声明后未指定值，则其中的元素的字段将为零值。该初始化以递归方式完成：<br><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;    n <span class="hljs-keyword">int</span>    f <span class="hljs-keyword">float64</span>    next *T&#125;fmt.Println([<span class="hljs-number">2</span>]T&#123;&#125;) <span class="hljs-comment">// [&#123;0 0 &lt;nil&gt;&#125; &#123;0 0 &lt;nil&gt;&#125;]</span></code></pre></div></p><h2 id="3-make和new的区别"><a href="#3-make和new的区别" class="headerlink" title="3. make和new的区别"></a>3. make和new的区别</h2><p>Go语言中new和make是内建的两个函数，主要用来创建分配类型内存。 在我们定义生成变量的时候，可能会觉得有点迷惑，其实他们的规则很简单。</p><h3 id="3-1-new"><a href="#3-1-new" class="headerlink" title="3.1 new"></a>3.1 new</h3><p><code>new(T)</code>为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T，该指针指向 T 的新分配的零值。new要点：</p><ul><li>内置函数 new 分配空间</li><li>传递给new 函数的是一个类型，不是一个值</li><li>返回值是 指向这个新分配的零值的指针</li></ul><h3 id="3-2-make"><a href="#3-2-make" class="headerlink" title="3.2 make"></a>3.2 make</h3><p><code>make(T， args)</code> 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make 也是内建函数，你可以从<a href="http://golang.org/pkg/builtin/#make" target="_blank" rel="noopener">官方文档这里</a>看到，它的函数原型 比 new 多了一个（长度）参数，返回值也不同.</p><p><strong>make 只能用于 slice，map，channel 三种类型</strong>， 并且只能是这三种对象。 和 new 一样，第一个参数是 类型，不是一个值. 但是make 的返回值就是这个类型（即使一个引用类型），而不是指针.具体的返回值，依赖具体传入的类型.</p><h3 id="3-3-两者区别"><a href="#3-3-两者区别" class="headerlink" title="3.3 两者区别"></a>3.3 两者区别</h3><p><code>new(T)</code> 返回 T 的指针 *T 并指向 T 的零值。<br><code>make(T)</code> 返回的初始化的 T，只能用于 slice，map，channel，要获得一个显式的指针，使用new进行分配，或者显式地使用一个变量的地址。<br>new 函数分配内存，make函数初始化。</p><p>具体可以看<a href="https://mojotv.cn/tutorial/golang-make-or-new" target="_blank" rel="noopener">mojoyv的文章</a> 以及三月沙的<a href="https://sanyuesha.com/2017/07/26/go-make-and-new/" target="_blank" rel="noopener">理解 Go make 和 new 的区别</a>，包含很多代码例子</p><h2 id="4-一些初始化相关的陷阱"><a href="#4-一些初始化相关的陷阱" class="headerlink" title="4. 一些初始化相关的陷阱"></a>4. 一些初始化相关的陷阱</h2><h3 id="4-1-在nil-map中赋值"><a href="#4-1-在nil-map中赋值" class="headerlink" title="4.1 在nil map中赋值"></a>4.1 在nil map中赋值</h3><div class="hljs"><pre><code class="hljs go"># error code:<span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>m[<span class="hljs-string">"pi"</span>] = <span class="hljs-number">3.1416</span># OUTPUT: <span class="hljs-built_in">panic</span>: assignment to entry in <span class="hljs-literal">nil</span> <span class="hljs-keyword">map</span># we should:m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)m[<span class="hljs-string">"pi"</span>] = <span class="hljs-number">3.1416</span></code></pre></div><h3 id="4-2-无效的内存地址或nil指针取消引用"><a href="#4-2-无效的内存地址或nil指针取消引用" class="headerlink" title="4.2 无效的内存地址或nil指针取消引用"></a>4.2 无效的内存地址或nil指针取消引用</h3><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;    X, Y <span class="hljs-keyword">float64</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span> <span class="hljs-title">Abs</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;    <span class="hljs-keyword">return</span> math.Sqrt(p.X*p.X + p.Y*p.Y)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> p *Point    fmt.Println(p.Abs())&#125;</code></pre></div><p>上面代码会报错：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-built_in">panic</span>: runtime error: invalid memory address or <span class="hljs-literal">nil</span> pointer dereference[signal SIGSEGV: segmentation violation code=<span class="hljs-number">0xffffffff</span> addr=<span class="hljs-number">0x0</span> pc=<span class="hljs-number">0xd2c5a</span>]goroutine <span class="hljs-number">1</span> [running]:main.(*Point).Abs(...)../main.<span class="hljs-keyword">go</span>:<span class="hljs-number">6</span>main.main()../main.<span class="hljs-keyword">go</span>:<span class="hljs-number">11</span> +<span class="hljs-number">0x1a</span></code></pre></div><p>未初始化的指针是nil，我们没法使用它，有两种解决方案：<br>创建一个指针<br><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> p *Point = <span class="hljs-built_in">new</span>(Point)    fmt.Println(p.Abs())&#125;</code></pre></div></p><p>或者直接跳过指针，用值接收者调用指针方法<br><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> p Point <span class="hljs-comment">// has zero value Point&#123;X:0, Y:0&#125;</span>    fmt.Println(p.Abs())&#125;</code></pre></div></p><h3 id="4-3-一个copy错误"><a href="#4-3-一个copy错误" class="headerlink" title="4.3 一个copy错误"></a>4.3 一个copy错误</h3><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> src, dst []<span class="hljs-keyword">int</span>src = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-built_in">copy</span>(dst, src) <span class="hljs-comment">// Copy elements to dst from src.</span>fmt.Println(<span class="hljs-string">"dst:"</span>, dst) # OUTPUT: dst: []</code></pre></div><p>很明显这里的src是一个slice的零值nil，要完整副本的COPY，必须分配容量足够大的目标切片：<br><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> src, dst []<span class="hljs-keyword">int</span>src = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;dst = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(src))n := <span class="hljs-built_in">copy</span>(dst, src)fmt.Println(<span class="hljs-string">"dst:"</span>, dst, <span class="hljs-string">"(copied"</span>, n, <span class="hljs-string">"numbers)"</span>)# OUTPUT： dst: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] (copied <span class="hljs-number">3</span> numbers)</code></pre></div></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang代码工具使用</title>
    <link href="/2020/07/01/goTools/"/>
    <url>/2020/07/01/goTools/</url>
    
    <content type="html"><![CDATA[<blockquote><p>工欲善其事必先利其器</p></blockquote><p>在学习golang的过程中，经常遇到教程让代码遵循<code>gofmt</code>，<code>golint</code>，<code>govet等</code>，而我虽然有Goland的加持，但对其中的区别也是稀里糊涂，在这里做一个简单的总结，主要参考的官方的<a href="https://github.com/golang/go/wiki/CodeTools" target="_blank" rel="noopener">CodeTools</a>专栏。感谢Google！</p><h2 id="1-什么是-Linting"><a href="#1-什么是-Linting" class="headerlink" title="1. 什么是 Linting?"></a>1. 什么是 Linting?</h2><p>Linting是自动检查源代码中是否存在编程错误和样式错误。这可以通过使用lint 工具（也称为<strong>linter</strong>）来完成。lint 工具是基本的静态代码分析器<br>术语linting最初来自于C语言的Unix实用程序。当然现在有许多可用于各种编程语言的代码linter</p><h3 id="1-1-为什么-Linting-重要"><a href="#1-1-为什么-Linting-重要" class="headerlink" title="1.1 为什么 Linting 重要?"></a>1.1 为什么 Linting 重要?</h3><p>Linting对于减少错误和提高代码的整体质量很重要。使用lint 工具可以通过早期发现错误来帮助加速开发并降低成本</p><h3 id="1-2-Lint-Tools-是如何工作的"><a href="#1-2-Lint-Tools-是如何工作的" class="headerlink" title="1.2 Lint Tools 是如何工作的"></a>1.2 Lint Tools 是如何工作的</h3><p>这是lint 工具通常如何适应开发过程的方式。</p><ol><li>编写代码</li><li>编译</li><li>用linter进行分析</li><li>查看该工具识别的错误</li><li>更改代码以解决错误</li><li>代码干净后，链接模块。</li><li>用linter对其进行分析</li><li>进行手动代码审查</li></ol><p>lint 编程是一种自动检查。它应该开发早期进行,在代码审查和测试之前。那是因为自动代码检查使代码审查和测试过程更加有效,使开发人员有时间专注于正确的事情。<br>关于lint其他一些方面的可以查阅<a href="https://www.perforce.com/blog/qac/what-lint-code-and-why-linting-important" target="_blank" rel="noopener">这里</a></p><h2 id="2-Lint工具介绍"><a href="#2-Lint工具介绍" class="headerlink" title="2. Lint工具介绍"></a>2. Lint工具介绍</h2><ul><li><p><a href="https://golang.org/cmd/gofmt/" target="_blank" rel="noopener"><code>gofmt  -  standard Go code formatter</code></a><br>它使用制表符进行缩进，并使用空格进行对齐。对齐方式使用的是编辑器固定宽度的字体</p></li><li><p><a href="https://github.com/golang/lint" target="_blank" rel="noopener"><code>golint - Detects style mistakes in Go code</code></a><br>检测样式错误，比如函数的注释，变量的注释等等</p></li><li><p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener"><code>goimports - Format code and fix your import statements</code></a><br> 更新Go的import行，添加缺少的行并删除未引用的行</p></li><li><p><a href="http://golang.org/cmd/vet/" target="_blank" rel="noopener"><code>govet - Examine Go source code</code></a><br>  检查Go的源代码并报告可疑的部分，例如其参数与格式字符串不一致的Printf调用。vet使用的试探法不能保证所有报告都是真实的问题，但可以发现编译器未捕获的错误</p></li><li><p><a href="https://golangci-lint.run/" target="_blank" rel="noopener"><code>golangci-lint - Bundle of gofmt, golint, govet and many other tools</code></a><br>一把梭，各种linter都有</p></li></ul><p>关于其中的一些区别：</p><blockquote><p>Golint differs from gofmt. Gofmt reformats Go source code, whereas golint prints out style mistakes.<br> Golint differs from govet. Govet is concerned with correctness, whereas golint is concerned with coding style. Golint is in use at Google, and it seeks to match the accepted style of the open source Go project</p></blockquote><h2 id="3-工具的选择"><a href="#3-工具的选择" class="headerlink" title="3. 工具的选择"></a>3. 工具的选择</h2><p>因为我用的Goland，IDE自带了<code>vet</code>，<code>fmt</code>，<code>import</code>，我已经养成了习惯，每完成更新一个就会手动format一下，当然也可以放置在<strong>File Watcher </strong>中自动格式化。之后每次的<strong>commit</strong>都lint一下，然后用<code>golangci-lint</code>查一下一些错误，比如<code>if isExist == True</code>检查改为<code>if isExist</code>，为初学者矫正很多写代码的错误习惯。</p><p>但是在<code>golint</code>官方有这么一段话：</p><blockquote><p>The suggestions made by golint are exactly that: suggestions. Golint is not perfect, and has both false positives and false negatives. Do not treat its output as a gold standard. We will not be adding pragmas or other knobs to suppress specific warnings, so do not expect or require code to be completely “lint-free”. In short, this tool is not, and will never be, trustworthy enough for its suggestions to be enforced automatically, for example as part of a build process. Golint makes suggestions for many of the mechanically checkable items listed in Effective Go and the CodeReviewComments wiki page.</p></blockquote><p>请不要将<code>golint</code>的输出建议视为黄金标准！ 不用搞得像个强迫症患者（我稍微有点，哈哈）一样，一定要完全<strong>“lint-free”</strong>！</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arduino温控PC风扇以及信息显示思路总结</title>
    <link href="/2020/05/13/arduinoFanByTemp/"/>
    <url>/2020/05/13/arduinoFanByTemp/</url>
    
    <content type="html"><![CDATA[<p>温控风扇的一个总所周知的例子就是CPU上的散热风扇，风扇速度会随着CPU负载上升的同时增加，达到及时散热的目的，然而这次要捣鼓的东西也跟这个差不多但是是在放在大机柜里，四路温控风扇，并带有温度风扇速度显示，以及通过触摸显示屏设置上下温度阀值，我毫不犹豫选择了Arduino，这在油管上也有很多类似的项目，不过也杂而不全，翻来覆去，测试了各个部分然后确定了自己想要的方案。</p><h2 id="1-温度传感器选择"><a href="#1-温度传感器选择" class="headerlink" title="1. 温度传感器选择"></a>1. 温度传感器选择</h2><p><a href="https://arduino.nxez.com/2017/03/26/arduino-sensor-series-of-temperature-measurement.html" target="_blank" rel="noopener">温度传感器有很多</a>，我选择了其中的<strong>热敏电阻</strong>和<strong>LM35</strong>进行了测试以及对比，有如下几点想说的：</p><ul><li>最开始我用的100k的热敏电阻和51k的电阻在3.3V下分压计算得到的温度和LM35基本差不多，我很满意，区别只是热敏电阻相对LM35来说浮动小很多</li><li>之后我热敏电阻在5V情况下分压计算温度发现跟之前有一两度的差距，我纠结了很久，反复查看分压得到的值，热敏电阻计算到的值跟之前就差了一点，但是代入公式温度有了一两度的差距，验证后的确如此，不纠结</li><li>LM35在跑了几天后不知道是线路问题还是啥直飙40+摄氏度，感觉不太可靠</li></ul><p>再加上项目要求，我选择了稳定性较高的热敏电阻，<strong>但是想要得到很高的测量精度，需要做很多优化工作，难度较大</strong>，好在对精度要求不高，机柜温度，八九不离十就行。热敏电阻的具体操作可以参考<a href="https://blog.csdn.net/Al_shawn/article/details/51287759" target="_blank" rel="noopener">这里</a>，而LM35的在<a href="https://blog.hobbycomponents.com/?p=89" target="_blank" rel="noopener">这边</a>，附带一个要用到的Arduino函数知识点<a href="https://www.quora.com/What-is-analogReference-function-in-Arduino-Why-and-when-it-should-be-used" target="_blank" rel="noopener">What is analogReference() function in Arduino?</a></p><h2 id="2-PC风扇速度控制"><a href="#2-PC风扇速度控制" class="headerlink" title="2. PC风扇速度控制"></a>2. PC风扇速度控制</h2><p>我一开始拿到个<strong>3 pin的PC风扇（12伏特）来测试</strong>，但还有<strong>2 pin</strong>和<strong>4 pin</strong>，前期找到了一些资料来了解它们</p><ul><li><a href="http://m.elecfans.com/article/1104020.html" target="_blank" rel="noopener">CPU风扇的工作原理</a></li><li><a href="https://forums.tomshardware.com/threads/fan-speed-control-how-to-2-pin-vs-3-pin-vs-4-pin.2200004/" target="_blank" rel="noopener">Fan speed control how-to, 2-pin vs.3-pin vs. 4-pin</a></li><li><a href="https://forum.arduino.cc/index.php?topic=174093.0" target="_blank" rel="noopener"> Control a 3-pin PC fan (Read 5239 times)</a></li></ul><p>具体操作我在油管上找到了篇绝佳的教程<a href="https://www.youtube.com/watch?v=Pw1kSS_FIKk&amp;t=355s" target="_blank" rel="noopener">Controlling fan speed with mosfet and Arduino</a>，我是完全照着这个来，完美，但是还是有几点要强调的：</p><ul><li>风扇速度可以通过PWM电压（无论几pin风扇）来控制也可以选择<strong>4 pin风扇</strong>的pwm线来控制，我选择了前者</li><li>视频中MOS管两端插了个电阻，当时有疑惑，后来得到了<a href="https://blog.csdn.net/luojing194/article/details/69397252" target="_blank" rel="noopener">解决</a></li></ul><h2 id="3-风扇速度测量"><a href="#3-风扇速度测量" class="headerlink" title="3. 风扇速度测量"></a>3. 风扇速度测量</h2><p>我一开始简单地想在施加PWM电压控制风速的同时直接把占空比当做速度的百分比，这明显是合理的，且网上大多都是通过百分比来表示，相对于一串数字的RPM来说更加直观点<br>但是后来摸索来摸索去又进入了测量RPM的怪圈，因为我测试的是<strong>3 pin的风扇</strong>，有一根测速度的线在上面，这就很尴尬不测测不行了。<br>我同样在油管上找到了合适的教程<a href="https://www.youtube.com/watch?v=sWjd61ouRVY&amp;list=LLhi4-nyxWBvXJnWZgVlRZmA&amp;index=6&amp;t=0s" target="_blank" rel="noopener">How to measure Fan RPM with Arduino using hall effect sensor</a>以及一些<a href="https://zhuanlan.zhihu.com/p/27996069" target="_blank" rel="noopener">霍尔效应的原理</a><br>风扇的RPM速度是拿到了，但是在整合程序的时候出现了两个问题：</p><ul><li>测量风扇速度必须在程序中腾出一秒来感应霍尔效应，那么在这一秒内Arduino等于阻塞了，但是又不好搞多线程导致程序有延迟</li><li>在使用ＰＷＭ控制风扇的时候测量出来的霍尔效应是垃圾数值，不能用作于风扇速度，具体看<a href="https://forum.arduino.cc/index.php?topic=620421.0" target="_blank" rel="noopener">这里</a>有这么段话<strong>:One thing you need to be aware of is that when you are controlling a three pin fan via a MOSFET then you need to crank the PWM signal to 100% for a few milliseconds while reading the speed or else you will get garbage readings.</strong></li></ul><p>所以兜兜转转又回到了用百分比描述风扇速度</p><h2 id="4-显示屏选择"><a href="#4-显示屏选择" class="headerlink" title="4. 显示屏选择"></a>4. 显示屏选择</h2><p>Arduino显示屏我主要参考<a href="https://www.youtube.com/watch?v=E6quVf1_BIg&amp;list=LLhi4-nyxWBvXJnWZgVlRZmA&amp;index=4&amp;t=73s" target="_blank" rel="noopener">Top 5 Arduino Displays</a>，主流的显示屏都有讲到。但是我这边的要求是尺寸大一点带触摸功能最终我选择了<a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.3e4a2e8dbwBdjH&amp;id=610082128912&amp;_u=evk2k025bb2" target="_blank" rel="noopener">4寸TFT彩屏 480X320超高清液晶屏LCD触摸屏</a><br>，连接以及代码操作可以参考<a href="https://www.youtube.com/watch?v=9Ms59ofSJIY&amp;list=LLhi4-nyxWBvXJnWZgVlRZmA&amp;index=2&amp;t=68" target="_blank" rel="noopener">Arduino TFT LCD Touch Screen Tutorial</a>和<a href="https://www.youtube.com/watch?v=PAPW97X6IRM&amp;list=LLhi4-nyxWBvXJnWZgVlRZmA&amp;index=3&amp;t=21s" target="_blank" rel="noopener">Arduino Tutorial: 3.5” Color TFT display ILI9481 on Arduino Uno and Mega from Banggood.com</a>。其实中间过程比较坎坷，挑了好几次试验了蛮久才最终定下来，源于我对这方面只是的匮乏，不太懂，这里也强调几个点：</p><ul><li>选择shield显示屏，直白点说也就是可以直插到Arduino板子上，这样就免了接线烦恼直接用</li><li>选择<a href="https://github.com/prenticedavid/MCUFRIEND_kbv" target="_blank" rel="noopener">MCUFRIEND_kbv</a>，里面有大量演示的例子以及代码让你校验这块屏幕，一些压感参数，这是我到最后才发现的。其中的代码优雅性也对自己有很大启发</li><li><code>MCUFRIEND_kbv/examples/TouchScreen_Calibr_native</code>是校验触摸屏，可以得到校准参数然后用到<code>examples/Touch_shield_new/</code>中，一路没问题那就没问题了，之后就开始自己的设计</li><li>一些相关函数可以参考<a href="http://adafruit.github.io/Adafruit-GFX-Library/html/class_adafruit___g_f_x.html#ab6e88c585d3ab6b4f95199361f224fc6" target="_blank" rel="noopener">Adafruit GFX Library</a>，说到底<strong>MCUFRIEND_kbv</strong>是对<strong>Adafruit GFX</strong>的强大包装，自动识别驱动和尺寸，让小白一路畅通</li></ul><h2 id="5-图片和代码展示"><a href="#5-图片和代码展示" class="headerlink" title="5. 图片和代码展示"></a>5. 图片和代码展示</h2><p>代码当然不是最终版，很多还要修改调整的，但是核心的东西就不用变了，接线可以看上面的油管链接，电路图我是不会画的，=。=<br><img src="/images/fanbytemp/fan.jpeg" srcset="/img/loading.gif" alt><br><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Adafruit_GFX.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;MCUFRIEND_kbv.h&gt;</span></span>MCUFRIEND_kbv tft;       <span class="hljs-comment">// hard-wired for UNO shields anyway.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;TouchScreen.h&gt;</span></span><span class="hljs-comment">// Assign human-readable names to some common 16-bit color values:</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLACK   0x0000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLUE    0x001F</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RED     0xF800</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GREEN   0x07E0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CYAN    0x07FF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAGENTA 0xF81F</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YELLOW  0xFFE0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WHITE   0xFFFF</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> XP = <span class="hljs-number">8</span>, XM = A2, YP = A3, YM = <span class="hljs-number">9</span>; <span class="hljs-comment">//ID=0x7796</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> TS_LEFT = <span class="hljs-number">922</span>, TS_RT = <span class="hljs-number">122</span>, TS_TOP = <span class="hljs-number">53</span>, TS_BOT = <span class="hljs-number">933</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MINPRESSURE 200</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXPRESSURE 1000</span><span class="hljs-comment">// 触摸屏实例化</span>TouchScreen ts = TouchScreen(XP, YP, XM, YM, <span class="hljs-number">300</span>);TSPoint tp;<span class="hljs-comment">// 触摸不同区域的不同标志</span>byte touch;<span class="hljs-comment">// 第一行的初始坐标以及行间距</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> line_x = <span class="hljs-number">8</span>, line_y = <span class="hljs-number">20</span>, line_distance = <span class="hljs-number">40</span>;<span class="hljs-comment">// + - 按钮的位置大下参数,一共四个按钮小方块,以左上角第一个作为起点,side_正方形按钮边长</span><span class="hljs-comment">// distance分别为了左右上下两个方块的间隔,symbol为符号到正方向边上的距离,intital_y表达式中的常量3代表与第一行之间的偏移量</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> initial_x = <span class="hljs-number">300</span> , initial_y = line_y - <span class="hljs-number">3</span> , side = <span class="hljs-number">30</span>, x_distance = <span class="hljs-number">50</span>, y_distance = <span class="hljs-number">40</span> , symbol_x = <span class="hljs-number">7</span>, symbol_y = <span class="hljs-number">5</span>;<span class="hljs-keyword">int16_t</span> BOXSIZE;<span class="hljs-keyword">int16_t</span> PENRADIUS = <span class="hljs-number">1</span>;<span class="hljs-keyword">uint16_t</span> ID, oldcolor, currentcolor;<span class="hljs-keyword">const</span> byte Orientation = <span class="hljs-number">1</span>;    <span class="hljs-comment">//PORTRAIT</span><span class="hljs-comment">//MOSFET Gate 控制电源PWM,选择PWM pin 44~46 for mega </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Gate 44</span><span class="hljs-comment">//MF52-100K 常温25摄氏度(298.15K)下阻值为100k欧</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> voltagepower = <span class="hljs-number">5.0</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> R = <span class="hljs-number">51</span>; <span class="hljs-comment">//采样电阻为51千欧</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> B = <span class="hljs-number">3950</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> T1 = <span class="hljs-number">273.15</span> + <span class="hljs-number">25</span>; <span class="hljs-comment">//常温</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> R1 = <span class="hljs-number">100</span>; <span class="hljs-comment">//常温对应的阻值，注意单位是千欧</span><span class="hljs-keyword">const</span> byte analogid = <span class="hljs-number">8</span>; <span class="hljs-comment">//A8处读取电压值</span><span class="hljs-comment">// 风扇速度调节的温度范围</span>byte MinTemp = <span class="hljs-number">25</span>;byte MaxTemp = <span class="hljs-number">32</span>;<span class="hljs-comment">// 风扇电压模拟值变量</span>byte analogvalue;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_threshold</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">// 显示设置值</span>  tft.setCursor(line_x, line_y);  tft.print(<span class="hljs-string">"MinTemp:"</span>); <span class="hljs-comment">// 第一行</span>  tft.print(MinTemp);  tft.println(<span class="hljs-string">" \367C"</span>);  tft.setCursor(line_x, line_y + line_distance * <span class="hljs-number">1</span>);  <span class="hljs-comment">// 第二行</span>  tft.print(<span class="hljs-string">"MaxTemp:"</span>);  tft.print(MaxTemp);  tft.println(<span class="hljs-string">" \367C"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showTempAndControlFan</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//获得A1处的电压值</span>  <span class="hljs-keyword">double</span> digitalValue = analogRead(analogid);  <span class="hljs-keyword">double</span> voltageValue = (digitalValue / <span class="hljs-number">1023</span>) * <span class="hljs-number">5</span>;  <span class="hljs-comment">//通过分压比获得热敏电阻的阻值</span>  <span class="hljs-keyword">double</span> Rt = ((voltagepower - voltageValue) * R) / voltageValue;  <span class="hljs-comment">//换算得到温度值</span>  <span class="hljs-keyword">double</span> temp = ((T1 * B) / (B + T1 * <span class="hljs-built_in">log</span>(Rt / R1))) - <span class="hljs-number">273.15</span>;  <span class="hljs-comment">// 显示温度</span>  tft.setCursor(line_x, line_y + line_distance * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 第三行</span>  tft.print(<span class="hljs-string">"Current Temp: "</span>);  tft.print((<span class="hljs-keyword">int</span>)temp);  tft.print(<span class="hljs-string">" \367C"</span>);  <span class="hljs-comment">// 温度控制风扇</span>  <span class="hljs-keyword">if</span> (temp &gt;= MaxTemp) &#123;    analogvalue = <span class="hljs-number">255</span>;    <span class="hljs-comment">//digitalWrite(buzzer, HIGH);</span>  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp &gt;= MinTemp) &#123;    <span class="hljs-comment">//根据温度MinTemp~MaxTemp调节风扇速度对应analog值128~255</span>    analogvalue = <span class="hljs-built_in">map</span>(temp, MinTemp, MaxTemp, <span class="hljs-number">128</span>, <span class="hljs-number">255</span>);    <span class="hljs-comment">//digitalWrite(buzzer, LOW);</span>  &#125;  <span class="hljs-keyword">else</span> &#123;    analogvalue = <span class="hljs-number">0</span>;    <span class="hljs-comment">//digitalWrite(buzzer, LOW);</span>  &#125;  analogWrite(Gate, analogvalue);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_fan</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;    tft.setCursor(line_x, line_y + line_distance * (<span class="hljs-number">2</span> + <span class="hljs-number">1</span> * i));    tft.print(<span class="hljs-string">"Fan"</span>);    tft.print(i);    tft.print(<span class="hljs-string">" Speed:  "</span>);    <span class="hljs-keyword">if</span>  (analogvalue == <span class="hljs-number">255</span>) &#123;      tft.print(<span class="hljs-string">"100%"</span>);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (analogvalue == <span class="hljs-number">0</span>) &#123;      tft.print(<span class="hljs-string">"  0%"</span>);    &#125;    <span class="hljs-keyword">else</span> &#123;      tft.print(<span class="hljs-string">" "</span>);      tft.print(analogvalue * <span class="hljs-number">100</span> / <span class="hljs-number">255</span>);      tft.print(<span class="hljs-string">"%"</span>);    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;  Serial.begin(<span class="hljs-number">9600</span>);  Serial.println(<span class="hljs-string">"start..."</span>);  tft.reset();  ID = tft.readID();  tft.begin(ID);  tft.setRotation(Orientation);  tft.fillScreen(BLACK);  tft.setTextColor(WHITE);  tft.setTextSize(<span class="hljs-number">2</span>);  <span class="hljs-comment">//https://forum.arduino.cc/index.php?topic=364055.0</span>  <span class="hljs-comment">// 设置加减符号边框</span>  tft.fillRect(initial_x, initial_y, side, side, MAGENTA);  tft.fillRect(initial_x + x_distance, initial_y, side, side, MAGENTA);  tft.fillRect(initial_x, initial_y + y_distance , side, side, MAGENTA);  tft.fillRect(initial_x + x_distance, initial_y + y_distance, side, side, MAGENTA);  <span class="hljs-comment">// 显示加减符号</span>  tft.setCursor(initial_x + symbol_x, initial_y + symbol_y);  tft.print(<span class="hljs-string">"+"</span>);  tft.setCursor(initial_x + symbol_x + x_distance, initial_y + symbol_y);  tft.print(<span class="hljs-string">"-"</span>);  tft.setCursor(initial_x + symbol_x, initial_y + symbol_y + y_distance);  tft.print(<span class="hljs-string">"+"</span>);  tft.setCursor(initial_x + symbol_x + x_distance, initial_y + symbol_y + y_distance);  tft.print(<span class="hljs-string">"-"</span>);  tft.setTextColor(WHITE, BLACK);  Serial.println(<span class="hljs-string">"Screen is "</span> + String(tft.width()) + <span class="hljs-string">"x"</span> + String(tft.height()));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;  show_threshold();  showTempAndControlFan();  show_fan();  <span class="hljs-keyword">uint16_t</span> xpos, ypos;  <span class="hljs-comment">//screen coordinates</span>  tp = ts.getPoint();   <span class="hljs-comment">//p.x, p.y are ADC values</span>  <span class="hljs-comment">// if sharing pins, you'll need to fix the directions of the touchscreen pins</span>  pinMode(XM, OUTPUT);  pinMode(YP, OUTPUT);  <span class="hljs-comment">// we have some minimum pressure we consider 'valid'</span>  <span class="hljs-comment">// pressure of 0 means no pressing!</span>  <span class="hljs-keyword">if</span> (tp.z &gt; MINPRESSURE &amp;&amp; tp.z &lt; MAXPRESSURE) &#123;    xpos = <span class="hljs-built_in">map</span>(tp.y, TS_TOP, TS_BOT, <span class="hljs-number">0</span>, tft.width());    ypos = <span class="hljs-built_in">map</span>(tp.x, TS_RT, TS_LEFT, <span class="hljs-number">0</span>, tft.height());    Serial.println(String(xpos) + <span class="hljs-string">","</span> + String(ypos));    <span class="hljs-keyword">if</span> (xpos &gt; initial_x  &amp;&amp; xpos &lt; initial_x + side) &#123;      <span class="hljs-keyword">if</span> (ypos &gt; initial_y &amp;&amp; ypos &lt; initial_y + side) &#123;        touch = <span class="hljs-number">1</span>;      &#125;    &#125;    <span class="hljs-keyword">if</span> (xpos &gt; initial_x + x_distance &amp;&amp; xpos &lt; initial_x + x_distance + side) &#123;      <span class="hljs-keyword">if</span> (ypos &gt; initial_y &amp;&amp; ypos &lt; initial_y + side) &#123;        touch = <span class="hljs-number">2</span>;      &#125;    &#125;    <span class="hljs-keyword">if</span> (xpos &gt; initial_x &amp;&amp; xpos &lt; initial_x + side) &#123;      <span class="hljs-keyword">if</span> (ypos &gt; initial_y + y_distance &amp;&amp; ypos &lt; initial_y + y_distance + side) &#123;        touch = <span class="hljs-number">3</span>;      &#125;    &#125;    <span class="hljs-keyword">if</span> (xpos &gt; initial_x + x_distance &amp;&amp; xpos &lt; initial_x + x_distance + side) &#123;      <span class="hljs-keyword">if</span> (ypos &gt; initial_y + y_distance &amp;&amp; ypos &lt; initial_y + y_distance + side) &#123;        touch = <span class="hljs-number">4</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">if</span> (touch == <span class="hljs-number">1</span>) &#123;    MinTemp++;    touch = <span class="hljs-number">0</span>;    delay(<span class="hljs-number">200</span>);  &#125;  <span class="hljs-keyword">if</span> (touch == <span class="hljs-number">2</span>) &#123;    MinTemp--;    touch = <span class="hljs-number">0</span>;    delay(<span class="hljs-number">200</span>);  &#125;  <span class="hljs-keyword">if</span> (touch == <span class="hljs-number">3</span>) &#123;    MaxTemp++;    touch = <span class="hljs-number">0</span>;    delay(<span class="hljs-number">200</span>);  &#125;  <span class="hljs-keyword">if</span> (touch == <span class="hljs-number">4</span>) &#123;    MaxTemp--;    touch = <span class="hljs-number">0</span>;    delay(<span class="hljs-number">200</span>);  &#125;&#125;</code></pre></div></p>]]></content>
    
    
    <categories>
      
      <category>Arduino</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arduino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python rsyslog日志集中化</title>
    <link href="/2020/04/02/python-rsyslog/"/>
    <url>/2020/04/02/python-rsyslog/</url>
    
    <content type="html"><![CDATA[<p>下位机十多台树莓派，就开始考虑将日志集中在一起方便调试查看，其实一开始我对这个不太熟悉，对集中化这个词不太敏感，只是想要把日志发送到同一个主机上，后来网上查了查，这叫日志集中化，名气最大的是ELK，日志一把梭<br>上面说的 ELK 都比较复杂，其实用一台服务器作为日志收集服务,使用 Linux 自带的 <code>rsyslog</code>即可，<code>Python</code> 日志库也自带了 <code>SysLogHandler</code>. 简单配置一下即可使用。</p><h2 id="1-什么是rsyslog"><a href="#1-什么是rsyslog" class="headerlink" title="1. 什么是rsyslog"></a>1. 什么是rsyslog</h2><h3 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h3><p>开始之前想说说什么是 <code>syslog</code>，在 <code>Linux</code>中，有很多后台程序都是以后台进程的形式存在运行，例如 <code>crontab／sshd／nginx</code> 等，有些是系统的，有些是我们自己添加的，但是，他们都有一些相同的特点：</p><ul><li>我们不能直接从标准输入给他们输入，也不能直接从标准输出获得他们的输出</li><li>他们通常在固定的位置有日志可以查看，这个位置通常在<code>/var/log/</code></li><li>…</li></ul><p>对于其中的第 2 个特点，大部分 Linux 后台进程都通过 <code>syslog</code>来实现。因为服务器中很多进程的调试和维护都需要一个稳定专业的日志系统，因此，Linux 提供了一个守护进程专门用来处理系统日志，而这个守护进程就是 <code>syslogd</code>，不过，现在的系统大都使用 <code>rsyslod</code>(<code>syslog</code> 升级版) 代替,提供扩展的过滤，消息的加密保护，各种配置选项，输入和输出模块，支持通过TCP或者UDP协议进行传输</p><h3 id="1-2-日志位置"><a href="#1-2-日志位置" class="headerlink" title="1.2 日志位置"></a>1.2 日志位置</h3><p>rsyslogd 在接收到日志之后，需要将日志输出到特定的日志文件中，默认情况下：<br>其中大部分日志消息会在<code>/var/log/rsyslog中</code>，接下来有各类的消息，</p><ul><li>认证信息会保存到<code>/var/log/auth</code>文件中</li><li>调试信息会保存到<code>/var/log/debug</code>文件中</li><li>普通信息会保存到<code>/var/log/messages</code>文件中</li><li>内核消息会保存到<code>/var/log/kern.log</code>文件中</li><li>邮件消息会保存到<code>/var/log/mail.log</code>文件中</li></ul><p>但是这些都是可以改变的，配置文件的位置是 <code>/etc/rsyslog.conf</code>，可以查看配置文件里<code>RULES</code>项的日志对一对上面的东西</p><h3 id="1-3-传输方式"><a href="#1-3-传输方式" class="headerlink" title="1.3 传输方式"></a>1.3 传输方式</h3><p><code>rsyslog</code>提供三个远程日志传输方式：</p><ul><li>UDP: 数据包传输可信度不高</li><li>TCP: 数据包传输可信度比较高</li><li>RELP: 数据包传输可信度最高，避免数据丢失，比较新的协议，目前应用较少</li></ul><p>关于TCP和UDP的传输方式，rsyslog官方推荐使用TCP传输方式</p><blockquote><p>In general, we suggest to use TCP syslog. It is way more reliable than UDP syslog and still pretty fast. The main reason is, that UDP might suffer of message loss. This happens when the syslog server must receive large bursts of messages. If the system buffer for UDP is full, all other messages will be dropped. With TCP, this will not happen. But sometimes it might be good to have a UDP server configured as well. That is, because some devices (like routers) are not able to send TCP syslog by design. In that case, you would need both syslog server types to have everything covered. If you need both syslog server types configured, please make sure they run on proper ports. By default UDP syslog is received on port 514. TCP syslog needs a different port because often the RPC service is using this port as well.</p></blockquote><h2 id="2-rsyslogc基础配置"><a href="#2-rsyslogc基础配置" class="headerlink" title="2. rsyslogc基础配置"></a>2. rsyslogc基础配置</h2><p>rsyslog主要配置文件在<code>/etc/rsyslog.conf</code>。这里你可以配置 <code>global directives</code>, <code>modules</code>， <code>rules</code> that consist of <code>filter</code> and <code>action</code> parts，也可以写一些注释。<br>这里我们主要来讲讲<code>rules</code>板块的配置，<code>rules</code>简单点说就是让系统日志进来的规则，就好比数据库先筛选一部分记录然后给这部分记录做一些动作，等于<code>table.filter().update()</code><br>以下内容整理来自<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/s1-basic_configuration_of_rsyslog#s2-Filters" target="_blank" rel="noopener">redhat rsyslog配置</a></p><h3 id="2-1-Filters（过滤器）"><a href="#2-1-Filters（过滤器）" class="headerlink" title="2.1 Filters（过滤器）"></a>2.1 Filters（过滤器）</h3><p><strong>Facility/Priority-based filters </strong></p><p>FACILITY指定产生特定系统日志消息的子系统。例如，邮件子系统处理所有与邮件相关的系统日志消息。 FACILITY可以用以下关键字之一（或数字代码）表示：<code>kern (0), user (1), mail (2), daemon (3), auth (4), syslog (5), lpr (6), news (7), cron (8), authpriv (9), ftp (10), and local0 through local7 (16 - 23)</code></p><p>PRIORITY指定系统日志消息的优先级。可以通过以下关键字之一（或数字）来表示优先级：<code>debug (7), info (6), notice (5), warning (4), err (3), crit (2), alert (1), and emerg (0)</code></p><p> To select all kernel syslog messages with any priority, add the following text into the configuration file:</p><p>选择任何优先级的所有内核syslog消息：</p><div class="hljs"><pre><code>kern.*</code></pre></div><p>要选择优先级crit更高的所有邮件系统日志消息，请使用以下形式：</p><div class="hljs"><pre><code>mail.crit</code></pre></div><p>要选择除具有info或debug优先级的消息外的所有cron syslog消息，请以以下形式设置配置：</p><div class="hljs"><pre><code>cron.!info,!debug</code></pre></div><p>此外，还支持比较符过滤，比如：</p><div class="hljs"><pre><code>:msg, contains, &quot;error&quot;:hostname, isequal, &quot;host1&quot;:msg, !regex, &quot;fatal .* error&quot;</code></pre></div><p>以及表达式过滤器：</p><div class="hljs"><pre><code>if EXPRESSION then ACTION else ACTION</code></pre></div><h3 id="2-2-Actions（动作）"><a href="#2-2-Actions（动作）" class="headerlink" title="2.2  Actions（动作）"></a>2.2  Actions（动作）</h3><h4 id="2-2-1-将syslog消息存入文件"><a href="#2-2-1-将syslog消息存入文件" class="headerlink" title="2.2.1 将syslog消息存入文件"></a>2.2.1 将syslog消息存入文件</h4><p>大多数操作指定将系统日志消息保存到哪个日志文件。这是通过在已定义的选择器之后指定文件(    FILTER PATH)路径来完成的：</p><div class="hljs"><pre><code>cron.* /var/log/cron.log</code></pre></div><p>默认情况下，每次生成系统日志消息时都会同步日志文件。使用破折号（-）作为指定的文件路径的前缀以省略同步：</p><div class="hljs"><pre><code>FILTER -PATH</code></pre></div><p>指定的文件路径可以是静态或动态的。如上例所示，静态文件由固定文件路径表示。动态文件路径可能会根据收到的消息而有所不同。动态文件路径由模板和问号（?）前缀表示，<br><code>FILTER ?DynamicFile</code></p><div class="hljs"><pre><code>template(name=&quot;DynFile&quot; type=&quot;string&quot; string=&quot;/var/log/line/%fromhost%.log&quot;)local7.* ?DynFile</code></pre></div><p>动态模板是很大的一块内容，具体的不展开我用到的不多，就上面这个例子。详情可以看<a href="https://dulishu.top/linux-rsyslog-template/" target="_blank" rel="noopener">rsyslog template</a>以及<a href="https://www.rsyslog.com/doc/master/configuration/properties.html" target="_blank" rel="noopener">需要用到的属性</a></p><h4 id="2-2-2-通过网络发送syslog消息"><a href="#2-2-2-通过网络发送syslog消息" class="headerlink" title="2.2.2 通过网络发送syslog消息"></a>2.2.2 通过网络发送syslog消息</h4><p>rsyslog允许您通过网络发送和接收syslog消息。此功能使您可以在一台计算机上管理多个主机的系统日志消息。要将系统日志消息转发到远程计算机，请使用以下语法，<code>@[(zNUMBER)]HOST:[PORT]</code>，<code>@</code>代表udp，<code>@@</code>代表TCP</p><div class="hljs"><pre><code>*.* @192.168.0.1*.* @@example.com:6514*.* @(z9)[2001:db8::1]</code></pre></div><p>Storing syslog messages in a database</p><h4 id="2-2-3-其他传输方式"><a href="#2-2-3-其他传输方式" class="headerlink" title="2.2.3 其他传输方式"></a>2.2.3 其他传输方式</h4><ul><li>Output channels</li><li>Sending syslog messages to specific users</li><li>Executing a program</li><li>Storing syslog messages in a database<br>（<code>:PLUGIN:DB_HOST,DB_NAME,DB_USER,DB_PASSWORD;[TEMPLATE]</code>）</li><li>Discarding syslog messages  （丢弃日志<code>local5.* stop</code>）</li></ul><h4 id="2-2-4-指定多个动作"><a href="#2-2-4-指定多个动作" class="headerlink" title="2.2.4 指定多个动作"></a>2.2.4 指定多个动作</h4><p>可以为每个选择器指定多个操作。要为一个选择器指定多个动作，请将每个动作写在单独的行上，并在其前面加上一个＆字符</p><div class="hljs"><pre><code>FILTER ACTION&amp; ACTION&amp; ACTIONkern.=crit user1&amp; ^test-program;temp&amp; @192.168.0.1</code></pre></div><h3 id="2-3-Log-Rotation-（日志轮替）"><a href="#2-3-Log-Rotation-（日志轮替）" class="headerlink" title="2.3 Log Rotation （日志轮替）"></a>2.3 Log Rotation （日志轮替）</h3><p>我们可以在<code>/etc/logrotate.conf</code>配置文件中进行<strong>日志轮替</strong>的配置</p><div class="hljs"><pre><code># rotate log files weeklyweekly# keep 4 weeks worth of backlogsrotate 4# uncomment this if you want your log files compressedcompress</code></pre></div><h2 id="3-使用Python发送日志到rsyslog"><a href="#3-使用Python发送日志到rsyslog" class="headerlink" title="3. 使用Python发送日志到rsyslog"></a>3. 使用Python发送日志到rsyslog</h2><p>我们查阅一下 Python 文档中的 logging 模块的文档，可以发现又一个 handler 叫做：SysLogHandler，看一下参数，并不比 syslog 的原始函数简单，但是，我们可以忽略所有这些参数，而简单得控制日志输出：</p><div class="hljs"><pre><code>class logging.handlers.SysLogHandler(address=(&apos;localhost&apos;, SYSLOG_UDP_PORT), facility=LOG_USER, socktype=socket.SOCK_DGRAM)</code></pre></div><p><code>address</code>: 前面说了 rsyslog 是一个套接字，这里可以制定套接字的地址，注意：这个可以是不在同一台机器,默认为(‘localhost’, 514)<br><code>facility</code>：这个参数的作用是告诉 rsyslog 日志的类型，从而可以让他根据不同的类型执行不同的操作，默认为LOG_USER,下面的例子我们使用<strong>自定义的日志设备local7</strong><br><code>socktype</code>：默认UDP，想换TCP用<code>socket.SOCK_STREAM</code><br>使用的话就和其他的 Handler 一致，简单得记一下：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<span class="hljs-keyword">from</span> logging.handlers <span class="hljs-keyword">import</span> SysLogHandler_LOG_SERVER = (<span class="hljs-string">'192.168.123.222'</span>, <span class="hljs-number">514</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remote_logger</span><span class="hljs-params">(name)</span>:</span>    logger = logging.getLogger(name)    logger.setLevel(logging.INFO)    handler1 = SysLogHandler(        address=_LOG_SERVER, facility=SysLogHandler.LOG_LOCAL7)    <span class="hljs-comment"># python logging 默认所有的日志都是输出到 stderr 中的,可以在supervisor的stderr_logfile指定文件中查看相关日志</span>    <span class="hljs-comment"># 或者 stdout_handler = logging.StreamHandler(sys.stdout)</span>    handler2 = StreamHandler()    formatter1 = logging.Formatter(<span class="hljs-string">'%(name)s - %(levelname)s -  %(message)s'</span>)    formatter2 = logging.Formatter(        <span class="hljs-string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)    handler1.setFormatter(formatter1)    handler2.setFormatter(formatter2)    logger.addHandler(handler1)    logger.addHandler(handler2)    <span class="hljs-keyword">return</span> loggerlogger = remote_logger(<span class="hljs-string">'test'</span>)logger.info(<span class="hljs-string">'xxx'</span>)</code></pre></div></p><h2 id="4-记录Python使用TCP的一些坑"><a href="#4-记录Python使用TCP的一些坑" class="headerlink" title="4. 记录Python使用TCP的一些坑"></a>4. 记录Python使用TCP的一些坑</h2><p>鉴于上面所说的，官方推荐使用TCP，而在上面的例子中我们只要改下<code>socktype</code>的参数就行，但随后发现日志总是没法显示，要么就是好多行在一起，找了好多资料才发现其中原因，具体看<a href="https://stackoverflow.com/questions/40041697/pythons-sysloghandler-and-tcp" target="_blank" rel="noopener">Python’s SyslogHandler and TCP</a>和<a href="https://stackoverflow.com/questions/52950147/sysloghandler-messages-grouped-on-one-line-on-remote-server" target="_blank" rel="noopener">SysLogHandler messages grouped on one line on remote server</a>，概括来说就是<strong>TCP格式标准不支持</strong>，要自己动手额外打些补丁，比较简便的方法是<a href="https://community.graylog.org/t/graylog-2-not-displaying-tcp-syslog-messages/961/2" target="_blank" rel="noopener">使用syslog_rfc5424_formatter库</a></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<span class="hljs-keyword">import</span> logging.handlers<span class="hljs-keyword">import</span> socket<span class="hljs-keyword">from</span> syslog_rfc5424_formatter <span class="hljs-keyword">import</span> RFC5424Formattermy_logger = logging.getLogger(<span class="hljs-string">'MyLogger'</span>)my_logger.setLevel(logging.DEBUG)handler = logging.handlers.SysLogHandler(address = (<span class="hljs-string">'0.0.0.0'</span>,<span class="hljs-number">8514</span>),socktype=socket.SOCK_STREAM)<span class="hljs-comment"># some old syslog daemons expect a NUL terminator, but graylog will not work if a NUL terminator is appended.</span>handler.append_nul = <span class="hljs-literal">False</span>handler.setFormatter(RFC5424Formatter())my_logger.addHandler(handler)my_logger.debug(<span class="hljs-string">'wolfgang was here\n'</span>)</code></pre></div><blockquote><p>当然我们可以用一些方法曲线救国，我们用UDP写入到本地然后在用rsylog自带的TCP传输写入到远程，这个方法还可以，尽量保证数据准确性</p></blockquote><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>在学习日志集中化过程中，也发现了<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/index.html" target="_blank" rel="noopener">ELK</a>，相信以后如果接触大型项目也会要学习到的，而几个小机器，用rsyslog绰绰有余～</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
      <tag>rsyslog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux的信号以及Python处理</title>
    <link href="/2020/03/31/linux-signal-with-python/"/>
    <url>/2020/03/31/linux-signal-with-python/</url>
    
    <content type="html"><![CDATA[<p>初次接触信号这个概念实在gpiozero库文档中的这么一个专题，<code>How do I keep my script running?</code>,我最最开始是在<code>button.when_pressed = hello</code>用一个<code>while True</code>的无限循环保持脚本运行，后来发现有个个内置库的<code>signal.pause()</code>函数可以保持脚本运行，直到按下<strong>Ctrl+C</strong>程序才会退出，我当时仅仅认识到这个地步，没往下深究，直到后来一次mqtt没加loop循环之后自动断开，我后来就在想我用<code>pause</code>还是<code>loop_forever</code>呢? 接下来我就慢慢揭开了信号的序幕，也算当补了下操作系统的一些知识。</p><h2 id="1-信号基础"><a href="#1-信号基础" class="headerlink" title="1. 信号基础"></a>1. 信号基础</h2><p>Linux信号是一种较高层的软件形式的异常，它允许进程和内核中断其他进程。<br>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件，Linux系统上支持30种不同类型的信号，每种信号类型都对应某种系统事件，红笔标注为常见信号：<br><img src="/images/signal/signals.jpeg" srcset="/img/loading.gif" alt="Linux信号"></p><blockquote><p>可以用<code>man 7 signal</code> 查看signal信息</p></blockquote><p>如果觉得上面专业的术语较为枯燥，可以查看<strong>Vamei</strong>大神（看了这篇文章才知道Vamei博主因为抑郁症去世，R.I.P.）的<a href="https://www.cnblogs.com/vamei/archive/2012/10/04/2711818.html" target="_blank" rel="noopener">Linux信号基础</a>以及之前几篇关于进程的文章，通熟易懂</p><h2 id="2-信号发送"><a href="#2-信号发送" class="headerlink" title="2. 信号发送"></a>2. 信号发送</h2><h3 id="2-1-用-bin-kill发送信号"><a href="#2-1-用-bin-kill发送信号" class="headerlink" title="2.1 用/bin/kill发送信号"></a>2.1 用<code>/bin/kill</code>发送信号</h3><p>我之前一直用<code>kill -9 15213</code>强制杀掉某个pid进程，对这个数字9一直没啥反应，其实就是信号9，也就是SIGKILL，等同于<code>kill -SIGTSTP 15213</code></p><h3 id="2-2-从键盘发送信号"><a href="#2-2-从键盘发送信号" class="headerlink" title="2.2 从键盘发送信号"></a>2.2 从键盘发送信号</h3><p>键盘快捷键我已经在上面图中用红笔写出来，不展开</p><h3 id="2-3-用函数发送信号"><a href="#2-3-用函数发送信号" class="headerlink" title="2.3 用函数发送信号"></a>2.3 用函数发送信号</h3><p>Python的<code>os.kill()</code>函数： <code>os.kill(os.getpid(), signal.SIGUSR1)</code></p><h3 id="2-4-用alarm函数向它自己发送信号"><a href="#2-4-用alarm函数向它自己发送信号" class="headerlink" title="2.4 用alarm函数向它自己发送信号"></a>2.4 用alarm函数向它自己发送信号</h3><p><code>signal.alarm(n)</code>函数会安排内核在n秒后发送一个<strong>SIGALRM</strong>信号给调用进程。如果n是0，那么不会调度安排新的alarm</p><h2 id="3-接收以及处理信号"><a href="#3-接收以及处理信号" class="headerlink" title="3. 接收以及处理信号"></a>3. 接收以及处理信号</h2><p><img src="/images/signal/signal_handler.jpg" srcset="/img/loading.gif" alt="Linux信号处理"></p><p>当进程决定执行信号的时候，有下面几种可能：</p><ul><li>无视(ignore)信号，信号被清除，进程本身不采取任何特殊的操作</li><li>默认(default)操作。每个信号对应有一定的默认操作。比如上面SIGCONT用于继续进程。</li><li>自定义操作。也叫做获取 (catch) 信号。执行进程中预设的对应于该信号的操作。</li></ul><p>进程会采取哪种操作，要根据该进程的程序设计。特别是获取信号的情况，程序往往会设置一些比较长而复杂的操作(通常将这些操作放到一个函数中)。</p><h3 id="3-1-Python-signal函数信号处理"><a href="#3-1-Python-signal函数信号处理" class="headerlink" title="3.1 Python signal函数信号处理"></a>3.1 Python signal函数信号处理</h3><p><strong>signal包定义了各个信号名及其对应的整数，核心是使用signal.signal()函数来预设(register)信号处理函数</strong>，<code>singnal.signal(signalnum, handler)</code>中signalnum为某个信号，handler为该信号的处理函数。我们在信号基础里提到，进程可以无视信号，可以采取默认操作，还可以自定义操作。当handler为<code>signal.SIG_IGN</code>时，信号被无视(ignore)。当handler为<code>singal.SIG_DFL</code>，进程采取默认操作(default)。当handler为一个函数名时，进程采取函数中定义的操作。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> signal<span class="hljs-comment"># Define signal handler function</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myHandler</span><span class="hljs-params">(signum, frame)</span>:</span>    print(<span class="hljs-string">'I received: '</span>, signum)<span class="hljs-comment"># register signal.SIGTSTP's handler </span>signal.signal(signal.SIGTSTP, myHandler)signal.pause()print(<span class="hljs-string">'End of Signal Demo'</span>)</code></pre></div><blockquote><p>信号处理程序和主程序以及其他信号处理程序并发地进行，如果处理程序和主程序并发的访问同样的全局数据结构，那么结果可能就是不可预知的，而且经常是致命的！</p></blockquote><p>在主程序中，我们首先使用<code>signal.signal()</code>函数来预设信号处理函数。然后我们执行<code>signal.pause()</code>来让该进程暂停以等待信号，以等待信号。当信号SIGUSR1被传递给该进程时，进程从暂停中恢复，并根据预设，执行SIGTSTP的信号处理函数<code>myHandler()</code>。<code>myHandler</code>的两个参数一个用来识别信号(signum)，另一个用来获得信号发生时，进程栈的状况(stack frame)。这两个参数都是由<code>signal.singnal()</code>函数来传递的。</p><p>上面的程序可以保存在一个文件中(比如<code>test.py</code>)。我们使用如下方法运行:<br><code>$python3 test.py</code></p><p>以便让进程运行。当程序运行到<code>signal.pause()</code>的时候，进程暂停并等待信号。此时，通过按下<strong>CTRL+Z</strong>向该进程发送SIGTSTP信号。我们可以看到，进程执行了<code>myHandle()</code>函数, 随后返回主程序，继续执行。(当然，也可以用<code>$ps</code>查询process ID, 再使用<code>$kill</code>来发出信号。)</p><p>(进程并不一定要使用<code>signal.pause()</code>暂停以等待信号，它也可以在进行工作中接受信号，比如将上面的<code>signal.pause()</code>改为一个需要长时间工作的循环。)</p><p>我们可以根据自己的需要更改<code>myHandler()</code>中的操作，以针对不同的信号实现个性化的处理。</p><h3 id="3-2-Python-alarm函数自发自收信号"><a href="#3-2-Python-alarm函数自发自收信号" class="headerlink" title="3.2 Python alarm函数自发自收信号"></a>3.2 Python alarm函数自发自收信号</h3><p>再来看个官网的例子，它使用<code>alarm()</code>函数来限制等待打开文件所花费的时间；这很有用，因为如果该文件作用于可能无法打开的串行设备，这通常会导致<code>os.open()</code>然后无限期挂起。解决的办法是在打开文件之前设置5秒警报。如果操作花费的时间太长，则会发送警报信号，并且处理程序将引发异常。<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> signal, os<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handler</span><span class="hljs-params">(signum, frame)</span>:</span>    print(<span class="hljs-string">'Signal handler called with signal'</span>, signum)    <span class="hljs-keyword">raise</span> OSError(<span class="hljs-string">"Couldn't open device!"</span>)<span class="hljs-comment"># Set the signal handler and a 5-second alarm</span>signal.signal(signal.SIGALRM, handler)signal.alarm(<span class="hljs-number">5</span>)<span class="hljs-comment"># This open() may hang indefinitely</span>fd = os.open(<span class="hljs-string">'/dev/ttyS0'</span>, os.O_RDWR)signal.alarm(<span class="hljs-number">0</span>)          <span class="hljs-comment"># Disable the alarm</span></code></pre></div></p><h2 id="4-说说在C语言中的实现"><a href="#4-说说在C语言中的实现" class="headerlink" title="4. 说说在C语言中的实现"></a>4. 说说在C语言中的实现</h2><p>在<strong>深入理解计算机系统</strong>书中，讲解Linux信号用了shell以及C来进行演示，这是必须的，理解这些底层机制用C实在是太契合了，但是回过头来看，Python实现这些功能时是完全照着C来的，无论是函数名参数名，只要底层原理相通，编程语言的函数实现也大体一致，如果想看更多关于C的演示，可以看<a href="https://jin-yang.github.io/post/kernel-signal-introduce.html" target="_blank" rel="noopener">Linux 信号机制</a>，很棒的教程！</p><p>但是，Python3的文档中明确指出，handler并不是运行在底层的C handler中的，所以不要希望捕捉同步错误例如SIGFPE与SIGSEGV。<br>同时新增了几个功能，大概用于阻塞signal这种，不过我还不太会用：<br><code>signal.pthread_kill(thread_id, signum)</code><br><code>signal.pthread_sigmask(how, mask)</code></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Invoke与Fabric注意事项详解教程</title>
    <link href="/2020/02/28/invoke-fabric/"/>
    <url>/2020/02/28/invoke-fabric/</url>
    
    <content type="html"><![CDATA[<p>说到远程部署利器，那就不得不讲讲Fabric，Fabric 是一个 Python 的库，同时它也是一个命令行工具。它提供了丰富的同 SSH 交互的接口，可以用来在本地或远程机器上自动化、流水化地执行 Shell 命令。使用 fabric 提供的命令行工具，可以很方便地执行应用部署和系统管理等操作。因此它非常适合用来做应用的远程部署及系统维护<br>刚实习那会，也遇到这种需求，但是不知道Fabric，自己在那实现好半天搞不定，sudo的问题也一直在，paramiko库也看得头晕，最终不了了之，直到发现了Fabric，才发现人家发明的轮子真的香！</p><h2 id="1-Fabric前世今生"><a href="#1-Fabric前世今生" class="headerlink" title="1. Fabric前世今生"></a>1. Fabric前世今生</h2><p>我从一开始接触的就是Python3，之后因为远程打包部署接触到了Fabric，当时官网Fabric还不支持Python3，所以我用了民间的Fabric3，十分好用，对新手很友好。后来，发现Fabric支持Python3了，但是看了文档，看的稀里糊涂，看了别人的教程才成功连接到远程主机上，我就又撒手转向了民间的Fabric3。<br>所以我们先区分下 Fabric1，Fabric2，Fabric3，它们的python官网发布的地址：</p><p>安装方式分别是：<br><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> https://pypi.org/project/Fabric/</span>pip install Fabric<span class="hljs-meta">#</span><span class="bash"> https://pypi.org/project/fabric2/</span>pip install fabric2<span class="hljs-meta">#</span><span class="bash"> https://pypi.org/project/Fabric3/</span>pip install fabric3</code></pre></div></p><p>Fabric1和Fabric2，在pypi中的页面，就是同一个东西：</p><ul><li>都是Fabric的最新版：Fabric 2.x，截至到20200227，安装出来的版本是：2.5</li><li>而官网之所以弄出来个Fabric2是因为：Fabric2和Fabric1相比，完全重写了，接口和功能都有很大改动,官网也不建议你继续用Fabric1，建议升级到Fabric2,最新版也早就支持Python 3.4+，和之前的Python2.7</li></ul><p>而Fabric3，是非官网的是当之前Fabric1还没有支持Python3时，别人去fork出来，加了Python 3的支持的现在好像基本上不维护了</p><p>总结就是：</p><blockquote><p>尽量不要用之前旧的版本的Fabric1了，如果还在用，建议升级到最新的Fabric2<br>不需要操心、忽略掉，所谓的、非官网的，现在已没价值的：Fabric3</p></blockquote><p><strong>因为要同时远程部署七八个树莓派，又要用到Fabric，趁着这次疫情在家，啃了一个星期的文档，蛮多人也觉得新版的Fabric比较难用，原因在于完全重写了，其实我们可以把这个库分开学习，分为Inovke和Paramiko，为什么重写之后要将Invoke独立出来，可以看这里<a href="http://www.pyinvoke.org/faq.html#invoke-split-from-fabric" target="_blank" rel="noopener">Why was Invoke split off from the Fabric project?</a>，那接下去就分别讲讲！</strong></p><h2 id="2-Invoke使用"><a href="#2-Invoke使用" class="headerlink" title="2. Invoke使用"></a>2. Invoke使用</h2><p><strong>Invoke 实现CLI解析，任务组织和Shell命令执行（通用框架以及本地命令的特定实现</strong>），关于Shell命令的执行其实和<code>subprocess</code>库挺像的，当然Invoke不仅于此。</p><h3 id="2-1-基础使用"><a href="#2-1-基础使用" class="headerlink" title="2.1 基础使用"></a>2.1 基础使用</h3><p>关于基础教程我就不说了，看<a href="http://docs.pyinvoke.org/en/latest/getting-started.html" target="_blank" rel="noopener">官网例子</a>一目了然，我在这里记录一些重点与自己的理解。</p><h3 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h3><p>关于invoke的配置方面我们大体看一下<a href="http://docs.pyinvoke.org/en/latest/concepts/configuration.html" target="_blank" rel="noopener">配置继承</a><br>配置很多层，有内部默认，系统级别，用户级别，项目级别…甚至可以在<a href="http://docs.pyinvoke.org/en/latest/invoke.html" target="_blank" rel="noopener">命令行运行</a>的时候我们再添加配置也是可行的。<br>我这里推荐使用<strong>用户级别</strong>的配置文件（<code>~/.invoke.yaml</code>，也可以是json，py文件），刚开始我自己测试的时候用的<strong>项目级别</strong>的配置文件（<code>/home/user/myproject/invoke.yaml</code>），一个原因是我在windows下测试，没有所谓的<code>~/.invoke.yaml</code>，还有个就是我想万一这个项目到别的机器上运行，我可能把隐藏的配置文件忘了，想显示放在项目里，结果这样就跳入了一个火坑，琢磨了我好久，原因在于：</p><blockquote><p>Project-level configuration file living next to your top level tasks.py. For example, if your run of Invoke loads /home/user/myproject/tasks.py (see our docs on the load process), this might be /home/user/myproject/invoke.yaml.</p></blockquote><p>项目级别的配置文件只有在你识别到tasks文件时才会调用同文件夹里的配置，其他方式你会没法识别到，比如你想单独用python3拍这个invoke脚本（把invoke当成subprocess那样）！下面会讲到相关例子。<br>其实，invoke本身没有啥配置修改，所以我也建议在执行<code>invoke ... task1 ...</code>时通过一些命令行参数来传递配置，省了配置文件的存在。</p><h3 id="2-3-导入集合"><a href="#2-3-导入集合" class="headerlink" title="2.3 导入集合"></a>2.3 导入集合</h3><p>Invoke执行模型的核心涉及一个或多个Collection对象，就是集合的意思。<br>默认调用<code>invoke</code>命令我们会查找同目录中的<code>tasks.py</code>或者<code>tasks</code>包，tasks就算是一个集合，具体我们可以看<a href="http://docs.pyinvoke.org/en/latest/concepts/loading.html" target="_blank" rel="noopener">Loading collections</a>，所以有接下来一个例子我上面说的火坑。<br>假如我tasks名字被占用了…我想换个任务名字来让Invoke搜索到，比如叫mytasks，常见的设置方法有两种，一种是设置<code>tasks.collection_name</code> 配置选项，或使用 <code>--collection</code>。集合名应该是Python模块名称，而不是文件名（所以mytasks，不是mytasks.py或 mytasks/。）<br>用<code>--collection</code>没问题，问题在于设置<code>tasks.collection_name</code> 配置选项，我一开始是用的<strong>项目级别</strong>配置，则报错<code>Can&#39;t find any collection named &#39;tasks&#39;!</code>，我明明设置文件里设置了，为什么还是在查找<code>tasks.py</code>,哪里有问题！问题在于上一节引用的英文里，<strong>项目级别</strong>配置是在同目录的<code>tasks.py</code>文件被找到后才会引入该配置，问题是一开始我都没有<code>tasks.py</code>我怎么引入配置文件，更别说里面的<code>tasks.collection_name</code> 配置选项了</p><h3 id="2-4-集合的命名空间"><a href="#2-4-集合的命名空间" class="headerlink" title="2.4 集合的命名空间"></a>2.4 集合的命名空间</h3><p>当任务很多，存在不同类别层级的时候我们就需要<a href="http://docs.pyinvoke.org/en/stable/concepts/namespaces.html" target="_blank" rel="noopener">构建命名空间</a>（看<code>Importing modules as collections</code>部分就行），单纯的<code>tasks.py</code>满足不了我们了，使用<code>tasks</code>包，包里有多个python文件代表个各种任务，然后在<code>tasks/__init__.py</code>中做<code>导入模块作为集合</code>操作就行，不展开。</p><h3 id="2-5-上下文Context"><a href="#2-5-上下文Context" class="headerlink" title="2.5 上下文Context"></a>2.5 上下文Context</h3><p>上下文Context这个参数出现了,很神奇，就好像Flask中的Context一样神奇。</p><p>what exactly is this ‘context’ arg anyway?</p><blockquote><p>A common problem task runners face is transmission of “global” data - values loaded from configuration files or other configuration vectors, given via CLI flags, generated in ‘setup’ tasks, etc.<br>Some libraries (such as Fabric 1.x) implement this via module-level attributes, which makes testing difficult and error prone, limits concurrency, and increases implementation complexity.<br>Invoke encapsulates state in explicit Context objects, handed to tasks when they execute . The context is the primary API endpoint, offering methods which honor the current state (such as Context.run) as well as access to that state itself.</p></blockquote><p>Context对象是在命令行解析过程中创建的（如果需要的话，可以手动创建），并用于与执行的任务共享解析器和配置状态，下面两种例子是一样的.<br>第一种通过命令行，过程中创建ｃ，即为context,会自动导入文件配置:<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> invoke <span class="hljs-keyword">import</span> task<span class="hljs-meta">@task</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(c)</span>:</span>print(config)    c.run(<span class="hljs-string">"ls"</span>)$ invoke ls...</code></pre></div></p><p>第二种手动创建,如果有配置我们需要手动添加配置而没法用文件配置,比如:<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> invoke <span class="hljs-keyword">import</span> Config,Context<span class="hljs-comment"># 默认配置</span>config = Config()<span class="hljs-comment"># 添加一些配置</span>config[<span class="hljs-string">'sudo'</span>] = &#123;<span class="hljs-string">'password'</span>:<span class="hljs-string">'mypassoword'</span>&#125;print(config)<span class="hljs-comment"># 传入配置,如果没有额外配置可以省略不填</span>c = Context(config=config)c.run(<span class="hljs-string">'ls'</span>)</code></pre></div></p><h3 id="2-6-sudo运行以及自动响应"><a href="#2-6-sudo运行以及自动响应" class="headerlink" title="2.6 sudo运行以及自动响应"></a>2.6 sudo运行以及自动响应</h3><p>最后我们说运行sudo命令时如何免密码以及与一运行一些其他命令时的提示互动.<br>我们可以先配置好文件:<br><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"tasks"</span>: &#123;        <span class="hljs-attr">"auto_dash_names"</span>: <span class="hljs-literal">false</span>    &#125;,    <span class="hljs-attr">"sudo"</span>: &#123;<span class="hljs-attr">"password"</span>:<span class="hljs-string">"mypassword"</span>        <span class="hljs-string">"prompt"</span>: <span class="hljs-string">"[sudo] password:"</span>,    &#125;&#125;</code></pre></div></p><p>然后在脚本里<code>c.sudo(&#39;rm test.txt&#39;)</code>就行.<br>或者我们简单点:直接在在函数里面加入<code>c.sudo(&#39;rm test.txt&#39;,user=&#39;baird&#39;,password=&#39;mypassword&#39;)</code><br>关于自动响应程序输出的,我们可以看<a href="http://docs.pyinvoke.org/en/stable/concepts/watchers.html" target="_blank" rel="noopener">Automatically responding to program output</a></p><h2 id="3-Fabric使用"><a href="#3-Fabric使用" class="headerlink" title="3. Fabric使用"></a>3. Fabric使用</h2><p>Fabric与Invoke基本上属于继承创新的关系,很多都是相同操作,所以这一部分就不重复讲了.<br><strong>Fabric相对于Invoke来说增加了Paramiko库的功能</strong>,也就是说实现了低/中级别SSH功能-SSH和SFTP会话，密钥管理等.但作为用户我们很少会直接从Paramiko导入,而是Fabric把它融合进来了,我们在看教程前,先来看看SSH认证</p><h3 id="3-1-认证"><a href="#3-1-认证" class="headerlink" title="3.1 认证"></a>3.1 认证</h3><p>即使在<strong>原始</strong> OpenSSH客户端中，对远程服务器的身份验证也涉及多个潜在的秘密和配置来源。Fabric不仅支持其中的大多数，而且还具有自己的功能,下面是认证方式以及对应的配置:</p><ul><li>私人秘钥文件,通过<code>connect_kwargs.key_filename</code>配置</li><li>如果私钥文件通过密码保护,通过<code>connect_kwargs.passphrase</code>配置</li><li>私钥对象,通过<code>connect_kwargs.pkey</code>配置</li><li>SSH代理</li><li>密码,通过<code>connect_kwargs.password</code>配置或者<code>--prompt-for-login-password</code>手动提示输入</li><li>GSSAPI,不太懂,pass<br>上面的认证方式基本就全了,当然,每种认证方式的配置选择有很多,不止一种,很灵活,具体看<a href="http://docs.fabfile.org/en/2.5/concepts/authentication.html" target="_blank" rel="noopener">Authentication</a>.<br><strong>其实我们不用管那么多啥认证方式,密码就完事了~,方便省略</strong></li></ul><h3 id="3-2-连接"><a href="#3-2-连接" class="headerlink" title="3.2 连接"></a>3.2 连接</h3><p>有了认证之后,就得到了一个连接(connection),用于SSH守护程序的连接，其中包含命令和文件传输的方法.这个connection其实跟context是一样的,一个远程一个本机,我们可以看下,在<code>fabfile.py</code>里代码如下:<br><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">from</span> fabric <span class="hljs-keyword">import</span> task<span class="hljs-meta">@task</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(c)</span>:</span>    c.run(<span class="hljs-string">'ls'</span>)</code></pre></div></p><p>当我们用<code>fab -H host1 show</code>时是连接的host1再运行ls命令,而<code>fab show</code>是直接在本机运行ls命令,也就是Invoke的作用,当然我么需要一个配置文件,我用的是密码:<br><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"user"</span>: <span class="hljs-string">"pi"</span>,    <span class="hljs-attr">"connect_kwargs"</span>: &#123;        <span class="hljs-attr">"password"</span>: <span class="hljs-string">"mypassword"</span>    &#125;,&#125;</code></pre></div></p><p>以上是使用命令行调用,或者我们可以使用connection函数:<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fabric <span class="hljs-keyword">import</span> Connectionc = Connection(<span class="hljs-string">'pi@host1'</span>,connect_kwargs=&#123;<span class="hljs-string">'password'</span>:<span class="hljs-string">'mypassword'</span>&#125;)c.run(<span class="hljs-string">'ls'</span>)</code></pre></div></p><p>更多例子我们可以看<a href="http://docs.fabfile.org/en/2.5/getting-started.html" target="_blank" rel="noopener">官方教程</a>,其实我最早看这上面例子时,我有点彷徨,没密码怎么连上去跑命令的,后来发现密码都是认证配置,连接并不重要,重要的是给你展示用法。</p><blockquote><p>从上面这个例子我们可以看出，可以用各种灵活的配置以及实现方式来创建一个远程连接。我的项目中有涉及远程部署多台机器， 我开始的想法是一把梭，创建所有机器的connection，然后上传上去，即我不需要-H来指定哪些机器，我已全部手动实例化，这就意味着用Fabric的Connection类实例化再加Facric中的Invoke功能。这是一种选择。后来发现，我应该采用一种更通用的方法，函数里我就执行相应动作，然后用-H指定主机，但是这样的话，比如我想同时部署多台机器，或者一半的机器，我还得在-H之后一个个输地址，这很耗时间，但好处就是一台台调试的时候更方便。所以我们还需外的任务，来根据条件快速输出-H后面的值做一个辅助工具，比如说输入1～7，那就自动把1~7七台机器的ip提示出来买，也算是曲线救国</p></blockquote><h3 id="3-3-配置"><a href="#3-3-配置" class="headerlink" title="3.3 配置"></a>3.3 配置</h3><p><a href="http://docs.fabfile.org/en/2.5/concepts/configuration.html" target="_blank" rel="noopener">Fabric配置系统的核心</a>依赖于Invoke功能（与Fabric的其余大部分一样),只是配置文件名从<code>invoke</code>(不包括后缀)改为<code>fabfile</code>,然后是多了一些关于远程主机认证的配置,最常用的就是<code>connect_kwargs</code>,上面例子也出现过了,就不过多强调了</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>这篇文章总结下来,花了我蛮多时间的,也算是打开了2020的新篇章。以为过程中一切都很顺利，结果写着写着就卡住了，打了自己”自以为很懂”的脸，也算有了更多收获，接下来更多加油!</p>]]></content>
    
    
    <categories>
      
      <category>Fabric</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
      <tag>Fabric</tag>
      
      <tag>Invoke</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python并发之异步I/O(async,await）</title>
    <link href="/2020/02/13/python-asyncio/"/>
    <url>/2020/02/13/python-asyncio/</url>
    
    <content type="html"><![CDATA[<p>前面关于yield，yield from的语法说了好多，其实大多是铺垫，算是python在通往异步大道上的一些探索，但是将异步完整融入python整个过程并非都是顺利的，创建修改替换修改，反反复复，直到最新几版的python，趋于平稳，用其优雅特性来给人们展示异步，我们一起来看看！</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>Python有很长一段的异步编程历史,特别是<code>twisted</code>，<code>gevent</code>和一些无堆栈的Python项目。<br>异步编程因为一些好的原因在这些年来越来越受关注。尽管相对于传统的线性风格更难一点，但是却是值得的：因为异步编程有更高的效率。<br>举个例子：在Http请求方面，Python异步协程可以提交请求然后去做队列中其他等待的任务，让它慢慢请求，而不是传统的一直等它请求到完成为止，这样的话会浪费更多的时间与资源。总之异步编程能让你的代码在处于等待资源状态时处理其他任务。<br>在Python3.4中，<code>asyncio</code>产生了。而在Python3.5中，有加入了对<code>async def</code> 和<code>await</code>新的语法支持。</p><h2 id="2-四个核心概念"><a href="#2-四个核心概念" class="headerlink" title="2. 四个核心概念"></a>2. 四个核心概念</h2><h3 id="2-1-Eventloop"><a href="#2-1-Eventloop" class="headerlink" title="2.1 Eventloop"></a>2.1 Eventloop</h3><p>Eventloop 可以说是 asyncio 应用的核心，是中央总控。Eventloop 实例提供了注册、取消和执行任务和回调的方法。<br>把一些异步函数 (就是任务，Task，一会就会说到) 注册到这个事件循环上，事件循环会循环执行这些函数 (但同时只能执行一个)，当执行到某个函数时，如果它正在等待 I/O 返回，事件循环会暂停它的执行去执行其他的函数；当某个函数完成 I/O 后会恢复，下次循环到它的时候继续执行。因此，这些异步函数可以协同 (Cooperative) 运行：这就是事件循环的目标。</p><h3 id="2-2-Coroutine"><a href="#2-2-Coroutine" class="headerlink" title="2.2 Coroutine"></a>2.2 Coroutine</h3><p>协程 (Coroutine) 本质上是一个函数，特点是在代码块中可以将执行权交给其他协程：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<span class="hljs-comment"># 在Python 3.4中, 创建一个协程我们用asyncio.coroutine装饰器，但现在基本弃用</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'Suspending a'</span>)    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)    print(<span class="hljs-string">'Resuming a'</span>)    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'In b'</span>)<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">await</span> asyncio.gather(a(), b())<span class="hljs-comment">#asyncio.run 是 Python 3.7 新加的接口，要不然你得这么写:</span><span class="hljs-comment">#loop = asyncio.get_event_loop()</span><span class="hljs-comment">#loop.run_until_complete(main())</span><span class="hljs-comment">#loop.close()</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    asyncio.run(main())&gt;&gt;Suspending a&gt;&gt;In b&gt;&gt;Resuming a</code></pre></div></p><blockquote><p>asyncio.gather 用来并发运行任务，在这里表示协同的执行 a 和 b两个协程<br>在协程 a 中，有一句 await asyncio.sleep (0)，await 表示调用协程，sleep 0 并不会真的 sleep（因为时间为 0），但是却可以把控制权交出去了。</p></blockquote><h3 id="2-3-Future"><a href="#2-3-Future" class="headerlink" title="2.3 Future"></a>2.3 Future</h3><p>接着说 Future，它代表了一个「未来」对象，异步操作结束后会把最终结果设置到这个 Future 对象上。Future 是对协程的封装，不过日常开发基本是不需要直接用这个底层 Future 类的</p><h3 id="2-4-Task"><a href="#2-4-Task" class="headerlink" title="2.4  Task"></a>2.4  Task</h3><p>Eventloop 除了支持协程，还支持注册 Future 和 Task2 种类型的对象，那为什么要存在 Future 和 Task 这 2 种类型呢？<br>Future 是协程的封装，Future 对象提供了很多任务方法 (如完成后的回调、取消、设置任务结果等等)，但是开发者并不需要直接操作 Future 这种底层对象，而是用 Future 的子类 Task 协同的调度协程以实现并发。</p><p>Task 非常容易创建和使用:</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># 或者用task = loop.create_task(a())</span>In : task = asyncio.ensure_future(a())In : taskOut: &lt;Task pending coro=&lt;a() running at /Users/dongwm/mp/<span class="hljs-number">2019</span><span class="hljs-number">-05</span><span class="hljs-number">-22</span>/coro1.py:<span class="hljs-number">4</span>&gt;&gt;In : task.done()Out: <span class="hljs-literal">False</span>In : <span class="hljs-keyword">await</span> taskSuspending aResuming aIn : taskOut: &lt;Task finished coro=&lt;a() done, defined at /Users/dongwm/mp/<span class="hljs-number">2019</span><span class="hljs-number">-05</span><span class="hljs-number">-22</span>/coro1.py:<span class="hljs-number">4</span>&gt; result=<span class="hljs-literal">None</span>&gt;In : task.done()Out: <span class="hljs-literal">True</span></code></pre></div><p><strong>在这边的时候我卡了很长时间：future与Task的区别是什么？？？？</strong></p><p>future在多线程说过，future表示终将发生的事情，而确定某件事会发生的唯一方式是执行的时间已经排定。（你不排定它，它就是个协程），那怎么排定？</p><p>BaseEventLoop.create_task(…) 或者 asyncio.ensure_future方法接收一个协程，排定它的运行时间，然后返回一个asyncio.Task 实例——也是 asyncio.Future 类的实例，因为 Task 是Future 的子类，用于包装协程。这与调用 Executor.submit(…) 方法创建Future实例是一个道理</p><p>这句话我读了好多遍，意思是不是说future跟task是同一样东西。对于event loop来说，一个包装了协程的future，就是循环中的一个task？我是这么理解的。</p><p>我们无法确定future啥时完成结束，但是总归结束（无论报错还是返回值）的，因为我们已经给它排定了时间。</p><h2 id="3-如何准确使用asyncio"><a href="#3-如何准确使用asyncio" class="headerlink" title="3. 如何准确使用asyncio"></a>3. 如何准确使用asyncio</h2><p>自从Python3.5加入了<code>async def</code> 和<code>await</code>新的语法，在往后Python大版本更新中一直对该部分的语法有更新修改，从前期的乱而杂，到最新的Python3.8语法渐渐稳定下来，优雅了很多，文档也条理了很多，其实要使用真正的语法还是要多看看<a href="https://docs.python.org/3/library/asyncio-task.html#coroutines" target="_blank" rel="noopener">官网例子</a>。</p><p>初阶选手使用时，一般的<code>High-level APIs</code>完全可以满足需求，当理解了高阶API时，在去查看源代码，查看<code>Low-level APIs</code>，深层次的理解！<a href="https://www.dongwm.com/post/understand-asyncio-3/" target="_blank" rel="noopener">这里有个较新的教程，分三个部分，很好！</a>，推荐阅读！</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>asyncio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派几种不同的PWM及其应用</title>
    <link href="/2020/02/10/Raspberrypi-PWM/"/>
    <url>/2020/02/10/Raspberrypi-PWM/</url>
    
    <content type="html"><![CDATA[<p>树莓派上PWM其实应用的不多，很多例子都是简单地用代码控制小灯地闪亮黯淡过程，这在我之前刚接触硬件时充满懵懂的脑子面前显得十分新奇，后来慢慢懂了PWM，很多时候用在步进马达上，后来，慢慢过了半年后，我才发现一个问题，当树莓派有发热现象，传统地调用树莓派PWM功能时，步进马达总是怪怪的，转的不是很规律，有点性能跟不上的感觉。深入进去，发现PWM有多东西，这次就趁机总结一下，方便以后使用。</p><h2 id="1-树莓派上PWM的分类"><a href="#1-树莓派上PWM的分类" class="headerlink" title="1. 树莓派上PWM的分类"></a>1. 树莓派上PWM的分类</h2><h3 id="1-1-Fully-hardware-PWM-全硬件PWM"><a href="#1-1-Fully-hardware-PWM-全硬件PWM" class="headerlink" title="1.1 Fully hardware PWM (全硬件PWM)"></a>1.1 Fully hardware PWM (全硬件PWM)</h3><blockquote><p>这种类型的PWM由树莓派的PWM外设产生。脉冲的时序由PWM外设控制。它是最准确的，而且可以说是最灵活的。<br>它可以在GPIO 12/13/18/19上生成。但是，只有两个通道，因此一次只能生成两个不同的PWM流。GPIO 12/18在一个通道上，GPIO 13/19在另一个通道上。<br>适用于无抖动的伺服，无干扰的LED亮度控制，电机速度控制。</p></blockquote><h3 id="1-2-DMA-timed-PWM-（DMA定时PWM）"><a href="#1-2-DMA-timed-PWM-（DMA定时PWM）" class="headerlink" title="1.2 DMA timed PWM （DMA定时PWM）"></a>1.2 DMA timed PWM （DMA定时PWM）</h3><blockquote><p>这种类型的PWM由树莓派的DMA外设产生。<br>脉冲的时序由DMA控制。它的定时精度不如完全硬件的PWM精确，但比软件定时的PWM精确得多。取决于实现方式，它不如完全硬件的PWM灵活，例如，频率的数量要受限制得多，开和关之间的步数要受限制得多。<br>此类PWM可以在扩展头上的任何GPIO上生成。所有GPIO可能具有不同的设置。<br>适用于无抖动的伺服，无干扰的LED亮度控制，电机速度控制。</p></blockquote><h3 id="1-3-Software-Timed-PWM-（软件定时PWM）"><a href="#1-3-Software-Timed-PWM-（软件定时PWM）" class="headerlink" title="1.3 Software Timed PWM （软件定时PWM）"></a>1.3 Software Timed PWM （软件定时PWM）</h3><blockquote><p>这种类型的PWM由软件生成。<br>脉冲的时序由（Linux）调度程序控制。与完全硬件PWM或DMA定时PWM相比，它的定时精度明显降低。它比DMA定时PWM灵活得多，并且与完全硬件PWM一样灵活，例如，频率数量是无限的，开和关之间的步数是无限的。<br>此类PWM可以在扩展头上的任何GPIO上生成。所有GPIO可能具有不同的设置。时序精度将根据用于PWM的GPIO数量而变化。<br>不太适合伺服器，可以控制LED的亮度，但会出现毛刺，适合于电机速度控制。</p></blockquote><p>脉冲稳定性当然是：全硬件PWM &gt;&gt; DMA定时PWM &gt;&gt; 软件定时PWM</p><h2 id="2-树莓派上PWM的实现方式"><a href="#2-树莓派上PWM的实现方式" class="headerlink" title="2. 树莓派上PWM的实现方式"></a>2. 树莓派上PWM的实现方式</h2><h3 id="2-1-传统的实现方式"><a href="#2-1-传统的实现方式" class="headerlink" title="2.1 传统的实现方式"></a>2.1 传统的实现方式</h3><p>手动sleep来实现pwm功能，步进马达连接与传统实现可以看<a href="https://www.raspberrypi.org/forums/viewtopic.php?t=186016" target="_blank" rel="noopener">这里</a><br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-keyword">print</span> (<span class="hljs-string">"Move Backward"</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">5</span>*<span class="hljs-number">200</span>):GPIO.output(LinearActuatorDir, <span class="hljs-number">0</span>)GPIO.output(LinearActuatorStepPin, <span class="hljs-number">1</span>)time.sleep(LowSpeed)GPIO.output(LinearActuatorStepPin, <span class="hljs-number">0</span>)time.sleep(LowSpeed)<span class="hljs-keyword">print</span> (<span class="hljs-string">"Moving"</span>)    ...</code></pre></div></p><h3 id="2-2-神级武器gpiozero"><a href="#2-2-神级武器gpiozero" class="headerlink" title="2.2 神级武器gpiozero"></a>2.2 神级武器gpiozero</h3><p>这里我们可以用gpiozero中的<a href="https://gpiozero.readthedocs.io/en/stable/api_output.html#pwmoutputdevice" target="_blank" rel="noopener">PWMOutputDevice类</a><br><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># 初始化完即运行，initial_value为占空比，frequency为频率</span>p = PWMOutputDevice(pin, *, active_high=<span class="hljs-literal">True</span>, initial_value=<span class="hljs-number">0</span>, frequency=<span class="hljs-number">100</span>, pin_factory=<span class="hljs-literal">None</span>)</code></pre></div></p><blockquote><p>注意，这里有一个点，<code>pin_factory=None</code>一般情况下默认使用的是<code>RPi.GPIO</code>，而<code>RPi.GPIO</code>默认的PWM是Software Timed PWM，所以可能稳定性不太好，所以我们可以使用<code>factory = PiGPIOFactory(host=&#39;127.0.0.1&#39;)</code>， <code>PiGPIO</code>支持DMA timed PWM，这个比较好</p></blockquote><h3 id="2-3-庞大的pigpio-（不推荐新手）"><a href="#2-3-庞大的pigpio-（不推荐新手）" class="headerlink" title="2.3 庞大的pigpio （不推荐新手）"></a>2.3 庞大的pigpio （不推荐新手）</h3><p>piggio python库中的set_PWM_dutycycle函数和hardware_PWM函数分别对应DMA，以及Fully hardware，这里不做过多阐述，自己也不是很懂 =。= ，有点尴尬，感觉相对于gpiozero稍微有点麻烦，可以看<a href="https://raspberrypi.stackexchange.com/questions/40243/pigpio-set-pwm-dutycycle-vs-hardware-pwm" target="_blank" rel="noopener">两者区别</a>和<a href="http://abyz.me.uk/rpi/pigpio/python.html" target="_blank" rel="noopener">pigpio文档</a></p>]]></content>
    
    
    <categories>
      
      <category>RaspberryPi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
      <tag>PWM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派使用MCP3008模数转换器(ADC)</title>
    <link href="/2020/01/20/ADC-MCP3008/"/>
    <url>/2020/01/20/ADC-MCP3008/</url>
    
    <content type="html"><![CDATA[<p>树莓派是一款出色的小型台式计算机，可用于控制数字输入和输出。但是，当你想读取模拟信号（例如从热敏电阻，电位器或许多其他类型的传感器获得的信号）时会怎么做？通过将小型的模数转换器（ADC）芯片连接到P树莓派，可以为程序打开模拟信号的世界！<br>我这边的目的是想测电瓶里面还剩多少电，通过数模转换器拿到电瓶此时输出的电压，再根据电瓶电压衰减曲线大概估算所剩百分比。</p><h2 id="1-方法总结"><a href="#1-方法总结" class="headerlink" title="1. 方法总结"></a>1. 方法总结</h2><ul><li><p><a href="https://www.raspberrypi-spy.co.uk/2013/10/analogue-sensors-on-the-raspberry-pi-using-an-mcp3008/" target="_blank" rel="noopener">Analogue Sensors On The Raspberry Pi Using An MCP3008</a></p></li><li><p><a href="https://learn.adafruit.com/mcp3008-spi-adc/python-circuitpython" target="_blank" rel="noopener">MCP3008 - 8-Channel 10-Bit ADC With SPI Interface</a></p></li><li><p><a href="https://gpiozero.readthedocs.io/en/stable/api_spi.html#mcp3208" target="_blank" rel="noopener">gpiozero 15.2.8. MCP3208</a></p></li></ul><p>用上面的三种方法都能拿到最后所需要的转换值。第一种比较原生。推荐第二种跟第三种方法，原因下面讲。</p><h2 id="2-一些小细节"><a href="#2-一些小细节" class="headerlink" title="2. 一些小细节"></a>2. 一些小细节</h2><ul><li>市面上常用的模数转换器，一种是简单的MCP3008 模数转换器，可以读取8个10位精度的模拟输入通道；另外一种是相对更高级的ADS1x15系列可以读取4个12位至16位精度的通道，大部分情况前者就够用</li><li>当你使用MCP3008芯片时，务必使用第三种方法，<code>gpiozero MCP3008</code>函数，依旧是熟悉的味道，简单好用，三行代码就解决；当使用ADS1x15系列时，需要用第二种方法中的库<a href="https://learn.adafruit.com/raspberry-pi-analog-to-digital-converters" target="_blank" rel="noopener">在这里往下翻翻</a></li><li>第二种方法中的<code>adafruit-circuitpython-mcp3xxx</code>库有个注意点，虽然MCP是10位精度的，也就是转换的最大值本应该是1023，但用这个方法的时候默认返回16位精度的值，为了与ADS1x15系列的借口保持统一，所以结果要么右移6位，要么就当成是16位精度也行。</li></ul><p>另外的,在<code>gpiozero</code>中，有下列方法实例化模数转换器：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gpiozero <span class="hljs-keyword">import</span> MCP3008MCP3008(channel=<span class="hljs-number">0</span>)MCP3008(channel=<span class="hljs-number">0</span>, device=<span class="hljs-number">0</span>)MCP3008(channel=<span class="hljs-number">0</span>, port=<span class="hljs-number">0</span>, device=<span class="hljs-number">0</span>)MCP3008(channel=<span class="hljs-number">0</span>, select_pin=<span class="hljs-number">8</span>)MCP3008(channel=<span class="hljs-number">0</span>, clock_pin=<span class="hljs-number">11</span>, mosi_pin=<span class="hljs-number">10</span>, miso_pin=<span class="hljs-number">9</span>, select_pin=<span class="hljs-number">8</span>)</code></pre></div></p><p>上面<code>device=0（默认） 或者device=1</code>，其实默认意味着MCP3008的<strong>cs</strong>引脚接的是<strong>GPIO08</strong>（也就是SPI0_CE0_N），所以<code>device=1</code>意味着接的<strong>GPIO07</strong></p><p>我一开始以为<strong>cs</strong>引脚只能接这两个，后来发现，所有通用<strong>IO</strong>引脚都能接，只要加个<code>select_pin</code>参数，简简单单，好用的。</p><p><strong>Arduino是自带模数转换功能，实在着急，先用个Arduino救救急，不展开～</strong></p>]]></content>
    
    
    <categories>
      
      <category>RaspberryPi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 yield from 用法详解</title>
    <link href="/2020/01/12/python-yield-from/"/>
    <url>/2020/01/12/python-yield-from/</url>
    
    <content type="html"><![CDATA[<p><code>yield from</code>是Python3.3以后全新的语言结构，它的作用比<code>yield</code>多得多，因此人们认为继续使用那个关键字多少会引起误解。在其他语言中，类似的结构使用<code>await</code>关键字，这个名称就好多了。当然，后面Python也改成了<code>await</code>，这个我们在结尾说，少废话，先看东西。</p><h2 id="1-替代内层for循环"><a href="#1-替代内层for循环" class="headerlink" title="1. 替代内层for循环"></a>1. 替代内层for循环</h2><p>如果生成器函数需要产出另一个生成器生成的值，传统的解决方法是使用嵌套的for循环：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chain</span><span class="hljs-params">(*iterables)</span>:</span>...<span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> iterables:...<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:...<span class="hljs-keyword">yield</span> i<span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">'ABC'</span><span class="hljs-meta">&gt;&gt;&gt; </span>t = tuple(range(<span class="hljs-number">3</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>list(chain(s, t))[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</code></pre></div></p><p>chain 生成器函数把操作依次交给接收到的各个可迭代对象处理。<br><div class="hljs"><pre><code class="hljs python">Python3<span class="hljs-number">.3</span>之后引入了新语法：<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chain</span><span class="hljs-params">(*iterables)</span>:</span><span class="hljs-meta">... </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iterables:<span class="hljs-meta">... </span><span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> i...<span class="hljs-meta">&gt;&gt;&gt; </span>list(chain(s, t))[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</code></pre></div></p><ul><li><code>yield from</code> 完全代替了内层的 for 循环。</li><li><code>yield from x</code> 表达式对 x 对象所做的第一件事是，调用 iter(x)，从中获取迭代器。因此，x 可以是任何可迭代的对象。</li><li>在这个示例中使用 <code>yield from</code>代码读起来更顺畅，不过感觉更像是语法糖。 </li></ul><p>上面这个例子看上去比较简单（传统意义上说因为我们只是for循环一次就完事，因为只嵌套了一层），我们再来看几个<code>yield from</code>的例子。<br><strong>例子1：我们有一个嵌套型的序列，想将它扁平化处理为一列单独的值。</strong><br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Iterable<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatten</span><span class="hljs-params">(items, ignore_types=<span class="hljs-params">(str, bytes)</span>)</span>:</span><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> items:<span class="hljs-keyword">if</span> isinstance(x, Iterable) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> isinstance(x, ignore_types):<span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> flatten(x)<span class="hljs-keyword">else</span>:<span class="hljs-keyword">yield</span> xitems = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-number">7</span>], <span class="hljs-number">8</span>]<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> flatten(items):print(x)<span class="hljs-comment"># output：</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span>-----------------------------------------------items = [<span class="hljs-string">'Dave'</span>, <span class="hljs-string">'Paula'</span>, [<span class="hljs-string">'Thomas'</span>, <span class="hljs-string">'Lewis'</span>]]<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> flatten(items):print(x)<span class="hljs-comment"># output：</span>DavePaulaThomasLewis</code></pre></div></p><ul><li><code>collections.Iterable</code>是一个抽象基类，我们用<code>isinstance(x, Iterable)</code>检查某个元素是否是可迭代的.如果是的话,那么就用<code>yield from</code>将这个可迭代对象作为一种子例程进行递归。最终返回结果就是一个没有嵌套的单值序列了。</li><li>代码中额外的参数<code>ignore types</code>和检测语句<code>isinstance(x, ignore types)</code>用来将字符<br>串和字节排除在可迭代对象外，防止将它们再展开成单个的字符。<ul><li>如果这里不用<code>yield from</code>的话，那么就需要另外一个for来嵌套，并不是一种优雅的操作</li></ul></li></ul><p><strong>例子2：利用一个Node类来表示树结构</strong><br><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>self._value = valueself._children = []<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span><span class="hljs-keyword">return</span> <span class="hljs-string">'Node(&#123;!r&#125;)'</span>.format(self._value)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_child</span><span class="hljs-params">(self, node)</span>:</span>self._children.append(node)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span><span class="hljs-keyword">return</span> iter(self._children)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depth_first</span><span class="hljs-params">(self)</span>:</span><span class="hljs-keyword">yield</span> self<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> self:<span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> c.depth_first()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:root = Node(<span class="hljs-number">0</span>)child1 = Node(<span class="hljs-number">1</span>)child2 = Node(<span class="hljs-number">2</span>)root.add_child(child1)root.add_child(child2)child1.add_child(Node(<span class="hljs-number">3</span>))child1.add_child(Node(<span class="hljs-number">4</span>))child2.add_child(Node(<span class="hljs-number">5</span>))<span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> root.depth_first():print(ch)</code></pre></div></p><ul><li><code>__iter__</code>代表一个Pyton的迭代协议，返回一个迭代器对象,就能迭代了</li><li><code>depth_frist</code>返回一个生成器，仔细体会其中的<code>yield</code>与 <code>yield from</code>用法</li></ul><p>上面两个例子无论是树还是嵌套序列，都比较复杂，观察这里<code>yield from</code>跟的是什么,跟的是函数,生成器函数,而且都是在函数内递归。虽然我也不是理解的很透彻 =,= 。但现在应该知道，这是<code>yield from</code>一种常用的方法了（认真体会，手动滑稽）。</p><h2 id="2-打开双通道"><a href="#2-打开双通道" class="headerlink" title="2. 打开双通道"></a>2. 打开双通道</h2><p>如果 <code>yield from</code> 结构唯一的作用是替代产出值的嵌套 for 循环，这个结构很有可能不会添加到 Python 语言中。<code>yield from</code> 结构的本质作用无法通过简单的可迭代对象说明，而要发散思维，使用嵌套的生成器。<br><strong>yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职责。</strong><br>这里有张详细图来说明三者关系:<a href="http://flupy.org/resources/yield-from.pdf" title="委派生成器,子生成器与调用方" target="_blank" rel="noopener">http://flupy.org/resources/yield-from.pdf</a><br>例子就不展开了，有兴趣的童鞋可以去 <strong>Fluent Python</strong>这本书上 查看 <strong>示例16-17</strong>。并且结合示例图好好体会（我也有待好好体会）</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li><p><code>yield from</code>伴随着Python3.4新加入的asyncio模块得以发扬光大, <code>asynico + yield from</code>双枪组合，但当时定义协程还是需要<code>@asyncio.coroutine</code>装饰器，之前都是我们手工切换协程，现在当声明函数为协程后，我们通过事件循环来调度协程</p></li><li><p>从Python 3.5开始引入了新的语法 <code>async</code> 和 <code>await</code> ，<code>yield from</code>换成了<code>await</code>（为了不与实现内层for循环的<code>yield from</code>误解？！），<code>@asyncio.coroutine</code>换成了<code>async</code>， <code>asynico + await</code>成了新的双枪组合，一直到未来… 从Python设计的角度来说，它们让协程表面上独立于生成器而存在，将细节都隐藏于<code>asyncio</code>模块之下，语法更Pythonic。</p></li><li><p>从Python3.5加入以来，<code>asynico</code>官方文档有点混乱，毕竟是新模块，语法也一直在变换中，到了Python 3.7，3.8才趋于稳定，文档也好像重写了，清晰明了，如果要细品<code>asynico</code>，那么不如看最新文档搞起来，能节省不少功夫！。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>yield from</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python yield使用详解（二）</title>
    <link href="/2020/01/06/python-yield-2/"/>
    <url>/2020/01/06/python-yield-2/</url>
    
    <content type="html"><![CDATA[<p>yield的第二部分主要是with模块的功能，即上下文管理器。我们可以用<code>contextmanager</code>装饰器加上<code>yield</code>语法代替传统的<code>__enter__</code>，<code>__exit__</code>魔法方法，让代码变得更Pythonic！</p><h2 id="1-上下文管理器和with块"><a href="#1-上下文管理器和with块" class="headerlink" title="1. 上下文管理器和with块"></a>1. 上下文管理器和with块</h2><h3 id="1-1-with表达式"><a href="#1-1-with表达式" class="headerlink" title="1.1 with表达式"></a>1.1 with表达式</h3><p>常见的with用法格式，控制代码块的<code>进入/退出</code>：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> f:    statement    statement ...<span class="hljs-keyword">with</span> lock:    statement    statement ...</code></pre></div></p><h3 id="1-2-定制你自己的上下文管理器"><a href="#1-2-定制你自己的上下文管理器" class="headerlink" title="1.2 定制你自己的上下文管理器"></a>1.2 定制你自己的上下文管理器</h3><p>一个计时器的例子：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<span class="hljs-meta">@contextmanager</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timethis</span><span class="hljs-params">(label)</span>:</span>    start = time.time()    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">yield</span>     <span class="hljs-keyword">finally</span>:        end = time.time()        print(<span class="hljs-string">'%s: %0.3f'</span> % (label, end-start))<span class="hljs-comment">#Usage</span><span class="hljs-keyword">with</span> timethis(<span class="hljs-string">'counting'</span>):     n = <span class="hljs-number">1000000</span>     <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:         n -= <span class="hljs-number">1</span><span class="hljs-comment">#Output</span>counting: <span class="hljs-number">0.156</span></code></pre></div></p><p>另外一个例子：临时文件夹<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tempfile, shutil<span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<span class="hljs-meta">@contextmanager</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tempdir</span><span class="hljs-params">()</span>:</span>    outdir = tempfile.mkdtemp()    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">yield</span> outdir    <span class="hljs-keyword">finally</span>:        shutil.rmtree(outdir)<span class="hljs-comment">#Example</span><span class="hljs-keyword">with</span> tempdir() <span class="hljs-keyword">as</span> dirname:    ...</code></pre></div></p><p><strong>等等！！！</strong>，<strong>这里的<code>yield outdir</code>是什么？</strong></p><ul><li>不是迭代</li><li>不是数据流</li><li>不是并发</li><li>那是什么？？？</li></ul><h2 id="2-深入上下文管理器"><a href="#2-深入上下文管理器" class="headerlink" title="2. 深入上下文管理器"></a>2. 深入上下文管理器</h2><p>现在可以对上面内容进行小结一下：</p><ul><li>上下文对象存在的目的是管理<code>with</code>语句，就像迭代器的存在是为了管理<code>for</code>语句</li><li>with语句的目的是简化t<code>try/finally</code>模式，这种模式用于保证一段代码运行完毕后执行某项操作。即使那段代码由于异常，<code>return</code>语句或<code>sys.exit()</code>调用而终止，也会执行指定操作</li></ul><p><strong>上下文管理器的内部实现：</strong><br><img src="/images/yield/yield2_1.png" srcset="/img/loading.gif" alt></p><ul><li>上下文管理器协议包含<strong>enter</strong>和<strong>exit</strong>两个方法，<code>with</code>语句还是运行时，会在上下文管理器对象上调用<strong>enter</strong>方法。with语句结束后，会在上下文管理器对象上调用<strong>exit</strong>方法，以此扮演finally子句的角色</li></ul><p><strong>实现模板</strong><br><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> value    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, val, tb)</span>:</span>        <span class="hljs-keyword">if</span> exc_type <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># Handle an exception (if you want)</span>           <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> handled <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span> <span class="hljs-comment"># Usage         </span><span class="hljs-keyword">with</span> Manager() <span class="hljs-keyword">as</span> value:    statements    statements</code></pre></div></p><p><strong>实例</strong><br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tempfile<span class="hljs-keyword">import</span> shutil<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">tempdir</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>        self.dirname = tempfile.mkdtemp()  <span class="hljs-comment">#生成临时文件夹</span>        <span class="hljs-keyword">return</span> self.dirname    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc, val, tb)</span>:</span>        shutil.rmtree(self.dirname)   <span class="hljs-comment">#删除文件夹</span><span class="hljs-comment"># Usage  </span><span class="hljs-keyword">with</span> tempdir() <span class="hljs-keyword">as</span> dirname:...<span class="hljs-comment"># with语句运行完毕后，会自动删除那个临时文件夹</span></code></pre></div></p><h2 id="3-更简洁的一种选择：利用-contextmanager装饰器"><a href="#3-更简洁的一种选择：利用-contextmanager装饰器" class="headerlink" title="3. 更简洁的一种选择：利用@contextmanager装饰器"></a>3. 更简洁的一种选择：利用@contextmanager装饰器</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tempfile, shutil<span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<span class="hljs-meta">@contextmanager</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tempdir</span><span class="hljs-params">()</span>:</span>    dirname = tempfile.mkdtemp()    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">yield</span> dirname    <span class="hljs-keyword">finally</span>:        shutil.rmtree(dirname) <span class="hljs-comment"># 跟上个例子相同的代码。</span></code></pre></div><h3 id="3-1-contextmanager装饰器运行原理"><a href="#3-1-contextmanager装饰器运行原理" class="headerlink" title="3.1 contextmanager装饰器运行原理"></a>3.1 contextmanager装饰器运行原理</h3><p>下图：<br><img src="/images/yield/yield2_2.png" srcset="/img/loading.gif" alt></p><ul><li>思考剪刀处<code>yield</code>代码</li><li>将代码一分两半</li></ul><p><img src="/images/yield/yield2_3.png" srcset="/img/loading.gif" alt></p><ul><li>每一半对应着上下文管理器协议</li><li><code>yield</code>是促成图中这一实现的魔法</li></ul><p>这里有一个注意点：使用<code>@contextmanager</code>装饰器时，要把yield语句放在<code>try/finally</code>语句中,这是无法避免的，因为我们永远不知道上下文管理器的用户会在with中做什么(会引发一些python解释器能捕获到的错误)。<br>当然，想要你如果想要更加深入的了解<code>@contextmanager</code>的内部代码实现，可以查看源代码，这里不展开了。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ol><li><code>yield</code>表达式的另一个不同作用:上下文管理器</li><li>常用来重新定制控制流</li><li>也可以用<code>@contextmanager</code>装饰器来代替<strong>enter</strong>和<strong>exit</strong>两个方法。优雅且实用，把三个不同的Python特性结合到一起： 函数装饰器，生成器和<code>with</code>语句</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>yield</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python yield使用详解（一）</title>
    <link href="/2020/01/02/python-yield-1/"/>
    <url>/2020/01/02/python-yield-1/</url>
    
    <content type="html"><![CDATA[<p>刚学到yield这个较为陌生的语法时，一头埋了进去，自认为较为全面的学习到了精髓。结果码了这么多代码好像也没用到过多少次这个关键字，直接扑街。记得工作经验只有一年的时候我出去面了个试，人家问我yield作用是什么，我很自信，一个劲地回答道协程协程，结果好像不太满意，人家一说生成器，奥，恍然大悟，竟然把最基本的语法忘了。所以现在看来，yield是否在协程异步方面有着不可代替的作用，必须出现它呢，那就从篇文章往下看。</p><h2 id="1-生成器"><a href="#1-生成器" class="headerlink" title="1. 生成器"></a>1. 生成器</h2><p><strong>yield语句可以作为生成器</strong><br><div class="hljs"><pre><code class="hljs python">def countdown(n):    while n &gt; 0:        yield n        n -= 1# 可以当迭代器来使用它for x in countdown(10):    print('T-minus', x)# 可以使用next()来产出值，当生成器函数return(结束)时，报错。&gt;&gt;&gt; c = countdown(3)&gt;&gt;&gt; c&lt;generator object countdown at 0x10064f900&gt;&gt;&gt;&gt; next(c)3&gt;&gt;&gt; next(c)2&gt;&gt;&gt; next(c)1&gt;&gt;&gt; next(c)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in ?StopIteration</code></pre></div></p><p>这篇文章我着重讲yield作为<code>协程</code>的使用方法，作为生成器的话我一笔带过，想要仔细了解<code>迭代器</code>与<code>生成器</code>使用，我这里推荐个教程。<a href="https://foofish.net/iterators-vs-generators.html" target="_blank" rel="noopener">完全理解Python迭代对象、迭代器、生成器</a> ，很棒，还有的话就是与生成器密切相关的itertools模块，可以了解下。但是我在讲<code>yield协程</code>之前我再给出一张图来说yield一个有趣的用法。 </p><p><strong>生成器类似于UNIX管道的作用</strong></p><p><img src="/images/yield/yield1_1.png" srcset="/img/loading.gif" alt></p><p>这个process会有难以置信的作用，比如实现UNIX中grep的作用。不展开，以后肯定会用到它。</p><h2 id="2-生成器进化为协程"><a href="#2-生成器进化为协程" class="headerlink" title="2. 生成器进化为协程"></a>2. 生成器进化为协程</h2><h3 id="2-1-一个协程例子"><a href="#2-1-一个协程例子" class="headerlink" title="2.1 一个协程例子"></a>2.1 一个协程例子</h3><p>重头戏来了。<br>如果你想更多的使用yield，那么就是协程了。<strong>协程就不仅仅是产出值了，而是能消费发送给它的值。</strong><br>那么这里的例子就用协程实现上面的UNIX的grep作用<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grep</span><span class="hljs-params">(pattern)</span>:</span>    print(<span class="hljs-string">"Looking for &#123;&#125;"</span>.format(pattern))    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        line = <span class="hljs-keyword">yield</span>        <span class="hljs-keyword">if</span> pattern <span class="hljs-keyword">in</span> line:            print(<span class="hljs-string">'&#123;&#125; : grep success '</span>.format(line))<span class="hljs-meta">&gt;&gt;&gt; </span>g=grep(<span class="hljs-string">'python'</span>)<span class="hljs-comment"># 还是个生成器</span><span class="hljs-meta">&gt;&gt;&gt; </span>g&lt;generator object grep at <span class="hljs-number">0x7f17e86f3780</span>&gt;  <span class="hljs-comment"># 激活协程！只能用一次，也可以用g.send(None)来代替next(g)</span><span class="hljs-meta">&gt;&gt;&gt; </span>next(g)Looking <span class="hljs-keyword">for</span> python<span class="hljs-comment"># 使用.send(...)发送数据，发送的数据会成为生成器函数中yield表达式值，即变量line的值</span><span class="hljs-meta">&gt;&gt;&gt; </span>g.send(<span class="hljs-string">"Yeah, but no, but yeah, but no"</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>g.send(<span class="hljs-string">"A series of tubes"</span>)<span class="hljs-comment"># 协程，协程，就是互相协作的程序，我发数据过去然后你协助我一下看看grep成功没</span><span class="hljs-meta">&gt;&gt;&gt; </span>g.send(<span class="hljs-string">"python generators rock!"</span>)python generators rock! : grep success <span class="hljs-comment"># 关闭</span><span class="hljs-meta">&gt;&gt;&gt; </span>g.close()</code></pre></div></p><p>例子讲完了。有几个注意点：</p><ul><li>生成器用于生成供迭代的数据</li><li>协程是数据的消费者</li><li>为了避免脑袋炸裂，不能把两个概念混为一谈</li><li>协程与迭代无关</li><li>注意，虽然在协程值会使用yield产出值，但这与迭代无关</li></ul><h3 id="2-2-发送数据给协程"><a href="#2-2-发送数据给协程" class="headerlink" title="2.2 发送数据给协程"></a>2.2 发送数据给协程</h3><p><img src="/images/yield/yield1_2.png" srcset="/img/loading.gif" alt></p><p>预激活，到yield处暂停。然后发送item值，协程继续了，协程中item接收到发送的那个值，然后到下一个yield再暂停。</p><h3 id="2-3-使用一个装饰器"><a href="#2-3-使用一个装饰器" class="headerlink" title="2.3 使用一个装饰器"></a>2.3 使用一个装饰器</h3><p>如果不预激(<code>primer</code>),那么协程没什么用，调用g.send(x)之前。记住一定要调用next(g)。为了简化协程用法，有时会使用一个预激装饰器，如下。<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coroutine</span><span class="hljs-params">(func)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">primer</span><span class="hljs-params">(*args,**kwargs)</span>:</span>        cr = func(*args,**kwargs)        next(cr)        <span class="hljs-keyword">return</span> cr    <span class="hljs-keyword">return</span> primer<span class="hljs-meta">@coroutine</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grep</span><span class="hljs-params">(pattern)</span>:</span> ...</code></pre></div></p><h3 id="2-4-关闭一个协程"><a href="#2-4-关闭一个协程" class="headerlink" title="2.4 关闭一个协程"></a>2.4 关闭一个协程</h3><ul><li>一个协程有可能永远运行下去</li><li>可以 .close()让它停下来<br>例子中已经体现，不展开。</li></ul><h3 id="2-5-捕捉close"><a href="#2-5-捕捉close" class="headerlink" title="2.5 捕捉close()"></a>2.5 捕捉close()</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grep</span><span class="hljs-params">(pattern)</span>:</span>    print(<span class="hljs-string">"Looking for &#123;&#125;"</span>.format(pattern))    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            line = <span class="hljs-keyword">yield</span>            <span class="hljs-keyword">if</span> pattern <span class="hljs-keyword">in</span> line:                print(line)    <span class="hljs-keyword">except</span> GeneratorExit:        print(<span class="hljs-string">"Going away. Goodbye"</span>)</code></pre></div><p>捕捉到.close()方法，然后会打印<code>&quot;Going away. Goodbye&quot;</code>。</p><h3 id="2-6-抛出异常"><a href="#2-6-抛出异常" class="headerlink" title="2.6 抛出异常"></a>2.6 抛出异常</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>g = grep(<span class="hljs-string">"python"</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>next(g) <span class="hljs-comment"># Prime it</span>Looking <span class="hljs-keyword">for</span> python<span class="hljs-meta">&gt;&gt;&gt; </span>g.send(<span class="hljs-string">"python generators rock!"</span>)python generators rock! : grep success <span class="hljs-meta">&gt;&gt;&gt; </span>g.throw(RuntimeError,<span class="hljs-string">"You're hosed"</span>)Traceback (most recent call last):..........RuntimeError: Yo<span class="hljs-string">u're hosed&gt;&gt;&gt;</span></code></pre></div><p>说明：</p><ul><li>在协程内部能抛出一个异常</li><li>异常发生于yield表达式</li><li>不慌，我们可以平常的方法处理它</li></ul><h3 id="2-7-生成器返回数值"><a href="#2-7-生成器返回数值" class="headerlink" title="2.7 生成器返回数值"></a>2.7 生成器返回数值</h3><p>鉴于上面的例子是一直run下去的，所以稍加修改：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grep</span><span class="hljs-params">(pattern)</span>:</span>    print(<span class="hljs-string">"Looking for &#123;&#125;"</span>.format(pattern))    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        line = <span class="hljs-keyword">yield</span>        <span class="hljs-comment"># 当发送的数据为None时，跳出while循环</span>        <span class="hljs-keyword">if</span> line <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> pattern <span class="hljs-keyword">in</span> line:                print(<span class="hljs-string">'&#123;&#125; : grep success '</span>.format(line))    <span class="hljs-keyword">return</span> <span class="hljs-string">'End'</span><span class="hljs-meta">&gt;&gt;&gt; </span>..... 省略<span class="hljs-meta">&gt;&gt;&gt; </span>g.send(<span class="hljs-literal">None</span>)Traceback (most recent call last): ... ...StopIteration: End<span class="hljs-comment"># 这里可以用try捕捉异常，异常对象的value属性保存着返回的值</span>    <span class="hljs-keyword">try</span>:        g.send(<span class="hljs-literal">None</span>)    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> exc:        result = exc.value<span class="hljs-meta">&gt;&gt;&gt; </span>result<span class="hljs-comment">#End</span></code></pre></div></p><p>   图解如下<br><img src="/images/yield/yield1_3.png" srcset="/img/loading.gif" alt></p><p>   说明：</p><ul><li>通过捕捉异常获取返回值</li><li>只支持python3</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li><code>yield</code>的基本用法已经差不多了，有两个方面：生成器与协程(理解协程的关键在于明白它在何处暂停发送出的数据传到了哪个变量)</li><li><code>yield</code>的另一方面的应用是上下文管理器下一节讲 </li><li><code>yield from</code>我这里暂时不讲，留到后面。<code>yield from</code>会在内部自动捕获<code>StopIteration</code>异常等</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>yield</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统中线程与进程概念解惑</title>
    <link href="/2019/12/31/thread-and-process/"/>
    <url>/2019/12/31/thread-and-process/</url>
    
    <content type="html"><![CDATA[<p>这篇文章总结本来记录于两年前，是在写Python多线程时对一些概念的疑惑的解答，当初查阅了很多资料，对于操作系统层面的线程进程概念很模糊。而今，随着Python版本的更新，本身异步的新特性逐渐完善，在学习异步的时候难免与常用的多进程多线程进行比较来说明异步的优越性，把以前的文章拿出来，并且在现在自己的理解上查阅一些资料进行适当修改，达到温故而知新的效果。</p><p>看了一天的相关概念,很多涉及到操作系统与底层硬件层面,脑子有点晕,对自己所理解的东西清理一下并记录下来,有些不对的地方还请指出.</p><h2 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1. 线程与进程"></a>1. 线程与进程</h2><p><strong>进程</strong>： </p><blockquote><p>我们都知道计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序侧是具有某种功能的程序，程序是运行于操作系统之上的。 (为了缓解头脑胀痛, 斜体字大体过一遍即可)<br><em>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序、数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</em></p></blockquote><p><strong>线程</strong>：</p><blockquote><p>在早期的操作系统中并没有线程的概念,在当时进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。进程间的通信与同步完全袭来操作系统内核转发与支持。<br>后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p></blockquote><p><strong>进程与线程的区别</strong>  </p><ol><li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位 （这句话一定要理解）；  </li><li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；  </li><li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；  </li><li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li></ol><p><strong>线程与进程关系的示意图：</strong><br><img src="/images/thread_and_process/线程与进程关系.png" srcset="/img/loading.gif" alt="线程与进程关系"></p><p><strong>某个进程中单线程与多线程的关系:</strong></p><h2 id><a href="#" class="headerlink" title></a><img src="/images/thread_and_process/单线程与多线程.png" srcset="/img/loading.gif" alt="单线程与多线程"></h2><p>从别处看到线程是进程的一个实体,是程序执行的最小单位(线程也被称为<strong>轻量级进程</strong>).<br>按照我的理解：QQ音乐正在运行,QQ音乐就是个进程,而这个进程中有多个线程在跑着(各有各的任务);我们平常编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。<br>如果我们要同时执行多个任务怎么办：一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务;还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务（之后详细讲）。  </p><h2 id="2-线程与cpu核心数的关系"><a href="#2-线程与cpu核心数的关系" class="headerlink" title="2. 线程与cpu核心数的关系"></a>2. 线程与cpu核心数的关系</h2><p>现在都是多核的处理器,那么在多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。  </p><blockquote><p>多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。<strong>内核线程</strong>（Kernel Thread， KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。<br>现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。  </p></blockquote><p>上面的应该可以理解,但是有个注意点：<strong>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程</strong>. 那为什么要说出上面那段文字呢? 我心中的困惑是：一般我们买的CPU包装盒上写的    <code>四核八线程</code>的”线程” 到底是什么线程?跟系统的线程是一个东东么?<a href="https://www.zhihu.com/question/274189552" target="_blank" rel="noopener">看这里</a></p><p>由于每个轻量级进程都需要一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。<br>下图中：K代表<strong>内核线程</strong>，LWP代表<strong>轻量级线程</strong>，U代表 <strong>用户线程</strong> </p><p><img src="/images/thread_and_process/内核线程用户线程.jpg" srcset="/img/loading.gif" alt="内核线程用户线程"></p><p>问题一：什么是用户线程?</p><blockquote><p>用户线程是完全建立在用户空间的线程库（比如python的threading库），用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。</p></blockquote><p>问题二:请简单解释下图中流程?</p><blockquote><p>还是上面的例子,当你运行一个python脚本时,等于创建可一个进程，光有进程没卵用，必须有程序执行的最小单位嘛，所以同时系统会创建一个LWP,程序就靠它运行，因为是第一个线程，也称它为主线程。然后，脚本跑着跑着，需要创建新的线程运行其他任务时，主线程程序安排一个”创建线程“的口号（比如调用一个线程库）来调用产生U。<br><a href="https://www.zhihu.com/question/25532384" target="_blank" rel="noopener">可以看这里</a>的回答，进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</p></blockquote><p>问题二：系统中有时会有那CPU核心数的数量影响着什么嘛？  </p><blockquote><p>（不是很确定），多核就是系统同时可以运行多个线程，比如双核可以<strong>同时</strong>执行两个线程。单核只能一次执行一个线程。<br>如果答案真如上面那样：那为什么能有百来个多线程同时存在？那么就可以引申到下面的话题了。</p></blockquote><h2 id="3-并发和并行"><a href="#3-并发和并行" class="headerlink" title="3. 并发和并行"></a>3. 并发和并行</h2><p><strong>并行（parallelism）</strong>：</p><blockquote><p>这个概念很好理解。所谓并行，就是同时执行的意思，无需过度解读（在日本跟台湾，翻译成平行，这就更好理解了）。判断程序是否处于并行的状态，就看同一时刻是否有超过一个“工作单位”在运行就好了。所以，单线程永远无法达到并行状态。<br>要达到并行状态，最简单的就是利用多线程和多进程。但是 Python 的多线程由于存在著名的 GIL，无法让两个线程真正“同时运行”，所以实际上是无法到达并行状态的。  </p></blockquote><p>那么对于上面的问题三，我们是否可以认为，一个四核八线程的CPU，最多允许八个线程同时执行?某个时间点就只有八个,然后下一时间,其他八个再执行=.=（不展开。有点晕）</p><p>在并行性开发时，不但可以考虑多进程并行执行，而且还可以开发出进程内多线程并行的程序，如下图。</p><h2 id="-1"><a href="#-1" class="headerlink" title></a><img src="/images/thread_and_process/并行执行实现方法.jpg" srcset="/img/loading.gif" alt="并行执行实现方法"></h2><hr><hr><hr><p><strong>并发（concurrency）</strong>：  </p><blockquote><p>要理解“并发”这个概念，必须得清楚，并发指的是程序的“结构”。当我们说这个程序是并发的，实际上，这句话应当表述成“这个程序采用了支持并发的设计”。好，既然并发指的是人为设计的结构，那么怎样的程序结构才叫做支持并发的设计<br><strong>正确的并发设计的标准是：使多个操作可以在重叠的时间段内进行(two tasks can start, run, and complete in overlapping time periods)。</strong>  </p></blockquote><p>这句话的重点有两个。我们先看“（操作）在重叠的时间段内进行”这个概念。它是否就是我们前面说到的并行呢？是，也不是。并行，当然是在重叠的时间段内执行，但是另外一种执行模式，也属于在重叠时间段内进行。这就是<strong>协程</strong>(或者简单点多线程也可以,然后把task1，task2改成线程1，线程2)。<br>使用协程时，程序的执行看起来往往是这个样子：</p><p><img src="/images/thread_and_process/协程.jpg" srcset="/img/loading.gif" alt="协程"></p><p><strong>task1, task2 是两段不同的代码，比如两个函数，其中黑色块代表某段代码正在执行。注意，这里从始至终，在任何一个时间点上都只有一段代码在执行，但是，由于 task1 和 task2 在重叠的时间段内执行，所以这是一个支持并发的设计。与并行不同，单核单线程能支持并发（特指协程）。</strong></p><p>那么，如何实现支持并发的设计？两个字：拆分。<br>之所以并发设计往往需要把流程拆开，是因为如果不拆分也就不可能在同一时间段进行多个任务了。这种拆分可以是平行的拆分，比如抽象成同类的任务，也可以是不平行的，比如分为多个步骤。  </p><p><strong>并发和并行的区别</strong>：<br>并行指物理上同时执行，并发指能够让多个任务在逻辑上交织执行的程序设计</p><h2 id="3-同步和异步理解"><a href="#3-同步和异步理解" class="headerlink" title="3. 同步和异步理解"></a>3. 同步和异步理解</h2><p>这里我就简单举个例子就好了:web网页,点一下发送邮件按钮,然后发送（发送过程5秒）,发送成功之网页显示跳转成功。<br>同步：点了发送之后，慢慢等五秒，然后显示成功<br>异步：点了发送之后，直接显示成功，后台默默的还在发送，知道发送完毕。<br>关于阻塞啥的我这里就不提了，已经有些晕了。毕竟在python中有些集成的库已经将这些问题考虑进去了，不需要重复造轮子，具体可以看看<a href="https://cloud.tencent.com/developer/article/1187407" target="_blank" rel="noopener">这篇文章前半部分</a></p><h2 id="5-python的相关模块"><a href="#5-python的相关模块" class="headerlink" title="5. python的相关模块"></a>5. python的相关模块</h2><ul><li><code>threading</code> 多线程库</li><li><code>concurrent.futures</code>中的<code>ThreadpoolExecutor</code> 线程池</li><li><code>concurrent.futures</code>中的<code>ProcesspoolExecutor</code> 进程池</li><li><code>subprocess</code> 子进程</li><li><code>yield</code>关键字 协程</li><li><code>async</code>和<code>await</code>(python3.5新加入)  协程库</li></ul><h2 id="6-其他我想要说的几个点"><a href="#6-其他我想要说的几个点" class="headerlink" title="6. 其他我想要说的几个点"></a>6. 其他我想要说的几个点</h2><ol><li>在多线程这方面我代码中用的比较少.有时偶尔用到,我会直接选用<code>ThreadpoolExecutor</code>类。这个接口抽象层级很高，多线程直接使用，无需关心任何实现细节，啥线程死锁等问题都不需要担心。  </li><li>多线程在单cpu中其实也是顺序执行的，不过系统可以帮你切换那个执行而已，其实并没有快（反而慢）；多个cpu的话就可以在两个cpu中同时执行了。</li><li>接上面那一条，虽然python有GIL锁，启用多线程的时候只能用一个cpu核心，但python线程仍然适合I/O密集型应用:标准库中每个使用 C 语言编写的 I/O 函数都会释放 GIL，因此，当某个线程在等待 I/O 时， Python 调度程序会切换到另一个线程。 （意思就是说I/O操作的延迟大于过程中程序运行时间,我完全可以在延迟的时候,切换到其他线程，做其他操作，如下图情况C）<br><img src="/images/thread_and_process/单线程多线程.jpg" srcset="/img/loading.gif" alt="单线程多线程"></li></ol><ol start="4"><li><strong>多线程与协程的区别：协程执行效率极高，因为子程序切换（函数）不是线程切换，由程序自身控制，不像多线程那样要切换线程的开销。所以与多线程相比，线程的数量越多，协程性能的优势越明显。</strong></li></ol><p>相关链接：<br><a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="noopener">https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/</a><br><a href="https://lz5z.com/Python%E5%8D%8F%E7%A8%8B/" target="_blank" rel="noopener">https://lz5z.com/Python%E5%8D%8F%E7%A8%8B/</a><br><a href="http://blog.csdn.net/luoweifu/article/details/46595285" target="_blank" rel="noopener">http://blog.csdn.net/luoweifu/article/details/46595285</a><br><a href="http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-process-thread.html" target="_blank" rel="noopener">http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-process-thread.html</a><br><a href="http://blog.csdn.net/gatieme/article/details/51481863" target="_blank" rel="noopener">http://blog.csdn.net/gatieme/article/details/51481863</a><br><a href="http://www.cnblogs.com/caihuafeng/p/5438753.html" target="_blank" rel="noopener">http://www.cnblogs.com/caihuafeng/p/5438753.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT知识指南以及在Python的应用</title>
    <link href="/2019/12/10/python-mqtt/"/>
    <url>/2019/12/10/python-mqtt/</url>
    
    <content type="html"><![CDATA[<p>谈到物联网就会谈到MQTT协议，之前一段时间我虽然在书上看到过，也是粗略一看也没深究，主要自己只是维度不够，项目中也没有用到，就不了了之了。最近老板找了个架构师准备用心好好搞一搞公司那个平台，提出新的架构，用到了MQTT协议，用心研究了一番，发现以前写了好多的功能都是MQTT自带的，花了好多时间重复造轮子。最近看了好多相关的东西，虽然蛮多深层次的东西都没有摸到，但也有些了解，故搜集了一些资料有序的记录下来，大部分内容来自<a href="http://www.steves-internet-guide.com/" target="_blank" rel="noopener">Steve</a>以及<a href="https://mntolia.com/" target="_blank" rel="noopener">Maulin Tolia</a>的博客，十分感谢。</p><h2 id="1-MQTT基础"><a href="#1-MQTT基础" class="headerlink" title="1. MQTT基础"></a>1. MQTT基础</h2><p>图文并茂的<a href="https://mntolia.com/fundamentals-mqtt/" target="_blank" rel="noopener">MQTT基础学习</a>，后来又发现了个湾湾的<a href="https://swf.com.tw/?p=1002" target="_blank" rel="noopener">MQTT教学</a>，同为两岸同胞，感觉切实际更好一点</p><p>其他补充：</p><h3 id="1-1-关于MQTT版本："><a href="#1-1-关于MQTT版本：" class="headerlink" title="1.1 关于MQTT版本："></a>1.1 关于MQTT版本：</h3><p>最初的MQT T是在1999年设计的，已经使用了很多年，并且基于TCP/IP网络设计。<br>MQTTv3.1.1是常用版本。</p><ul><li>MQTT v3.1.0 – 几乎与3.1.1没什么区别</li><li>MQTT v3.1.1 – 常用的版本，想看底层的MQTT协议数据包结构，可以看<a href="http://www.steves-internet-guide.com/mqtt-protocol-messages-overview/" target="_blank" rel="noopener">这里</a></li><li>MQTT v5 – 当前受限使用，目前只有C语言客户端支持，<a href="http://www.steves-internet-guide.com/mqttv5/" target="_blank" rel="noopener">新功能阐述</a>以及<a href="https://github.com/wialon/gmqtt" target="_blank" rel="noopener">正在开发的Python客户端</a></li><li>MQTT-SN – 旨在通过UDP，ZigBee和其他传输进行工作,但当前并不流行</li></ul><h3 id="1-2-关于MQTT与HTTP"><a href="#1-2-关于MQTT与HTTP" class="headerlink" title="1.2 关于MQTT与HTTP"></a>1.2 关于MQTT与HTTP</h3><ul><li><a href="https://www.linkedin.com/pulse/internet-things-http-vs-websockets-mqtt-ronak-singh-cspo/" target="_blank" rel="noopener">物联网：协议之战（HTTP，Websocket和MQTT）</a></li><li><a href="https://medium.com/mqtt-buddy/mqtt-vs-http-which-one-is-the-best-for-iot-c868169b3105" target="_blank" rel="noopener">MQTT与HTTP：哪种是IoT的最佳选择？</a></li><li><a href="https://flespi.com/blog/http-vs-mqtt-performance-tests" target="_blank" rel="noopener">HTTP与MQTT性能测试</a></li></ul><h3 id="1-3-基于websocket的MQTT"><a href="#1-3-基于websocket的MQTT" class="headerlink" title="1.3 基于websocket的MQTT"></a>1.3 基于websocket的MQTT</h3><p>Websockets允许直接在Web浏览器中接收MQTT数据,Javascript MQTT Client提供了对Web浏览器的MQTT websocket支持<br><a href="http://www.steves-internet-guide.com/mqtt-websockets/" target="_blank" rel="noopener">Using MQTT Over WebSockets with Mosquitto</a><br><a href="https://www.thomaslaurenson.com/blog/2018/07/10/mqtt-web-application-using-javascript-and-websockets/" target="_blank" rel="noopener">MQTT Web Application Using JavaScript and Paho MQTT Library</a></p><h3 id="1-4-MQTT客户端"><a href="#1-4-MQTT客户端" class="headerlink" title="1.4 MQTT客户端"></a>1.4 MQTT客户端</h3><p>对于MQTTv3.1.1，基本可以在所有系统上使用所有的编程语言，例子中最常见的是基本就是<code>Python</code>以及<code>Node.js</code></p><h3 id="1-5-常见的broker"><a href="#1-5-常见的broker" class="headerlink" title="1.5 常见的broker"></a>1.5 常见的broker</h3><p>第一个它是按mqtt broker地址公有私有来分，旨在区分哪些能直接测试用，哪些自己搭建：<br><a href="https://mntolia.com/10-free-public-private-mqtt-brokers-for-testing-prototyping/" target="_blank" rel="noopener">10 Free Public &amp; Private MQTT Brokers(For Testing &amp; Production)</a><br>而第二种是根据自建需求对比不同的broker：<br><a href="http://www.bewindoweb.com/244.html" target="_blank" rel="noopener">MQTT Broker的需求和各大Broker对比</a></p><h3 id="1-6-MQTT安全机制简介"><a href="#1-6-MQTT安全机制简介" class="headerlink" title="1.6 MQTT安全机制简介"></a>1.6 MQTT安全机制简介</h3><ul><li>Client ids</li><li>Usernames and passwords （Restricting Access to topics）</li><li>Client Certificates  （Restricting Access to topics）</li></ul><p>具体看<a href="http://www.steves-internet-guide.com/mqtt-security-mechanisms/" target="_blank" rel="noopener">Introduction to MQTT Security Mechanisms</a></p><h2 id="2-Python-MQTT使用"><a href="#2-Python-MQTT使用" class="headerlink" title="2. Python MQTT使用"></a>2. Python MQTT使用</h2><p>Python mqtt客户端有很多库，特意找了篇文章进行了比较：<a href="https://flespi.com/blog/benchmarking-popular-mqtt-json-implementations" target="_blank" rel="noopener">Benchmarking popular MQTT + JSON implementations</a></p><p>一开始看的<a href="https://mntolia.com/mqtt-python-with-paho-mqtt-client/" target="_blank" rel="noopener">MQTT Python With Paho-MQTT (Beginner’s Guide With Example)</a>,然后是一些基础功能的使用，persistend session , qos level, retained messeges, last will基本都能在<a href="https://mntolia.com/" target="_blank" rel="noopener">Maulin Tolia</a>的博客找到，一目了然</p><blockquote><p>要深究基本用法的各个参数以及对象，就要先了解整个mqtt的过程以及一些机制，参数与机制一一对应，就比如client.connection方法中的keepalive参数，或者loop_forever与loop_start区别与mqtt自身心跳机制的关系</p></blockquote><p>这些进阶的内容可以在<a href="http://www.steves-internet-guide.com/" target="_blank" rel="noopener">人气非常高的steve mqtt博客上</a>看到，比如<a href="http://www.steves-internet-guide.com/category/python-mqtt-projects/" target="_blank" rel="noopener">Python MQTT实际应用以及项目专栏</a>，面面俱到，并且详细到啥都有~</p><p><strong>虽然篇幅不多，但贴了好多链接，你品，你品，你细细品，OVER ～</strong></p>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
      <tag>MQTT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django admin后台常用设置汇总</title>
    <link href="/2019/12/09/django-admin-action/"/>
    <url>/2019/12/09/django-admin-action/</url>
    
    <content type="html"><![CDATA[<p>一开始学Django的时候基本都有接触django admin管理员后台，但是之后的开发基本很少用，写API测试的时候要修好后台数据基本都是命令行或者数据库直接修改，完全没有接触到admin。但是最近方便公司订饭，写了个订饭系统，前后端分离，本想让前端根据登录员工判断是否是管理员角色，然后在页面上增加管理员操作元素，有点麻烦，。之后，我直接傻了，拍了下自己头，为啥不用django自带的管理员后台呢，好用方便快捷。</p><h2 id="1-信手拈来"><a href="#1-信手拈来" class="headerlink" title="1. 信手拈来"></a>1. 信手拈来</h2><p><a href="https://www.cnblogs.com/huchong/p/7894660.html" target="_blank" rel="noopener">Django admin 一些有用的设置</a><br><a href="https://www.jianshu.com/p/69e6f9c97b48" target="_blank" rel="noopener">如何修改django的app在admin中显示的名称</a></p><h2 id="2-柳暗花明"><a href="#2-柳暗花明" class="headerlink" title="2. 柳暗花明"></a>2. 柳暗花明</h2><p>在搜寻资料的过程中，反现了一本好书 <a href="https://books.agiliq.com/projects/django-admin-cookbook/en/latest/two_admin.html" target="_blank" rel="noopener">django-admin-cookbook</a>，我把各个topic翻译过来，以便以后方便翻阅。</p><ol><li>如何更改“ Django admin”文本？ （常用的site_header，site_title，index_title）</li><li>如何为Django 模型设置复数文本？ （verbose_name_plural参数）</li><li>如何创建两个独立的管理站点？ （继承AdminSite）</li><li>如何从“Django admin”删除默认app？ （比如默认的Groups Users）</li><li>如何为“Django admin”添加一个log？</li><li>如何覆盖“Django admin”的页面模板？</li><li>如何在列表视图页面上显示计算字段？ (其他Model可计算获得的字段)</li><li>如何在“Django admin”中优化查询？ （<code>get_queryset</code>方法覆盖）</li><li>如何启用对计算字段的排序？ （接第七条）</li><li>如何启用对计算字段的过滤？ （同上）</li><li>如何显示计算出的布尔字段的“开”或“关”图标？（同上）</li><li>如何在“Django admin”添加其他操作？ （actions）</li><li>如何从“Django admin”中导出CSV？</li><li>如何在“Django admin”删除“deleted”操作？</li><li>如何将自定义操作按钮（不是操作）添加到“Django admin”列表页面？</li><li>如何使用“Django admin”导入CSV？</li><li>如何将Django管理员限制为特定用户？ （<code>is_staff=True</code>，<code>is_superuser=True</code>）</li><li>如何限制对Django管理员部分的访问？ （<code>has_xxx_permission</code>等）</li><li>如何允许管理员只能创建一个对象？ (同上)</li><li>如何删除模型的“添加”或者“删除”按钮？ （同上）</li><li>如何让一位Django管理员编辑多个模型？ （需要使用内联）</li><li>如何将一对一关系添加为管理员内联？（同上）</li><li>如何在“Django admin”中添加嵌套的内联？ （同上）</li><li>如何为两个不同的模型创建一个“Django admin”？</li><li>如何在列表视图页面上显示更多行？ （<code>list_per_page</code>）</li><li>如何禁用分页？ （同上）</li><li>如何在“Django admin”中添加基于日期的过滤？ （<code>date_hierarchy = &#39;added_on&#39;</code>）</li><li>如何在列表视图页面上显示多对多或反转FK字段？</li><li>如何在”Django admin“中显示Imagefield中的图像？</li><li>保存时如何将模型与当前用户关联？</li><li>如何在”Django admin“中将字段标记为只读？ （<code>readonly_fields</code>）</li><li>如何在”Django admin“中显示不可编辑的字段 （同上）</li><li>如何使字段在创建时可编辑，但在现有对象中只能读取？ （<code>get_readonly_fields</code>）</li><li>如何在”django admin“中过滤FK下拉值？</li><li>如何使用带有大量对象的FK管理模型？</li><li>如何更改下拉菜单中的ForeignKey显示文本？</li><li>如何在”Django更改视图页面“中添加自定义按钮？</li><li>如何获取特定对象的”Django admin“ URL？</li><li>如何向”Django adimn“添加两次模型？</li><li>如何在”Django admin“覆盖保存行为？ （<code>save_model</code>）</li><li>如何将数据库视图添加到“Django admin”？</li><li>如何在“Django admin”中设置应用程序和模型的顺序？</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python -m 参数以及生僻运行命令汇总</title>
    <link href="/2019/10/17/python-m-option/"/>
    <url>/2019/10/17/python-m-option/</url>
    
    <content type="html"><![CDATA[<p>最近在翻阅剖析Python源码的时候讲到了内部Python变量的实现，以及当运行Python命令时，隐藏在内部的一些过程，于是<code>python3 --help</code>之后对某些运行参数产生了一些疑问，还涉及到了包与模块的内容，略微生僻，特此整理记录下～</p><h2 id="1-大杂烩"><a href="#1-大杂烩" class="headerlink" title="1. 大杂烩"></a>1. 大杂烩</h2><blockquote><p>旨在由用户直接执行的包含Python代码的纯文本文件通常称为<strong>脚本(script)</strong>，这是一个非正式术语，表示顶级程序文件。<br> 另一方面，包含设计用于从另一个Python文件导入和使用的Python代码的纯文本文件称为<strong>模块(modules)</strong>。</p></blockquote><h3 id="1-1-使用importlib导入模块"><a href="#1-1-使用importlib导入模块" class="headerlink" title="1.1 使用importlib导入模块"></a>1.1 使用importlib导入模块</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> importlibimportlib.import_module(<span class="hljs-string">'math'</span>)</code></pre></div><p>当我们想要导入自己写的<code>test.py</code>中的函数hello时，我们可以这样曲线救国: 首先每个模块导入后是一个对象(object), 它里面的各个变量都是以属性(attr)的形式挂靠在里面, 所以我们可以使用getattr来找到制定的函数</p><p><code>hello = getattr(importlib.import_module(&#39;test&#39;), &#39;hello&#39;)</code> 等价于<code>from test import hello</code></p><p>或者包中的某个模块：</p><p><code>ClassA = getattr(importlib.import_module(&#39;packege.module&#39;), &#39;ClassA&#39;)</code>等价于<br><code>from packege.module import ClassA</code></p><h3 id="1-2-重新导入"><a href="#1-2-重新导入" class="headerlink" title="1.2 重新导入"></a>1.2 重新导入</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<span class="hljs-keyword">import</span> math   <span class="hljs-comment"># Second import, which does nothing ,need to reload</span>importlib.reload(math)</code></pre></div><p>这里的注意点，<code>reload</code>函数是一个模块对象，而不是一个字符串</p><h3 id="1-3-使用-runpy-run-module-and-runpy-run-path-运行脚本"><a href="#1-3-使用-runpy-run-module-and-runpy-run-path-运行脚本" class="headerlink" title="1.3 使用 runpy.run_module() and runpy.run_path()运行脚本"></a>1.3 使用 runpy.run_module() and runpy.run_path()运行脚本</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> runpyrunpy.run_module(mod_name=<span class="hljs-string">'hello'</span>)runpy.run_path(file_path=<span class="hljs-string">'hello.py'</span>)</code></pre></div><h3 id="1-4-使用exec-运行脚本"><a href="#1-4-使用exec-运行脚本" class="headerlink" title="1.4 使用exec()运行脚本"></a>1.4 使用exec()运行脚本</h3><div class="hljs"><pre><code class="hljs python">exec(open(<span class="hljs-string">'hello.py'</span>).read())</code></pre></div><h3 id="1-5-python-c参数"><a href="#1-5-python-c参数" class="headerlink" title="1.5 python -c参数"></a>1.5 python -c参数</h3><div class="hljs"><pre><code class="hljs python">python -c <span class="hljs-string">"import math;print(math.pi)"</span></code></pre></div><h2 id="2-Python-m-参数"><a href="#2-Python-m-参数" class="headerlink" title="2. Python -m 参数"></a>2. Python -m 参数</h2><blockquote><p>-m参数显示为run library module as a script，常见于 <code>Python3 -m http.server 8080</code></p></blockquote><p>因为<code>http</code>是<strong>标准库</strong>（已经存在于sys.path中），这也是包，我们用<code>http.server</code>来调用server文件并把它作为脚本来运行，运行其中<code>__name__ == &quot;__main__&quot;</code>部分</p><p>那假设我们是自己创建的的包呢，那也是同样的道理，我们<a href="https://www.cnblogs.com/xueweihan/p/5118222.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">python自问自答：python -m参数？</a>，直接运行与-m运行的区别在于：<br><strong>直接启动脚本是把脚本所在的目录添加在sys.path中<br>-m模块启动脚本是把你输入命令的目录（也就是当前路径），放到了sys.path属性中</strong></p><h2 id="3-其他谈谈"><a href="#3-其他谈谈" class="headerlink" title="3. 其他谈谈"></a>3. 其他谈谈</h2><h3 id="3-1-当使用from-module-import-语句时，希望对从模块或包导出的符号进行精确控制时，定义一个变量-all-来明确地列出需要导出的内容（强烈反对使用-from-module-import-）"><a href="#3-1-当使用from-module-import-语句时，希望对从模块或包导出的符号进行精确控制时，定义一个变量-all-来明确地列出需要导出的内容（强烈反对使用-from-module-import-）" class="headerlink" title="3.1 当使用from module import * 语句时，希望对从模块或包导出的符号进行精确控制时，定义一个变量 all 来明确地列出需要导出的内容（强烈反对使用 from module import *）"></a>3.1 当使用<code>from module import *</code> 语句时，希望对从模块或包导出的符号进行精确控制时，定义一个变量 <strong>all</strong> 来明确地列出需要导出的内容（强烈反对使用 <code>from module import *</code>）</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># somemodule.py</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spam</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grok</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span>blah = <span class="hljs-number">42</span><span class="hljs-comment"># Only export 'spam' and 'grok'</span>__all__ = [<span class="hljs-string">'spam'</span>, <span class="hljs-string">'grok'</span>]</code></pre></div><h3 id="3-2-运行目录或压缩文件"><a href="#3-2-运行目录或压缩文件" class="headerlink" title="3.2 运行目录或压缩文件"></a>3.2 运行目录或压缩文件</h3><p>如果你的应用程序已经有多个文件，你可以把你的应用程序放进它自己的目录并添加一个<strong>main</strong>.py文件。 举个例子，你可以像这样创建目录：</p><div class="hljs"><pre><code>myapplication/        spam.py        bar.py        grok.py        __main__.py</code></pre></div><p>如果<code>__main__.py</code>存在，你可以简单地在顶级目录运行Python解释器：<code>python3 myapplication</code></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中extern和头文件以及静态动态库概念梳理</title>
    <link href="/2019/10/11/extern-and-linker/"/>
    <url>/2019/10/11/extern-and-linker/</url>
    
    <content type="html"><![CDATA[<p>最近因为Arduino使用的较多，开始学起来了C语言，看了还多天，无非就是基本的数据类型，运算符，控制语句，简单得很，后来发现这仅仅是语法层面，C语言是除了汇编最为底层的语言了，要了解这门语言，就要从了解支撑起C的底层原理开始了解，编译原理，操作系统，计算机硬件。而这次遇到的C语言的库文件，就好比Python中的标准库与第三方库，怎么共享，中间又是个什么过程，一团黑。因为涉及内容太多太多，我还是偏向于找一些好的资料然后分主题整理下来，自己再串起来，解惑也。</p><h2 id="1-先说说声明与定义"><a href="#1-先说说声明与定义" class="headerlink" title="1. 先说说声明与定义"></a>1. 先说说声明与定义</h2><p>stackoverflow上有个很全面的回答，<a href="https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration" target="_blank" rel="noopener">What is the difference between a definition and a declaration?</a></p><p>下面是我摘抄的一些简单概念：</p><p>定义（definition）：表示创建变量或分配存储单元<br>声明（declaration）：说明变量的性质，但并不分配存储单元<br><code>extern int i</code>; //是声明，不是定义，没有分配内存<br><code>int i</code>; //是定义<br>如果在声明的时候给变量赋值，那么就和去掉extern直接定义变量赋值是等价的</p><p><code>extern int a = 10</code>;<br><code>int a = 10</code>;//上述两条语句等价<br>谨记：声明可以多次，定义只能一次</p><h2 id="2-extern与static"><a href="#2-extern与static" class="headerlink" title="2. extern与static"></a>2. extern与static</h2><h3 id="2-1-extern"><a href="#2-1-extern" class="headerlink" title="2.1 extern"></a>2.1 extern</h3><p>当需要在外部文件导入函数或者变量时，我们可能很正常的找到了extern这个关键字，依然有篇经典的回答，<a href="https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files" target="_blank" rel="noopener">how do i use extern to share variables between source files</a></p><p>对变量而言，如果你想在本源文件中使用另一个源文件的变量，就需要在使用前用extern声明该变量，或者在头文件中用extern声明该变量；</p><blockquote><p>不加extern也可以…源于某些不可描述的原因（可从上面那链接中找到原因）</p></blockquote><p>对函数而言，如果你想在本源文件中使用另一个源文件的函数，就需要在使用前用声明该变量，声明函数加不加extern都没关系，所以在头文件中函数可以不用加extern。</p><h3 id="2-2-static"><a href="#2-2-static" class="headerlink" title="2.2 static"></a>2.2 static</h3><p>对于static，我暂时用的不多，查看<code>C primer plus</code>书籍，我们看到static的三个用法</p><ul><li><strong>块作用域的静态变量</strong></li><li><strong>外部链接的静态变量</strong></li><li><strong>内部链接的静态变量</strong></li></ul><p>相关问答：<a href="https://stackoverflow.com/questions/572547/what-does-static-mean-in-c" target="_blank" rel="noopener">What does “static” mean in C?</a></p><p>上面的讲解都附带了一些例子，我们来看一些<a href="https://medium.com/@shrmoud/static-vs-extern-a79e36f14812" target="_blank" rel="noopener">更清晰的例子: static vs extern</a></p><h2 id="3-头文件"><a href="#3-头文件" class="headerlink" title="3. 头文件"></a>3. 头文件</h2><p>对于我自己创建头文件这件事，我的第一反应是项目多文件的时候导入外部函数啥的用的，后来我发现了<code>extern</code>这个关键字，我就开始疑问，我都可以直接导入外部变量与函数，我为啥还要用头文件这个东西？ 后来发现自己还是<code>too young too simple！</code></p><blockquote><p>其实头文件是种约定，对计算机而言没什么作用，它只是在预编译时在#include的地方展开一下，没别的意义了，其实头文件主要是给别人看的。</p></blockquote><p>所以，按这么说，我在<code>test.h</code>文件中写着<code>extern int max(int a,int b)</code>（函数的extern可以省略），然后主文件中<code>incluede &quot;test.h&quot;</code>，等价于我直接<code>extern int max(int a,int b)</code>放到主文件中，这就达到了和我所产生的疑问一样的目的，然后头文件作用不仅仅这样。</p><p><strong>在以下场景中会使用头文件：</strong></p><ul><li>通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功 能，而不必关心接口怎么实现的。</li><li>多文件编译。将稍大的项目分成几个文件实现，通过头文件将其他文件的函数声明引入到当前文件。</li><li>头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。</li></ul><p>既然头文件是一种规定，那么写头文件时也有相当多的规则，<a href="https://reality0ne.com/how-to-struct-c-header-files/" target="_blank" rel="noopener">如何组织好 C 的头文件</a>很有必要。</p><h2 id="4-编译系统"><a href="#4-编译系统" class="headerlink" title="4. 编译系统"></a>4. 编译系统</h2><p>对与一个简单的hello程序<br><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello, world\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div></p><p><strong>当我们调用gcc编译时，过程是这样的：</strong></p><p><img src="/images/gcc_linker/gcc.jpg" srcset="/img/loading.gif" alt="compilation system"><br>关于对每个部分的具体相关命令，可以看下<a href="http://youguanxinqing.xyz/index.php/archives/85/" target="_blank" rel="noopener">这篇文章前半部分</a></p><h2 id="5-链接"><a href="#5-链接" class="headerlink" title="5. 链接"></a>5. 链接</h2><p><strong>接下来我们着重讲讲链接以及相关的内容：</strong></p><blockquote><p>链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编’译时(compile time),也就是在源代码被翻译成机器代码时；也可以执行于加载时(load time),也就是在程序被加载器(load-er)加载到内存并执行时；甚至执行于运行时(run time),也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器(linker)的程序自动执行的。<br>链接器的两个主要任务是<strong>符号解析(symbol resolution)与重定位(relocation)</strong></p></blockquote><h3 id="5-1-可重定位目标文件"><a href="#5-1-可重定位目标文件" class="headerlink" title="5.1 可重定位目标文件"></a>5.1 可重定位目标文件</h3><p>在上面编译过程中的链接之前，我们经过预处理，编译，汇编，得到了<code>.o</code>文件，<br>也就是可重定位目标文件，包含了二进制代码与数据（是一堆乱码）。</p><h3 id="5-2-函数库"><a href="#5-2-函数库" class="headerlink" title="5.2 函数库"></a>5.2 函数库</h3><p>这里说个函数库的概念，顾名思义：里边存放了一堆供程序员使用的函数。其实不但有函数名、函数对应的实现代码，还有链接过程中所需的重定位信息。函数库分为静态库（linux .a 文件 ，windows 为.lib文件）和动态库（.so，windows为.dll文件）文件。<br>当然，Linux 中也有标准的 C 函数库，里面有我们平常熟知的<code>printf</code>，<code>scanf</code>等标准c函数，都统一在libc.a与libc.so中,会存放在某个文件夹，我们可以通过<code>gcc --print-file-name=libc.a</code>查找<br>而用户，也可以根据自生需求，建立自己的用户函数库，这也是为什么我们上面说多个文件共享等等事情。</p><p>这里需要注意，由于函数库来自于 .o 文件，也就是说，是一堆二进制文件构成，你看不到里面的库函数代码。所以库函数该怎么用呢？这就体现了头文件中的重要性。所以 .h 文件与 .c 最好是要分开写。</p><h2 id="6-静态库"><a href="#6-静态库" class="headerlink" title="6. 静态库"></a>6. 静态库</h2><blockquote><p><strong>静态链接器（static linker</strong>）读取一组可重定位目标文件，将所有相关的目标模块打包成为一个单独的文件，称为<strong>静态库（static library）</strong>，也可称之为静态函数库，最后再和主函数的<code>.o</code>文件链接起来创建一个可执行目标。</p></blockquote><p>为什么会有静态库？ <strong>在静态库之前,我们可以选择这么做？</strong></p><p>把所有<code>printf</code>标准函数放到<code>libc.o</code>中，然后<code>gcc main.c /usr/lib/libc.o</code> ，我们就可以用标准函数了。优点是我们将编译器的实现与标准函数实现分开了，但是缺点就是造成浪费，<code>libc.o</code>中我们有上百个函数，但我们平常的一个程序，我们可能仅仅用到<code>printf</code>等几个常用函数，全部导入进来，这样就造成空间浪费，还有就是对某个函数改变了，等重新编译整个源文件，开发维护复杂。</p><p>再者，我们可以为每个标准函数创建独立的<code>.o</code>文件，然后用:<br><code>gcc main.c /usr/lib/printf.o /usr/lib/scanf.o</code><br>这也是可行的，但是一看就知道太麻烦耗时</p><p>之后，静态库概念被提出来，以解决这些不同方法的缺点。相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。比如，使用c标准库和数学库中函数的程序可以用形式如下的命令行來编译和链接：<br><code>gcc main.c /usr/lib/libm.a /usr/lib/libc.a</code><br>在链接时，链接器只复制被程序引用的目标模块，这就减少了磁盘跟内存大小。</p><blockquote><p>在Linux系统中，静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。</p></blockquote><p>简单举个例子来，有两个向量加法与乘法的<code>.c</code>文件，分别为<code>addvec.c</code>,<code>multvec.c</code>,还有个主文件<code>main.c</code></p><ul><li>我们先生成<code>.o</code>文件：<br><code>gcc -c addvec.c multvec.c</code></li><li>创建静态库：<br><code>ar rcs libvector.a addvec.o multvec.o</code></li><li>编译主文件：<br><code>gcc -c main.c</code></li><li>最后链接：<br><code>gcc -static -o a.out main.o ./libvector.a</code></li></ul><h2 id="7-动态库"><a href="#7-动态库" class="headerlink" title="7. 动态库"></a>7. 动态库</h2><p>然而，静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。<br>另一个问题是几乎每个C程序都使用标准I/O函数，比如printf和scanf。在运行时，这些函数的代码会被复制到每个运行进程的文本段中。在一个运行上百个进程的典型系统上，这将是对稀缺的内存系统资源的极大浪费。<br>共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起來。这个过程称为动态链接(dynamic linking),是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object),在Linux系统中通常用.so后缀来表示。微软的操作系统大鼠地使用了共享库，它们称为DLL(动态链接库）<br><strong>所有引用某库的可执行目标文件共享这个<code>.so</code>文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行文件中</strong></p><p>还是展示上面向量那个例子：</p><ul><li>构造共享库：<br><code>gcc -shared -fpic -o libvector.so addvec.c multvec.c</code></li><li>链接<br><code>gcc -o a.out main.c ./libvector.so</code></li></ul><blockquote><p>这样就创建了一个可执行目标文件a.out,而此文件的形式使得它在运行时可以和libvector.so链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。认识到这一点是很重要的：此时，没有任何libvector.so的代码和数据节貞的被复制到可执行文件a.out中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对libvector.so中代码利数据的引用</p></blockquote><p><strong>所以静态库与动态库的区别：</strong></p><div class="hljs"><pre><code>静态库：1.链接时将程序放进进可执行程序2.会产生多分副本3.不依赖程序运行动态库：1.程序运行时，加载时才去动态库找函数2.多进程共享3.依赖程序运行</code></pre></div><p>还有个题外话，<a href="https://stackoverflow.com/questions/6906360/by-default-does-gcc-link-to-static-or-dynamic-standard-library" target="_blank" rel="noopener">gcc链接标准库时默认是动态的还是静态的？</a></p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>花了两天，算是把相关的概念过程整理清楚了，有些资料第一次读没有读懂，回过头来再细读，豁然开朗！花了蛮多精力，不知道以后有没有机会用C做代码量多一点的项目，哈哈~</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Flask目录结构以及与Vue.js整合注意事项</title>
    <link href="/2019/09/25/Flask-structrue-and-integrate-with-vue/"/>
    <url>/2019/09/25/Flask-structrue-and-integrate-with-vue/</url>
    
    <content type="html"><![CDATA[<p>没用Flask之前，我对Flask的只有一个概念，那就是<strong><code>Micro</code></strong>，官网对其的解释是这样的：<strong><code>Micro</code></strong>并不意味着你的整个Web应用程序必须只有单个Python文件（尽管可以），也不意味着Flask缺少功能。微框架中的<strong><code>Micro</code></strong>意味着Flask旨在使核心保持简单但可扩展。Flask不会为你做出很多决定，例如使用什么数据库，而且它所做的决定（例如使用哪种模板引擎）很容易更改。其他一切都由你决定，因此Flask可以满足你的所有需求，而无所不包。</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>由于工作性质，要求写的小web应用都要涉及一些底层，不如串口通信，或者GPIO调用。而串口这种东西不像数据库连接一样，开几个都可以，也不能开了之后关然后再开（效率比数据库连接差多了）。所以最好写个全局的，开了一次就不用关了，代码量也不多，哪个简单用哪个，我就想到了用Flask。例如一个最小的应用就可以这么简单的写：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flaskapp = Flask(__name__)<span class="hljs-meta">@app.route('/')</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, World!'</span></code></pre></div><p>单个Python文件就好办了，然后打开串口，在路由中引用串口实例加入一些操作，就是个能用的小型Web应用了。</p><h2 id="2-目录结构安排一下"><a href="#2-目录结构安排一下" class="headerlink" title="2. 目录结构安排一下"></a>2. 目录结构安排一下</h2><p>即使一个项目再小也要有个规则安排，总不能真的单文件走天下。<br><a href="https://www.v2ex.com/t/467423" target="_blank" rel="noopener">V2EX上有篇文章</a>探讨了Flask的目录结构，我看了上面的每个链接，果然<strong><code>Flask 其实很灵活，怎样都行，怎么舒服怎么来</code></strong>这句话很对。</p><p>我从一些教程或者github中综合了下，整理下我会采用的结构目录，旨在简单明了。</p><h4 id="单模块目录结构"><a href="#单模块目录结构" class="headerlink" title="单模块目录结构"></a>单模块目录结构</h4><p>当项目代码量少于几百行的时候我们可以采用单模块的目录结构，也就是把所有的代码都写在<code>app.py</code>里，然后把一些配置（比如我上面例子中的串口位置，波特率啥的）写到<code>config.py</code>里，比如这样：<br><div class="hljs"><pre><code class="hljs undefined">app<span class="hljs-selector-class">.py</span>config<span class="hljs-selector-class">.py</span>requirements<span class="hljs-selector-class">.txt</span>static/templates/</code></pre></div></p><h4 id="包目录结构"><a href="#包目录结构" class="headerlink" title="包目录结构"></a>包目录结构</h4><p>对于包目录结构我们可以按照<a href="https://flask.palletsprojects.com/en/1.1.x/tutorial/layout/" target="_blank" rel="noopener">官网推荐</a>的来：<br><div class="hljs"><pre><code class="hljs undefined">/home/user/Projects/flask-tutorial├── flaskr/│   ├── __init__<span class="hljs-selector-class">.py</span>│   ├── db<span class="hljs-selector-class">.py</span>│   ├── schema<span class="hljs-selector-class">.sql</span>│   ├── auth<span class="hljs-selector-class">.py</span>│   ├── blog<span class="hljs-selector-class">.py</span>│   ├── templates/│   │   ├── base<span class="hljs-selector-class">.html</span>│   │   ├── auth/│   │   │   ├── login<span class="hljs-selector-class">.html</span>│   │   │   └── register<span class="hljs-selector-class">.html</span>│   │   └── blog/│   │       ├── create<span class="hljs-selector-class">.html</span>│   │       ├── index<span class="hljs-selector-class">.html</span>│   │       └── update<span class="hljs-selector-class">.html</span>│   └── static/│       └── style<span class="hljs-selector-class">.css</span>├── tests/│   ├── conftest<span class="hljs-selector-class">.py</span>│   ├── data<span class="hljs-selector-class">.sql</span>│   ├── test_factory<span class="hljs-selector-class">.py</span>│   ├── test_db<span class="hljs-selector-class">.py</span>│   ├── test_auth<span class="hljs-selector-class">.py</span>│   └── test_blog<span class="hljs-selector-class">.py</span>├── venv/├── setup<span class="hljs-selector-class">.py</span>└── MANIFEST.<span class="hljs-keyword">in</span></code></pre></div></p><p>看似文件很多，但是基本的骨架还是像下面这样：<br><div class="hljs"><pre><code class="hljs undefined">config<span class="hljs-selector-class">.py</span>requirements<span class="hljs-selector-class">.txt</span>run<span class="hljs-selector-class">.py</span>instance/    config<span class="hljs-selector-class">.py</span>yourapp/    __init__<span class="hljs-selector-class">.py</span>    views<span class="hljs-selector-class">.py</span>    models<span class="hljs-selector-class">.py</span>    forms<span class="hljs-selector-class">.py</span>    static/    templates/</code></pre></div></p><p>然后我们可以在这上面进行很多衍生，加入蓝图等东西。</p><h4 id="更完整的目录结构"><a href="#更完整的目录结构" class="headerlink" title="更完整的目录结构"></a>更完整的目录结构</h4><p>更完善的目录结构我们可以加入<code>docker</code>，<code>makefile</code>等，我们可以参考有名的<a href="https://github.com/cookiecutter/cookiecutter/blob/master/README.md" target="_blank" rel="noopener">cookiecutter项目模板</a>，很全面，考虑很周到，但是在自己的开发过程中用不太到，仅供参考。</p><h2 id="3-Flask与Vue-js整合问题"><a href="#3-Flask与Vue-js整合问题" class="headerlink" title="3. Flask与Vue.js整合问题"></a>3. Flask与Vue.js整合问题</h2><p>采用前后端分离开发的时候，需要整合前端vue的包，我们可以在实例化app的时候这么做：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template, jsonify<span class="hljs-comment"># Set up automatic serving of static Vue &amp; frontend files and template folder for index.html.</span>app = Flask(__name__, static_folder=<span class="hljs-string">'./dist/static'</span>, template_folder=<span class="hljs-string">'./dist'</span>)<span class="hljs-comment"># Add your routes here:</span><span class="hljs-meta">@app.route('/api/posts')</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">blog_posts</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> jsonify([])<span class="hljs-comment"># Make a "catch all route" so all requests match our index.html file. This lets us use the new history APIs in the browser.</span><span class="hljs-meta">@app.route('/', defaults=&#123;'path': ''&#125;)</span><span class="hljs-meta">@app.route('/&lt;path:path&gt;')</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">(path)</span>:</span>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">'index.html'</span>)</code></pre></div></p><p>Vue这边也要设置，平时前后端分离开发，都是用axios到我开发的机器上拿数据，还会遇到跨域问题，但是整合的时候Vue这边打包前填什么服务器ip呢，我要是部署到别的机器ip肯定会变，ip肯定会变，总不能一个ip打一个不同的包。所以说我们需要在vue.config.js中这么配置：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;    <span class="hljs-attr">assetsDir</span>: <span class="hljs-string">'static'</span>, <span class="hljs-comment">// For simple configuration of static files in Flask (the "static_folder='client/dist/static'" part in app.py)</span>    devServer: &#123;        <span class="hljs-attr">proxy</span>: <span class="hljs-string">'http://localhost:5000'</span> <span class="hljs-comment">// So that the client dev server can access your Flask routes</span>    &#125;&#125;;</code></pre></div><p>这样就OK了，打一个包后续都能用了</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>对于Flask目录结构真的是仁者见仁，智者见智，怎么舒服怎么来，但是对于刚开始用的人来说不要一开始就用人家的大结构目录，容易看的懵逼，项目都是从一开始的几个文件然后内容的增多到很多个包，中间有慢慢衍生的过程，想一开始就把代码套在大骨架上实属勉强。<br>Vue配置文件中<code>proxy</code>我只是知道个大概的作用，只是在网上找到了这个解决方案，如果不加，直接在<code>axios</code>中裸用<code>&#39;http://localhost:5000&#39;</code>，那么访问 到的地址就是打开浏览器访问页面时的那台机器的localhost资源，原因可能在于webpack4本身不知道<code>&#39;http://localhost:5000&#39;</code>这个地址，需要代理下！<br><br><br><br><br>参考资料：<br><a href="https://medium.com/unbabel/integrating-webpack-4-with-a-backend-framework-4a0e630d2a03" target="_blank" rel="noopener">Integrating Webpack 4 with a backend framework</a></p><p><a href="https://stackabuse.com/single-page-apps-with-vue-js-and-flask-deployment/" target="_blank" rel="noopener">Single Page Apps with Vue.js and Flask: Deployment</a></p><p><a href="https://vsupalov.com/combine-frontend-and-backend-development-servers/" target="_blank" rel="noopener">Running Frontend and Backend Development Servers Together</a></p><p><a href="https://olav.it/2018/08/29/simple-spa-setup-with-vue-cli-3-and-flask/" target="_blank" rel="noopener">Simple SPA setup with Vue CLI 3 and Flask</a></p><p><a href="https://olav.it/2018/08/29/simple-spa-setup-with-vue-cli-3-and-flask/" target="_blank" rel="noopener">flask-vuejs-template</a></p>]]></content>
    
    
    <categories>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Vue</tag>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Python在树莓派中使用MCP23017 I/O扩展模块</title>
    <link href="/2019/09/20/MCP23017-raspberrypi-expander/"/>
    <url>/2019/09/20/MCP23017-raspberrypi-expander/</url>
    
    <content type="html"><![CDATA[<p><strong>摘自老外一段话,本来想翻译,有点拗口,直接搬运过来,作为背景:</strong></p><p>For all of my projects I have used the standard GPIO header pins as inputs and outputs. This gives you a total of 17 pins to play with but what if you need more?</p><p>The easiest way of getting more inputs and outputs is to use an “i/o port expander”. This is a device that allows you to control a number of ports using data you send to the device.</p><p>MCP23017 Example CircuitOther people have has lots of success using I2C devices so I decided to give one a try. I2C is a serial communications protocol which allows chips to swap data on the same “bus”. A port expander takes the data and controls the appropriate pins. This allows lots of sensors and devices to be controlled using only a few of the Pi’s GPIO pins.</p><h2 id="1-说说硬件"><a href="#1-说说硬件" class="headerlink" title="1. 说说硬件"></a>1. 说说硬件</h2><p>我买的是微雪电子上的MCP23017 I/O扩展模块,这是一款基于 I2C 接口控制的 I/O 扩展模块，可外扩 16Pin I/O 口，支持同时使用多达 8 个，即可扩至 128Pin I/O 口，兼容 3.3V 和 5V 电平。</p><p>产品参数与接线这里不多说,参考该产品的<a href="http://www.waveshare.net/w/upload/3/31/MCP23017-IO-Expansion-Board-user-manual-cn.pdf" target="_blank" rel="noopener">用户手册</a>,当然我们要验证这个拓展模块有没有用的直接表现就是简单地在电路上面接一个小灯(<strong>假设接在引脚PAO上</strong>).</p><p>这个模块不仅可以拓展树莓派,还可以拓展Arduino与单片机,算是通用的,性价比不错.</p><h2 id="2-系统设置与硬件测试"><a href="#2-系统设置与硬件测试" class="headerlink" title="2. 系统设置与硬件测试"></a>2. 系统设置与硬件测试</h2><p>我们先要打开树莓派上的I2C接口,默认是不开的,这个简单,直接在配置里面打开接口就行,然后重启</p><ul><li><p>安装 i2c-tools 工具对器件地址进行确认<br><strong><code>sudo apt-get install i2c-tools</code></strong></p></li><li><p>查询已连接的 I2C 设备<br><strong><code>i2cdetect -y 1</code></strong></p></li></ul><p>将会打印出已连接设备的 I2C 器件地址信息：</p><div class="hljs"><pre><code>pi@raspberrypi:~ $ i2cdetect  -y 1     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- 27 -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- --  </code></pre></div><blockquote><p>注意,这里不同厂家的拓展模块有可能是其他地址,比如0x20,原因在于我这个模块的A0,A1,A2在厂家出厂时就在内部接了3.3V,所以是0x27,这也是为什么能同时接八个该拓展模块的原因,A0,A1,A2,有接GND与3V3的选择,共有<code>2*2*2=8</code>不同的组合,具体可以看下面的表格</p></blockquote><p><img src="/images/MCP23017/address_pin.jpg" srcset="/img/loading.gif" alt="MCP23017地址"></p><h2 id="3-命令行测试"><a href="#3-命令行测试" class="headerlink" title="3.命令行测试"></a>3.命令行测试</h2><p><strong>这里的命令行测试我并不是很懂,只是看到外文教程上以这样为例,而且我依葫芦画瓢成功了,写在这里只是为了快速测试 (LED引脚需接在PAO上)</strong></p><ul><li><p>首先我们将PA0-PA6设置为输出模式,将PA7设置为输入(二进制用10000000表示,十六进制用0x80表示):</p><blockquote><p><strong><code>sudo i2cset -y 1 0x27 0x00 0x80</code></strong></p></blockquote></li><li><p>将PA0设置为逻辑高点亮LED:</p><blockquote><p><strong><code>sudo i2cset -y 1 0x27 0x14 0x01</code></strong></p></blockquote></li><li><p>关闭小灯则可以用:</p><blockquote><p><strong><code>sudo i2cset -y 1 0x27 0x14 0x00</code></strong></p></blockquote></li></ul><h2 id="4-在Python脚本中使用拓展模块"><a href="#4-在Python脚本中使用拓展模块" class="headerlink" title="4. 在Python脚本中使用拓展模块"></a>4. 在Python脚本中使用拓展模块</h2><p>习惯了在树莓派中用<code>gpiozero</code>简单丝滑流畅地操控IO,不用关乎太多底层,实在爽的很. 而在这里,我们是I2C bus协议,我们一般是用到<code>smbus</code>库,但是还是有些底层(特别是拓展模块上各个引脚代表的寄存器地址好像有点难以理解)的有些费力,所以找阿找,找到了一个新库,依旧保持优雅!</p><h3 id="4-1-什么是CircuitPython"><a href="#4-1-什么是CircuitPython" class="headerlink" title="4.1 什么是CircuitPython?"></a>4.1 什么是CircuitPython?</h3><p><code>CircuitPython</code>基于<code>Python</code>,在<code>Python</code>上添加了硬件支持.<code>CircuitPython</code>旨在在微控制器板上运行。微控制器板是一块带有微控制器芯片的电路板，它本质上是一个多功能的一体机。你持有的电路板是微控制器板！ <code>CircuitPython</code>可以在小型Linux板上运行,这里正好可以用我们的树莓派试试手.先安装库<code>sudo pip3 install adafruit-circuitpython-mcp230xx</code>，然后是代码演示。</p><h3 id="4-2-代码演示"><a href="#4-2-代码演示" class="headerlink" title="4.2 代码演示"></a>4.2 代码演示</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> board<span class="hljs-keyword">import</span> busio<span class="hljs-keyword">from</span> digitalio <span class="hljs-keyword">import</span> Direction, Pull<span class="hljs-keyword">from</span> adafruit_mcp230xx.mcp23017 <span class="hljs-keyword">import</span> MCP23017<span class="hljs-comment"># Initialize the I2C bus:</span>i2c = busio.I2C(board.SCL, board.SDA)<span class="hljs-comment"># Initialize the MCP23017 chip on the bonnet</span>mcp = MCP23017(i2c,<span class="hljs-number">0x27</span>)<span class="hljs-comment">#0 to 15 for the GPIOA0...GPIOA7, GPIOB0...GPIOB7 pins (i.e. pin 12 is GPIOB4).</span>a0 = mcp.get_pin(<span class="hljs-number">0</span>)<span class="hljs-comment"># defalut input mode , switch to output pinmode</span>a0.switch_to_output()<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    a0.value = <span class="hljs-literal">True</span>    time.sleep(<span class="hljs-number">2</span>)    a0.value = <span class="hljs-literal">False</span>    time.sleep(<span class="hljs-number">2</span>)</code></pre></div><p>具体的代码解释都在注释上写这个了,很简单,不展开.想要查看更多的例子或者源代码可以看<a href="https://github.com/adafruit/Adafruit_CircuitPython_MCP230xx/blob/master/examples/mcp230xx_simpletest.py" target="_blank" rel="noopener"><strong>官方库手册</strong></a></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p><strong>当树莓派GPIO口要连接较多设备,数量紧张时,可以用MCP23017拓展模块了来增加,最多可以加128个….<code>adafruit_mcp230xx.mcp23017</code>库也可以很Python地写出控制代码,但是一些监听事件要自己实现,不像<code>gpiozero</code>都有现成的轮子.当然我们可以转换下思路,把一些简单的output设备接在拓展模块上用来简单控制就行,把一些实现复杂的input设备接在树莓派自带的GPIO上,就可以用<code>gpiozero</code>库的高级内容了.</strong></p><p><br></p><p>一些资料整理:<br><a href="https://www.raspberrypi-spy.co.uk/2013/07/how-to-use-a-mcp23017-i2c-port-expander-with-the-raspberry-pi-part-1/#prettyPhoto" target="_blank" rel="noopener">How To Use A MCP23017 I2C Port Expander With The Raspberry Pi – Part 1</a></p><p><a href="https://learn.adafruit.com/using-mcp23008-mcp23017-with-circuitpython/python-circuitpython" target="_blank" rel="noopener">Using MCP23008 &amp; MCP23017 with CircuitPython</a></p><p><a href="https://raspi.tv/2013/using-the-mcp23017-port-expander-with-wiringpi2-to-give-you-16-new-gpio-ports-part-3" target="_blank" rel="noopener">Using the MCP23017 port expander with WiringPi2 to give you 16 new GPIO ports – part 3</a></p><p><a href="https://circuitpython.readthedocs.io/en/2.x/shared-bindings/index.html" target="_blank" rel="noopener">Adafruit CircuitPython</a></p>]]></content>
    
    
    <categories>
      
      <category>RaspberryPi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
      <tag>I2C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arduino Serial使用以及各种读写函数区别</title>
    <link href="/2019/08/01/Arduino-Serial/"/>
    <url>/2019/08/01/Arduino-Serial/</url>
    
    <content type="html"><![CDATA[<p>之前有一篇文章总结了Python的串口使用，自认为已经深得要领。直到最近开始研究Arduino，用的串口传输数据，心里还是有很多问题，时常在运用相关函数的时候想起之前Python上的串口知识点，两者有着千丝万缕的关系。从头开始理一下思路，原理都是一样的，计算机只懂得二进制，而人类懂得ASCII文本，如何理解两者之间架起的这座桥梁甚是关键….</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>常见的串口调试是将Arduino与PC相连，然后利用PC上的串口助手与其通信调试，但是有一个注意点是，调试Arduino串口时，用串口助手调试与跟程序语言(比如Python，Arduino语言)调试的传输的数据有区别，比如串口助手输入框中输入<code>97</code>时你可能输入的是两个字符<code>9</code>与<code>7</code>，而在用Arduino语法（Serial.write(97)）写的时候就是代表ASCII的<code>a</code>，或者在Python中是<code>ser.write(b&#39;a&#39;)</code>也可写成<code>ser.write([97])</code>）,两者调试方法有明显的差别性。</p><h2 id="2-两个重要的写函数（write，print）"><a href="#2-两个重要的写函数（write，print）" class="headerlink" title="2. 两个重要的写函数（write，print）"></a>2. 两个重要的写函数（write，print）</h2><h3 id="2-1-Serial-write"><a href="#2-1-Serial-write" class="headerlink" title="2.1 Serial.write()"></a>2.1 Serial.write()</h3><p>串口中通信的一定是byte（字节），也就是八位Bit（二进制位），可以为一个字节，也可为多个字节；如果想发送代表数字的字符，应该使用print()函数（这个后面说）；该函数返回有几个字节被发送了。</p><p><code>Serial.write()</code>一共有三种语法</p><ul><li><code>Serial.write(val)</code></li></ul><p>发送单个字节，比如发送97，那么等于发送十进制ASCII码值为97的字符，也就是字母a</p><ul><li><code>Serial.write(str)</code></li></ul><p>发送字符串作为一系列的字节,比如<code>int bytesSent = Serial.write(“hello”);</code></p><blockquote><p>注意，这里发送字符串一定要用双引号，我一开始习惯了Python的用法，单双引号看心情来用，直接只收到一个字节，问题很大</p></blockquote><ul><li><code>Serial.write(buf, len)</code></li></ul><p>发送一个长度为len的数组（一般为char类型数组),跟上面<code>Serial.write(str)</code>作用是一致的，只是传入参数不一样</p><h3 id="2-2-Serial-print"><a href="#2-2-Serial-print" class="headerlink" title="2.2 Serial.print()"></a>2.2 Serial.print()</h3><blockquote><p><strong>Prints data to the serial port as human-readable ASCII text.</strong></p></blockquote><p>println与print类似，只是多了换行符，这里只介绍print函数。<br>上面这行英文已经把它跟read()函数的关系分的很清楚了。这个命令可以有多种形式。每个数字都使用ASCII字符打印。浮点数类似地打印为ASCII数字，默认为两位小数。字节作为单个字符发送。字符和字符串按原样发送。例如：</p><div class="hljs"><pre><code class="hljs cpp">Serial.print(<span class="hljs-number">78</span>) gives <span class="hljs-string">"78"</span>Serial.print(<span class="hljs-number">1.23456</span>) gives <span class="hljs-string">"1.23"</span>Serial.print(<span class="hljs-string">'N'</span>) gives <span class="hljs-string">"N"</span>Serial.print(<span class="hljs-string">"Hello world."</span>) gives <span class="hljs-string">"Hello world."</span></code></pre></div><p>还有第二个可选参数<code>format</code>是具体的格式，允许二进制八进制十六进制等，例如：<br><div class="hljs"><pre><code class="hljs cpp">Serial.print(<span class="hljs-number">78</span>, BIN) gives <span class="hljs-string">"1001110"</span>Serial.print(<span class="hljs-number">78</span>, OCT) gives <span class="hljs-string">"116"</span>Serial.print(<span class="hljs-number">78</span>, DEC) gives <span class="hljs-string">"78"</span>Serial.print(<span class="hljs-number">78</span>, HEX) gives <span class="hljs-string">"4E"</span>Serial.print(<span class="hljs-number">1.23456</span>, <span class="hljs-number">0</span>) gives <span class="hljs-string">"1"</span>Serial.print(<span class="hljs-number">1.23456</span>, <span class="hljs-number">2</span>) gives <span class="hljs-string">"1.23"</span>Serial.print(<span class="hljs-number">1.23456</span>, <span class="hljs-number">4</span>) gives <span class="hljs-string">"1.2346"</span></code></pre></div></p><h3 id="2-3-Serial-write与Serial-print函数的区别"><a href="#2-3-Serial-write与Serial-print函数的区别" class="headerlink" title="2.3 Serial.write与Serial.print函数的区别"></a>2.3 Serial.write与Serial.print函数的区别</h3><blockquote><p>谢邀，我觉得print，printf是开发出来专门针对pc端显示的，write则是用来与串口设备通信的，当然在老手眼里怎么用都行     ——————from逼乎某大佬回答</p></blockquote><p>按照arduino官网reference的解释，<code>Serial. print()</code>是<strong>print data to  the serial port as human-reading ASC II text</strong> ,<code>Serial. write()</code>是<strong>write binary data to  the serial port</strong> ，一个转化为文本输出，一个是数据输出。</p><p>我在测试的时候刚开始并没有发现两者的区别。起初我认为传数据就该用<code>Serial.write</code>，而对于<code>Serial.print</code>这是在用串口助手的时候用，打印一些格式啥的，好利于调试辨认啥的等等（事实确实如此，但不仅于此）</p><p>于是我就将这两者的区别与Python中<code>sys.stdout.write</code>与内置的<code>print</code>函数作比较，前者不会写换行符然后是写到缓冲区，而<code>print</code>函数每次都有换行符，清空了缓冲区，然后就打印到屏幕上了，而且<code>print</code>函数自带了很多格式，可以跟<code>format</code>函数配合啥的，倒是跟Arduino的<code>print</code>有几分相似……但是其实这并不是重点～</p><blockquote><p>我认为Arduino中的<code>write</code>与<code>print</code>还是存在缓冲区这个区别的，比如是在<code>write</code>中设置了<code>timeout</code>等操作，达到了与<code>print</code>类似的操作，这里只是猜测下，不做深究</p></blockquote><p>重点来了！ </p><p>我在这里<a href="https://www.zhihu.com/question/21307404" target="_blank" rel="noopener">Arduino 的 Serial.write() 和 Serial.print() 的区别在哪里？</a>看到了答案？</p><ul><li><strong>在输出字符或字符串时，没有任何区别</strong></li><li><strong>在输出数值时，write会直接输出数据本身，而print会将其转化为可显示的ASCII字符（其实我觉得不妥，转换是串口助手来转换的，应该是算是说转换成可以传输的ASCII码值）</strong></li></ul><p>当时我的想法跟<code>amazing814</code>答主一样，而跟最高赞同者那位相反，后来发现我们概念理解错了<br>他“错误”的回答如下：</p><blockquote><p>1, print 出来的是真实数值,<br>  2, write出来的是ascii码表对应的值(或者是说”对应的图形”)</p></blockquote><p>错在了串口助手会自动将数据转换程ASCII文本！ 反正，你要知道的是，串口发送或者读取到的数据都是字节！这一点用Python串口模块自己尝试一下就行！</p><p>所以<code>Serial.write</code>与<code>Serial.print</code>最大的区别就是传进函数中的数据，前者是真正的原始数据（int型或者说二进制位的数值），得到的是数据本身，而<code>使用print</code>函数的时候会以多个字节的形式向串口传递括号中数值，会将它看成一个字符串，传递其中每一个字符的ASCII码。例如你举的例子“78”会向串口传递“7”和“8”的ASCII码的值。</p><p>比如 Serial.write(78) ,发送的是<code>N</code>(换算成二进制就是01001110)，得到的也是<code>N</code>的字节（即二进制位），虽然串口助手上显示的是<code>N</code><br>与Serial.print(78)，发送的<code>7</code>和<code>8</code>两个字节，内部先把<code>7</code>，<code>8</code>转换成<code>55</code>，<code>56</code>的原始数据，在发送出去，得到也是<code>55</code>,<code>56</code></p><p>所以那位错误的答主，想说的其实并不是“真实”，而是“相同”！ 真正的计算机数据是二进制位（为了方便，转换成十进制了，也就是上面的55,56）</p><p><strong>print主要用于”给人看”的地方. 电脑内部通讯, 如果程序内不需要用人眼再检查, 用 write 会比较好, 直接快捷.</strong></p><h2 id="3-Serial-read-相关函数"><a href="#3-Serial-read-相关函数" class="headerlink" title="3. Serial.read 相关函数"></a>3. Serial.read 相关函数</h2><h3 id="3-1-Serial-read"><a href="#3-1-Serial-read" class="headerlink" title="3.1 Serial.read()"></a>3.1 Serial.read()</h3><p>读取即将来的串口数据，但是只读取第一个字节，且这个字节的数据类型为int，即ASCII码值。</p><p>通常与<code>Serial.available()</code>一起用，例子如下：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> incomingByte = <span class="hljs-number">0</span>; <span class="hljs-comment">// for incoming serial data</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;  Serial.begin(<span class="hljs-number">9600</span>); <span class="hljs-comment">// opens serial port, sets data rate to 9600 bps</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// send data only when you receive data:</span>  <span class="hljs-keyword">if</span> (Serial.available() &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// read the incoming byte:</span>    incomingByte = Serial.read();    <span class="hljs-comment">// say what you got:</span>    Serial.print(<span class="hljs-string">"I received: "</span>);    Serial.println(incomingByte, DEC);  &#125;&#125;</code></pre></div><p>串口发送数据与读到数据都为字节，所以该函数return回来int 型数据很正常，但是我们可以直接拿来跟字符比较或者用到某些话函数中，这得益于在C语言中单引号括起一个字符实际上代表一个整数，即ASCII码值</p><p>，从Arduino内置的例子就能看到：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// Open serial communications and wait for port to open:</span>  Serial.begin(<span class="hljs-number">9600</span>);  <span class="hljs-keyword">while</span> (!Serial) &#123;    ; <span class="hljs-comment">// wait for serial port to connect. Needed for native USB port only</span>  &#125;  <span class="hljs-comment">// send an intro:</span>  Serial.println(<span class="hljs-string">"send any byte and I'll tell you everything I can about it"</span>);  Serial.println();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// get any incoming bytes:</span>  <span class="hljs-keyword">if</span> (Serial.available() &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">int</span> thisChar = Serial.read();    <span class="hljs-comment">// say what was sent:</span>    Serial.print(<span class="hljs-string">"You sent me: \'"</span>);    Serial.write(thisChar);    Serial.print(<span class="hljs-string">"\'  ASCII Value: "</span>);    Serial.println(thisChar);    <span class="hljs-comment">// analyze what was sent:</span>    <span class="hljs-keyword">if</span> (isAlphaNumeric(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's alphanumeric"</span>);    &#125;    <span class="hljs-keyword">if</span> (isAlpha(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's alphabetic"</span>);    &#125;    <span class="hljs-keyword">if</span> (isAscii(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's ASCII"</span>);    &#125;    <span class="hljs-keyword">if</span> (isWhitespace(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's whitespace"</span>);    &#125;    <span class="hljs-keyword">if</span> (isControl(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's a control character"</span>);    &#125;    <span class="hljs-keyword">if</span> (isDigit(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's a numeric digit"</span>);    &#125;    <span class="hljs-keyword">if</span> (isGraph(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's a printable character that's not whitespace"</span>);    &#125;    <span class="hljs-keyword">if</span> (isLowerCase(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's lower case"</span>);    &#125;    <span class="hljs-keyword">if</span> (isPrintable(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's printable"</span>);    &#125;    <span class="hljs-keyword">if</span> (isPunct(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's punctuation"</span>);    &#125;    <span class="hljs-keyword">if</span> (isSpace(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's a space character"</span>);    &#125;    <span class="hljs-keyword">if</span> (isUpperCase(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's upper case"</span>);    &#125;    <span class="hljs-keyword">if</span> (isHexadecimalDigit(thisChar)) &#123;      Serial.println(<span class="hljs-string">"it's a valid hexadecimaldigit (i.e. 0 - 9, a - F, or A - F)"</span>);    &#125;    <span class="hljs-comment">// add some space and ask for another byte:</span>    Serial.println();    Serial.println(<span class="hljs-string">"Give me another byte:"</span>);    Serial.println();  &#125;&#125;</code></pre></div><h3 id="3-2-Serial-readBytes-buffer-length"><a href="#3-2-Serial-readBytes-buffer-length" class="headerlink" title="3.2 Serial.readBytes(buffer, length)"></a>3.2 Serial.readBytes(buffer, length)</h3><p><code>Serial.readBytes</code>从串行端口读取字符到缓冲区,返回放入缓冲区的字节数，如果超时该函数将中断</p><p>这个函数我看到的用法是放在字符数组中，然后再利用数组的特性进行一些操作，例子如下：<br><div class="hljs"><pre><code class="hljs C"><span class="hljs-keyword">char</span> mystr[<span class="hljs-number">10</span>]; <span class="hljs-comment">//Initialized variable to store recieved data</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// Begin the Serial at 9600 Baud</span>  Serial.begin(<span class="hljs-number">9600</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;  Serial.readBytes(mystr,<span class="hljs-number">5</span>); <span class="hljs-comment">//Read the serial data and store in var</span>  Serial.println(mystr); <span class="hljs-comment">//Print data on Serial Monitor</span>  <span class="hljs-keyword">for</span> (byte i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i = i + <span class="hljs-number">1</span>) &#123;      Serial.println(mystr[i]);  delay(<span class="hljs-number">1000</span>);&#125;</code></pre></div></p><h3 id="3-3-Serial-readString"><a href="#3-3-Serial-readString" class="headerlink" title="3.3 Serial.readString()"></a>3.3 Serial.readString()</h3><p><code>Serial.readString</code>将串行缓冲区中的字符读入String，如果超时该函数将中断</p><div class="hljs"><pre><code class="hljs C">String a;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;Serial.begin(<span class="hljs-number">9600</span>); <span class="hljs-comment">// opens serial port, sets data rate to 9600 bps</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span>(Serial.available()) &#123;        a= Serial.readString();<span class="hljs-comment">// read the incoming data as string</span>        Serial.println(a);&#125;&#125;</code></pre></div><p>当时这个函数与上面的搞不太清楚，所以试了下。其实这个函数是读取发送过来的字符串，存到一个String类型的变量里，用来打印，或者处理（<code>Serial.write()无法字节发送String类型的变量</code>）再发出去等等，可以看一下String类型的变量很多个方法比如<code>toCharArray()</code>，<code>toInt()</code>之类的</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>经历了两天的疑惑解惑过程，发现自己关于串口的基本功还是不够扎实，这个过程中需要自己不断反复地尝试与验证，剥开代码语言的皮囊，看到更下面真实的骨架，其实也挺开心的，故再花点时间整理在这里留作总结以及反思！</p>]]></content>
    
    
    <categories>
      
      <category>Arduino</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Serial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中关于键盘行为的方法总结</title>
    <link href="/2019/07/25/python-about-keyboard/"/>
    <url>/2019/07/25/python-about-keyboard/</url>
    
    <content type="html"><![CDATA[<p>最近在倒腾AGV的时候，手动挪小车实在是太重太重了，之前写过控制小车转弯直行的命令，但没有优化，最近小车加了层铠甲实在太重了，于是想写一个类似于小时候玩赛车游戏一样的用手柄或者键盘控制的程序来控制它，中间查阅了相关Python控制键盘的一些第三方库，以及中间遇到的问题做一些整理</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>我能想到的操控键盘的行为无非有两种，一种是监听键盘的按键，还有一种就是模拟键盘的输入，但我的情景里需要的是前者。</p><h2 id="2-pynput库"><a href="#2-pynput库" class="headerlink" title="2. pynput库"></a>2. pynput库</h2><p>这个库允许你控制和监视输入设备。 目前，支持鼠标和键盘输入和监视</p><h3 id="2-1-控制键盘示例"><a href="#2-1-控制键盘示例" class="headerlink" title="2.1 控制键盘示例"></a>2.1 控制键盘示例</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pynput.keyboard <span class="hljs-keyword">import</span> Key, Controllerkeyboard = Controller()<span class="hljs-comment"># Press and release space</span>keyboard.press(Key.space)keyboard.release(Key.space)<span class="hljs-comment"># Type a lower case A; this will work even if no key on the</span><span class="hljs-comment"># physical keyboard is labelled 'A'</span>keyboard.press(<span class="hljs-string">'a'</span>)keyboard.release(<span class="hljs-string">'a'</span>)<span class="hljs-comment"># Type two upper case As</span>keyboard.press(<span class="hljs-string">'A'</span>)keyboard.release(<span class="hljs-string">'A'</span>)<span class="hljs-keyword">with</span> keyboard.pressed(Key.shift):    keyboard.press(<span class="hljs-string">'a'</span>)    keyboard.release(<span class="hljs-string">'a'</span>)<span class="hljs-comment"># Type 'Hello World' using the shortcut type method</span>keyboard.type(<span class="hljs-string">'Hello World'</span>)</code></pre></div><h3 id="2-2-监听鼠标示例"><a href="#2-2-监听鼠标示例" class="headerlink" title="2.2 监听鼠标示例"></a>2.2 监听鼠标示例</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pynput <span class="hljs-keyword">import</span> keyboard<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_press</span><span class="hljs-params">(key)</span>:</span>    <span class="hljs-keyword">try</span>:        print(<span class="hljs-string">'alphanumeric key &#123;0&#125; pressed'</span>.format(key.char))    <span class="hljs-keyword">except</span> AttributeError:        print(<span class="hljs-string">'special key &#123;0&#125; pressed'</span>.format(key))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_release</span><span class="hljs-params">(key)</span>:</span>    print(<span class="hljs-string">'&#123;0&#125; released'</span>.format(key))    <span class="hljs-keyword">if</span> key == keyboard.Key.esc:        <span class="hljs-comment"># Stop listener</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-comment"># Collect events until released</span><span class="hljs-keyword">with</span> keyboard.Listener(        on_press=on_press,        on_release=on_release) <span class="hljs-keyword">as</span> listener:    listener.join()<span class="hljs-comment"># ...or, in a non-blocking fashion:</span>listener = mouse.Listener(    on_press=on_press,    on_release=on_release)listener.start()</code></pre></div><p><strong>我对这个库的第一印象是简洁好用，监听部分的callback函数很优雅，很是喜欢，也简单测试成功了，于是我噗呲噗呲地开始写，然后把代码扔到树莓派上准备run一下，结果悲剧了，报错<code>Xlib.error.DisplayNameError: Bad display name &quot;&quot;</code>，网上说通过ssh使用这个库的时候会报错，没法正常监听，具体可以看<a href="https://github.com/moses-palmer/pynput/issues/6" target="_blank" rel="noopener">这个issue</a>，虽然上面有着解决方法，但是我没有得到解决，只能忍痛弃之 （或者可以曲线救国，采用蓝牙键盘？没试过）</strong></p><h2 id="3-keyboard库"><a href="#3-keyboard库" class="headerlink" title="3. keyboard库"></a>3. keyboard库</h2><p><a href="https://github.com/boppreh/keyboard" target="_blank" rel="noopener">keyboard库</a>在github上是有较多star的，内容非常多，功能十分强大，你能想到的基本都有….不过我看着头疼，当然，没有选择的另外一个原因是发现了另外一个小脚本来实现我所需要的键盘监听功能，这也是我待会要说的，如果要用其他关于键盘的行为操作，建议好好琢磨下这个库。</p><h2 id="4-神奇小脚本"><a href="#4-神奇小脚本" class="headerlink" title="4. 神奇小脚本"></a>4. 神奇小脚本</h2><p>网上看着看着，突然发现了国外大佬的这篇文章<a href="https://www.jonwitts.co.uk/archives/896" target="_blank" rel="noopener">Detecting keyboard input in Python</a>，完美测试，感觉好极了！先贴代码：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span> <span class="hljs-comment"># adapted from https://github.com/recantha/EduKit3-RC-Keyboard/blob/master/rc_keyboard.py</span> <span class="hljs-keyword">import</span> sys, termios, tty, os, time <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getch</span><span class="hljs-params">()</span>:</span>    fd = sys.stdin.fileno()    old_settings = termios.tcgetattr(fd)    <span class="hljs-keyword">try</span>:        tty.setraw(sys.stdin.fileno())        ch = sys.stdin.read(<span class="hljs-number">1</span>)     <span class="hljs-keyword">finally</span>:        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)    <span class="hljs-keyword">return</span> ch button_delay = <span class="hljs-number">0.2</span> <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    char = getch()     <span class="hljs-keyword">if</span> (char == <span class="hljs-string">"p"</span>):        print(<span class="hljs-string">"Stop!"</span>)        exit(<span class="hljs-number">0</span>)     <span class="hljs-keyword">if</span> (char == <span class="hljs-string">"a"</span>):        print(<span class="hljs-string">"Left pressed"</span>)        time.sleep(button_delay)     <span class="hljs-keyword">elif</span> (char == <span class="hljs-string">"d"</span>):        print(<span class="hljs-string">"Right pressed"</span>)        time.sleep(button_delay)     <span class="hljs-keyword">elif</span> (char == <span class="hljs-string">"w"</span>):        print(<span class="hljs-string">"Up pressed"</span>)        time.sleep(button_delay)     <span class="hljs-keyword">elif</span> (char == <span class="hljs-string">"s"</span>):        print(<span class="hljs-string">"Down pressed"</span>)        time.sleep(button_delay)     <span class="hljs-keyword">elif</span> (char == <span class="hljs-string">"1"</span>):        print(<span class="hljs-string">"Number 1 pressed"</span>)        time.sleep(button_delay)</code></pre></div></p><p><strong>说实话其实<code>getch</code>这个函数我没太看懂，我也不想花时间研究它了，轮子已经造好了，正如这篇文章的作者一样，他也进行了一些搜索并找到了一些示例代码，但是没有一个完全符合要求，直到github上发现了<a href="https://github.com/recantha/EduKit3-RC-Keyboard/blob/master/rc_keyboard.py" target="_blank" rel="noopener">control a robot with a bluetooth keyboard </a>这篇文章，也是感叹极客的给力！</strong></p><h2 id="5-碎碎念"><a href="#5-碎碎念" class="headerlink" title="5. 碎碎念"></a>5. 碎碎念</h2><p>回过头来整理时发现了更巧的事情，<a href="https://github.com/recantha/EduKit3-RC-Keyboard/blob/master/rc_keyboard.py" target="_blank" rel="noopener">control a robot with a bluetooth keyboard </a>这篇文章也是用键盘来控制两个马达，控制前进后退（虽然马达类型不一样），真是太巧了，哈哈哈哈哈～</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker常用命令整理</title>
    <link href="/2019/07/10/docker-common-commands/"/>
    <url>/2019/07/10/docker-common-commands/</url>
    
    <content type="html"><![CDATA[<p>因为工作需要接触到了Docker，发现这个东西是真的好用。容器带来的隔离效果对我这种强迫症患者太友好了。学一个新的框架或者数据库，docker搞起来，无论怎么糟蹋怎么设置，出现小问题啥的直接移除这个容器，再创个干净的新的重头再来，少了很多配置的烦恼，电脑上也不用装很多乱七八糟的东西！所以这篇文章就记录下最近自己整理的常用的docker命令，以便后续翻阅。</p><p><strong>由于国内网络环境的缘故，要使用国内源安装，安装过程看<a href="https://yeasy.gitbooks.io/docker_practice/install/ubuntu.html" target="_blank" rel="noopener">这里的教程</a></strong></p><h2 id="1-操作容器"><a href="#1-操作容器" class="headerlink" title="1. 操作容器"></a>1. 操作容器</h2><ul><li><p>启动容器以后台方式运行(更通用的方式）<br><code>docker run --name container_name -v /path/to/hostdir:/mnt -d -p 5000:5000 image_name</code></p></li><li><p>在运行着的容器内部运行一条命令(比attach更好用)<br><code>docker exec -it   &lt;id/container_name&gt;  /bin/(bash|sh)</code></p></li><li><p>附着到正在运行的容器<br><code>docker attach &lt;id/container_name&gt;</code></p></li><li><p>实时查看日志输出<br><code>docker logs -f &lt;id/container_name&gt; (类似 tail -f) (带上时间戳-t）</code></p></li><li><p>列出当前所有正在运行的container(类似的选项就不说了 docker ps –help)<br><code>docker ps</code></p></li><li><p>显示一个运行的容器里面的进程信息<br><code>docker top &lt;id/container_name&gt;</code></p></li><li><p>显示容器统计信息（可选–no-stream，all等参数）<br><code>docker stats</code></p></li><li><p>查看容器内部详情细节<br><code>docker inspect &lt;id/container_name&gt;</code></p></li><li><p>从容器内拷贝文件到主机上(从主机拷贝到容器里将cp后面两个参数调换)<br><code>docker cp &lt;id/container_name&gt;:/file/path/within/container /host/path/target</code></p></li><li><p>保存对容器的修改（commit） 当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器<br><code>docker commit &lt;id/container_name&gt; new_image_name</code></p></li><li><p>删除单个容器（可加-f选项）<br><code>docker rm &lt;id/container_name&gt;</code></p></li><li><p>删除所有容器<br><code>docker rm  $(docker ps -a -q)</code></p></li><li><p>查看容器内部详情细节<br><code>docker inspect -f &#39;{range .NetworkSettings.Networks}{.IPAddress}{end}&#39; container_name_or_id</code></p><blockquote><p>注意这里format之后不是一对{} 而是两对，这里有bug，所以先这么写着</p></blockquote></li><li><p>停止、启动、杀死、重启一个容器<br><code>docker stop|start|kill|restart &lt;id/container_name&gt;</code></p></li></ul><h2 id="2-操作镜像"><a href="#2-操作镜像" class="headerlink" title="2. 操作镜像"></a>2. 操作镜像</h2><ul><li><p>列出镜像（可加-a ，-q选项）<br><code>docker images</code></p></li><li><p>从dockerhub检索image<br><code>docker search image_name</code></p></li><li><p>下载image<br><code>docker pull image_name</code></p></li><li><p>删除一个或者多个镜像(可加-f选项)<br><code>docker rmi image_name</code></p></li><li><p>显示一个镜像的历史<br><code>docker history image_name</code></p></li><li><p>发布docker镜像<br><code>docker image push my_repo/my_image:my_tag</code></p></li><li><p>删除一个或者多个镜像<br><code>docker rmi image_name</code></p></li><li><p>保存一个镜像到一个tar文件里（反过来就是解压）<br><code>docker save debian -o mydebian.tar</code><br><code>docker load -i mydebian.tar</code></p></li><li><p>给镜像打标签(标签指向源镜像，多生产一个)<br><code>docker tag centos:7 mycentos7:v1</code></p></li></ul><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h2><ul><li><p>通过Dockerfile生成新的镜像<br><code>docker build  -t new_image_name:tag .</code></p></li><li><p>显示系统范围信息<br><code>docker info</code></p></li><li><p>提供docker 版本信息<br><code>docker version</code></p></li><li><p>查看docker0的网络(宿主机上操作)<br><code>ip a show docker0</code></p></li><li><p>附着到容器内部查看其内部ip：<br><code>ip a show eth0</code></p></li><li><p> 登录到Docker registry.<br><code>docker login</code></p></li><li><p>删除所有未使用的容器，未使用的网络和悬空图像(也可单独删除)<br><code>docker system prune</code></p></li></ul><h2 id="4-念念不忘"><a href="#4-念念不忘" class="headerlink" title="4. 念念不忘"></a>4. 念念不忘</h2><ul><li><a href="https://gist.github.com/garystafford/f0bd5f696399d4d7df0f" target="_blank" rel="noopener">国外友人自己整理的有用的Docker命令</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL 常用命令记录</title>
    <link href="/2019/07/10/postgresql-tutorial/"/>
    <url>/2019/07/10/postgresql-tutorial/</url>
    
    <content type="html"><![CDATA[<p>从之前看的<code>Two Scoops Press Two Scoops of Django 1.11</code>书籍或者是官网的教程，又或者最近在github查找django-docker人家的代码时看到的，都是用的PostgreSQL作为Django的数据库，平常都是用的Mysql，是不是验证了”国外大多用PostgresSQL，国内大多用Mysql“这句话，我对这个数据库比较陌生，但是既然官网都主推了，相对Mysql也有额外特色功能,SQL语句大多是通用的，不如把其他的基础使用语法记录一下，也算入门了。</p><h2 id="1-好的开始"><a href="#1-好的开始" class="headerlink" title="1. 好的开始"></a>1. 好的开始</h2><ul><li><p>创建一个新的PostgreSQL角色并输入密码，可选选项查看<a href="https://www.postgresql.org/docs/11/app-createuser.html" target="_blank" rel="noopener">createuser文档</a><br><code>createuser -P -e dbuser</code></p><blockquote><p><code>-e</code>选项为创建完成过后的通知消息，下同</p></blockquote></li><li><p>创建数据库，可选选项查看<a href="https://www.postgresql.org/docs/11/app-createdb.html" target="_blank" rel="noopener">createdb选项</a><br><code>createdb -e -O dbuser  mydb</code></p></li><li><p>通过sql文件导入数据<br><code>psql mydb &lt; mydb.sql</code></p></li><li><p>如果数据库存在则删除该数据库<br><code>dropdb --if-exists mydb</code></p></li><li><p>如果数据用户存在则删除该用户<br><code>dropuser --if-exists dbuser</code></p></li></ul><p>也可以用交互的方法<br><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment">#　su postgres first login postgres DB</span>psql<span class="hljs-comment"># create user</span>CREATE USER dbuser WITH PASSWORD <span class="hljs-string">'password'</span>;<span class="hljs-comment"># create db</span>CREATE DATABASE exampledb OWNER dbuser;<span class="hljs-comment"># grant all privileges</span>GRANT ALL PRIVILEGES ON DATABASE exampledb to dbuser;<span class="hljs-comment"># login exampledb</span>psql -U dbuser -d exampledb -h 127.0.0.1 -p 5432<span class="hljs-comment"># if linux user == db user</span>psql exampledb<span class="hljs-comment"># psql exampledb &lt; exampledb.sql</span></code></pre></div></p><ul><li>将PostgreSQL数据库导出到一个脚本文件<br><code>pg_dump</code></li><li>将所有的PostgreSQL数据库导出到一个脚本文件<br><code>pg_dumpall</code></li><li>从一个由pg_dump或pg_dumpall程序导出的脚本文件中恢复PostgreSQL数据库<br><code>pg_restore</code></li></ul><h2 id="2-快捷命令"><a href="#2-快捷命令" class="headerlink" title="2. 快捷命令"></a>2. 快捷命令</h2><div class="hljs"><pre><code class="hljs bash">\h：查看SQL命令的详细解释，例如 \h select?：查看psql命令列表\l：列出所有数据库\c [database_name]：连接其他数据库\d （table）：列出数据库的所有表（某一具体表） \dn：查看表架构\di：查看索引\du：列出所有数据库用户\conninfo：列出连接<span class="hljs-comment">#　更多请查看 \?</span></code></pre></div><h2 id="3-东张西望"><a href="#3-东张西望" class="headerlink" title="3. 东张西望"></a>3. 东张西望</h2><ul><li><a href="http://www.freeoa.net/osuport/db/postgresql-comm-used-cmd-refer_3072.html" target="_blank" rel="noopener">PostgreSQL最常用命令参考</a></li><li><a href="https://blog.csdn.net/baidu_33387365/article/details/80883142" target="_blank" rel="noopener">PostgreSQL：深入理解 template1 和 template0</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django+Gunicorn+Nginx配置整理</title>
    <link href="/2019/07/08/django-gunicorn-nginx-config/"/>
    <url>/2019/07/08/django-gunicorn-nginx-config/</url>
    
    <content type="html"><![CDATA[<p>之前一篇文章我们梳理了WSGI与WSGI服务器的一些概念，这里主要整理下web应用部署时候的配置，包括Gunicorn以及Nginx的配置，方便以后翻阅</p><h2 id="1-Gunicorn使用及配置"><a href="#1-Gunicorn使用及配置" class="headerlink" title="1. Gunicorn使用及配置"></a>1. Gunicorn使用及配置</h2><blockquote><p>我们可以通过执行<strong><code>./manage.py runserver</code></strong>命令来运行我们的django应用程序。但我们知道它被称为开发服务器是有原因的，因为自带的开发服务器不健壮，安全问题，线程问题等等。那么，我们如何真正运行我们的应用呢？</p></blockquote><p><strong>Gunicorn，一个简单，轻便，快速的Python WSGI HTTP Server for UNIX。</strong></p><ul><li><p>绑定一个具体的端口</p><div class="hljs"><pre><code class="hljs python">gunicorn --bind <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">8030</span> myproject.wsgi</code></pre></div></li><li><p>增加请求服务的worker数量</p><div class="hljs"><pre><code class="hljs python">gunicorn --workers <span class="hljs-number">3</span> myproject.wsgi</code></pre></div></li><li><p>以守护进程模式来运行</p><div class="hljs"><pre><code class="hljs python">gunicorn --daemon myproject.wsgi</code></pre></div></li><li><p>或者把上面三个组合起来这是常用的</p><div class="hljs"><pre><code class="hljs python">gunicorn -D -b <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">8030</span> -w <span class="hljs-number">3</span> myproject.wsgi</code></pre></div></li><li><p>或者我更喜欢把配置写到配置文件里</p><div class="hljs"><pre><code class="hljs python">gunicorn -c /path/to/config/gunicorn.conf.py  myproject.wsgi</code></pre></div></li></ul><p><strong>gunicorn.conf.py</strong> 配置文件模板如下，具体可以去看<a href="http://docs.gunicorn.org/en/stable/" target="_blank" rel="noopener">Gunicorn官方文档</a> ：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<span class="hljs-keyword">import</span> logging.handlers<span class="hljs-keyword">from</span> logging.handlers <span class="hljs-keyword">import</span> WatchedFileHandler<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> multiprocessingbind = <span class="hljs-string">"unix:/tmp/gunicorn.sock"</span>   <span class="hljs-comment">#绑定的ip与端口</span>backlog = <span class="hljs-number">512</span>                <span class="hljs-comment">#监听队列数量，64-2048</span><span class="hljs-comment">#chdir = '/home/test/server/bin'  #gunicorn要切换到的目的工作目录</span>worker_class = <span class="hljs-string">'sync'</span> <span class="hljs-comment">#使用gevent模式，还可以使用sync 模式，默认的是sync模式</span>workers = <span class="hljs-number">4</span> <span class="hljs-comment"># multiprocessing.cpu_count()    #进程数</span>threads = <span class="hljs-number">16</span> <span class="hljs-comment">#multiprocessing.cpu_count()*4 #指定每个进程开启的线程数</span>loglevel = <span class="hljs-string">'info'</span> <span class="hljs-comment">#日志级别，这个日志级别指的是错误日志的级别，而访问日志的级别&gt;无法设置</span><span class="hljs-comment">#access_log_format = '%(t)s %(p)s %(h)s "%(r)s" %(s)s %(L)s %(b)s %(f)s" "%(a)s"'</span>access_log_format = <span class="hljs-string">'%(t)s %(p)s %(h)s "%(r)s" %(s)s'</span><span class="hljs-comment">#accesslog = "./gunicorn_access.log"      #访问日志文件</span><span class="hljs-comment">#errorlog = "./gunicorn_error.log"        #错误日志文件</span>accesslog = <span class="hljs-string">"-"</span>  <span class="hljs-comment">#访问日志文件，"-" 表示标准输出</span>errorlog = <span class="hljs-string">"-"</span>   <span class="hljs-comment">#错误日志文件，"-" 表示标准输出</span></code></pre></div></p><h2 id="2-一对好基友：Supervisor与Gunicorn"><a href="#2-一对好基友：Supervisor与Gunicorn" class="headerlink" title="2. 一对好基友：Supervisor与Gunicorn"></a>2. 一对好基友：Supervisor与Gunicorn</h2><p>我们可以用supervisor来管理Gunicorn服务，配置模板如下。<br><div class="hljs"><pre><code class="hljs python">[program:orderlunch]command= pipenv run gunicorn -c gunicorn.conf.py OrderLunch.wsgidirectory=/home/pi/OrderLunchEnv/OrderLunchuser=pinumprocs=<span class="hljs-number">1</span>stdout_logfile=/var/log/supervisor/orderlunch.logstderr_logfile=/var/log/supervisor/orderlunch_error.logautostart= trueautorestart=truestopwaitsecs = <span class="hljs-number">600</span>killasgroup=truepriority=<span class="hljs-number">999</span></code></pre></div></p><h2 id="3-Gunicorn如何处理静态文件？"><a href="#3-Gunicorn如何处理静态文件？" class="headerlink" title="3. Gunicorn如何处理静态文件？"></a>3. Gunicorn如何处理静态文件？</h2><blockquote><p>在用Gunicorn跑Django的时候,比较郁闷的是静态文件的处理,即使在settings设置DEBUG=True,静态文件也不会正常显示.生产环境下一般不会裸跑Gunicorn,一般都会在前面放一个Nginx反代到Gunicorn,而静态文件直接交给Nginx处理.<br>但是如heroku,coding.net的演示平台这种PaaS就不能自己配置反向代理,怎么样设置wsgi才能正常处理静态文件呢.这里总结下处理这个问题的经验。</p></blockquote><p>以上问题来自<a href="https://zhu327.github.io/2015/09/29/gunicorn%E8%BF%90%E8%A1%8Cdjango%E6%97%B6%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">Gunicorn运行Django时静态文件处理</a> </p><p>这里提到了两个方法来解决此问题：</p><ul><li><strong>1. 强制使用Django自带的静态文件处理器</strong></li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<span class="hljs-keyword">from</span> django.conf.urls.static <span class="hljs-keyword">import</span> staticurlpatterns = [    <span class="hljs-comment"># ... the rest of your URLconf goes here ...</span>] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT）</code></pre></div><ul><li><strong>2. 使用第三方库Whitenoise用来处理wsgi app静态文件</strong><br>这个方法比较好一点，用Whitenoise搭配Gunicorn,完全能在没有Nginx的情况下在生产环境中处理静态文件，配置非常简单，可以参考 <a href="http://whitenoise.evans.io/en/stable/" target="_blank" rel="noopener">Whitenoise官方文档</a> </li></ul><h2 id="4-Nginx与Gunicorn配置记录"><a href="#4-Nginx与Gunicorn配置记录" class="headerlink" title="4. Nginx与Gunicorn配置记录"></a>4. Nginx与Gunicorn配置记录</h2><p>网上的教程鱼龙混杂，配置各个都不太一样，但大差不差，有些能用有些不能用，踩了蛮多坑，把自己的第一次成功配置贴在下面，方便自己以后回来查看。</p><div class="hljs"><pre><code class="hljs shell">server &#123;    listen 80;    server_name 0.0.0.0;    access_log /var/log/nginx/orderlunch_access_log;    error_log /var/log/nginx/orderlunch_error_log;    location  = /favicon.ico &#123; access_log off ; log_not_found off ;  &#125;    location / &#123;      include proxy_params;      proxy_pass http://unix:/tmp/gunicorn.sock;    &#125;    location /static &#123;      alias  /home/pi/OrderLunchEnv/OrderLunch/collected_static;      #　这里注意alias与root的区别    &#125;&#125;</code></pre></div><p>这里gunicorn我用的是<code>.sock</code>，所以相应的nginx这边的proxy_pass也要用sock，当然也可以用，http+port的形式。<br>配置到能访问网址，不止是一个配置文件就能解决的，完整的过程看这边：<a href="http://rahmonov.me/posts/run-a-django-app-with-nginx-and-gunicorn/" target="_blank" rel="noopener">run-a-django-app-with-nginx-and-gunicorn</a>  以及<a href="https://www.cnblogs.com/nanrou/p/7026802.html" target="_blank" rel="noopener">初次部署django+gunicorn+nginx</a> ,用来看看一些概念和思路。</p><h2 id="5-更好的解决方式：Docker"><a href="#5-更好的解决方式：Docker" class="headerlink" title="5. 更好的解决方式：Docker"></a>5. 更好的解决方式：Docker</h2><p>研究的过程中，接触到了Docker。我们可以用pipenv保持python开发环境的一致，干净，但是当涉及到一些系统级别的服务时，比如redis作为消息队列 ，nginx作为代理服务器时，我们怎么做到隔离呢，那就是用Docker。这真的是太方便了！有时候因为Ubuntu系统版本的问题，或者之前设置过了这会想删除之前项目部署重新设置，可能存在一系列让人烦躁的事情，而Docker直接搞一个Nginx容器用来做反向代理，用一个redis容易作为消息队列的存储，干净的容器，不用了将容器直接关闭或者清除，也不用操心各个容器间的内部网络，都实现好了。<br>输入关键字docker django能在gihtub找到很多别人写的。我找到一个自己认为较好的，fork之后然后进行了一些修改（比如生成docker 镜像时，新增了国内下载源等），项目地址在这<a href="https://github.com/fantasyhh/docker-django" target="_blank" rel="noopener">docker-django</a> ，可以先按照教程跑起来然后查看内部的实现原理，会发现docker真的乃一部署神器！</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这一配置篇与上一章的概念篇，把我最近关于对wsgi以及部署方面的一些概念进行了总结，也算解了心中一大困惑，部署是常见的事，记录下来，有规矩，才有方圆～</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Gunicorn</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梳理Python WSGI与WSGI服务器等概念</title>
    <link href="/2019/06/27/python3-wsgi-concept/"/>
    <url>/2019/06/27/python3-wsgi-concept/</url>
    
    <content type="html"><![CDATA[<p>经常接触Django，问自己一个问题：Django项目中与setttings文件同目录的wsgi.py是干什么用的？这个问题熟悉而又陌生，wsgi.py这个文件可以说无时无刻不在我们眼皮底下出现，但又对它真正的功能作用知之甚少。更早的时候，将Django部署在Apache上会用到mod-wsgi，这是两者之间通信的媒介。忙碌中整理一些概念与教程来梳理这些概念，解惑也。</p><h2 id="1-首先弄清下面几个概念"><a href="#1-首先弄清下面几个概念" class="headerlink" title="1. 首先弄清下面几个概念"></a>1. 首先弄清下面几个概念</h2><p><strong>WSGI</strong>：全称是Web Server Gateway Interface，WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。</p><p><img src="/images/wsgi/wsgi.png" srcset="/img/loading.gif" alt=" " title="wsgi"></p><blockquote><p>WSGI存在的目的有两个：</p><ol><li>让Web服务器知道如何调用Python应用程序，并且把用户的请求告诉应用程序。</li><li>让Python应用程序知道用户的具体请求是什么，以及如何返回结果给Web服务器。</li></ol></blockquote><p><strong>uwsgi</strong>：与WSGI一样是一种通信协议，<strong>是uWSGI服务器的独占协议</strong>，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。</p><p><strong>uWSGI</strong>：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。</p><p><strong>WSGI协议主要包括server(或者gateway)和application(或者framework)两部分：</strong></p><ul><li><p>WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端；</p></li><li><p>WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：<strong>对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器</strong>。</p></li></ul><blockquote><p>​ WSGI Middleware（中间件）也是WSGI规范的一部分。上一章我们已经说明了WSGI的两个角色：server和application。那么middleware是一种运行在server和application中间的应用（一般都是Python应用）。middleware同时具备server和application角色，对于server来说，它是一个application；对于application来说，它是一个server。middleware并不修改server端和application端的规范，只是同时实现了这两个角色的功能而已。</p></blockquote><p><img src="/images/wsgi/middleware.png" srcset="/img/loading.gif" alt="middleware"> </p><p>WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和application组合实现自己的web应用。例如<strong>uWSGI和Gunicorn</strong>都是实现了WSGI server协议的服务器，<strong>Django，Flask</strong>是实现了WSGI application协议的web框架，可以根据项目实际情况搭配使用，详细的我们后面说。</p><h2 id="2-WSGI实现原理以及”兄弟”CGI-FastCGI"><a href="#2-WSGI实现原理以及”兄弟”CGI-FastCGI" class="headerlink" title="2. WSGI实现原理以及”兄弟”CGI FastCGI?"></a>2. WSGI实现原理以及”兄弟”CGI FastCGI?</h2><p>WSGI原理的内部实现，说简单不简单说复杂却不复杂，这里不细说，我们可以<strong><a href="http://luckylau.tech/2017/02/28/python%E7%9A%84wsgi%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">用简单实例来理解Python WSGI</a> </strong></p><p>那么<code>CGI</code> <code>FastCGI</code>又是什么？是不是跟WSGI有什么关系？我们可以翻阅下<a href="https://blog.callmewhy.com/2015/12/07/what-is-wsgi-and-cgi/" target="_blank" rel="noopener">CGI FastCGI WSGI 学习笔记 </a> 就会豁然开朗了</p><h2 id="3-WSGI服务器的选择？"><a href="#3-WSGI服务器的选择？" class="headerlink" title="3. WSGI服务器的选择？"></a>3. WSGI服务器的选择？</h2><p>上面提到<strong>uWSGI和Gunicorn</strong>都是实现了WSGI server协议的服务器，还有我之前用过的部署在Apache上mod_wsgi, 那么对于这些东西，为什么需要一个？我应该选择哪一个？</p><blockquote><p><strong>django自带的web server目的是方便开发，不是能直接放到生产环境的,直接引用django的文档。It’s intended only for use while developing. (We’re in the business of making Web frameworks, not Web servers.)</strong></p></blockquote><blockquote><p> <strong>使用Gunicorn，除非你在Windows上部署，在这种情况下使用mod_wsgi。</strong></p></blockquote><p><img src="/images/wsgi/which_wsgi_server.png" srcset="/img/loading.gif" alt="which_server"> </p><p>具体的解释我这里用这篇英文原文<a href="https://djangodeployment.com/2017/01/02/which-wsgi-server-should-i-use/" target="_blank" rel="noopener">Which WSGI server should I use?</a> 翻译一下来回答。</p><p>如图所示（我们可以暂时忽略掉图中的Web Server，这是下一小节要说的），Web浏览器与Web服务器通信，Web服务器又与WSGI服务器通信。该WSGI服务器不会直接与你的Django项目通信，而是导入 Django项目。它是这么做的：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django_project.wsgi <span class="hljs-keyword">import</span> applicationapplication(args)</code></pre></div></p><p>因此，从操作系统的角度来看，你的Django项目将成为WSGI服务器的一部分; 这是同一个过程。调用<strong><code>application()</code></strong>的方式由WSGI规范标准化。这个函数的接口是标准化的，这使得你可以在许多不同的WSGI服务器（如Gunicorn，uWSGI或mod_wsgi）之间进行选择，以及为什么每个服务器都可以与许多Python应用程序框架（如Django或Flask）进行交互。</p><p>mod_wsgi仅适用于Apache，我更偏向于可与Apache或nginx一起使用的方法。这样的话，使更改Web服务器变得更容易。我也发现Gunicorn更容易设置和维护。</p><p>我使用了uWSGI几年，并且被它的功能所震撼。其中许多都复制了Apache或nginx或堆栈其他部分中已存在的功能，因此很少需要它们。它的文档有点混乱。开发人员自己承认：“我们尽力提供良好的文档，但这是一项艰苦的工作。对不起。“我记得每周都会遇到问题并且每次花费数小时来解决问题。</p><p>另一方面，Gunicorn正是你想要的恰到好处的功能。它很简单，工作正常。所以我推荐它，除非在你的特殊情况下有一个令人信服的理由使用其中一个。</p><p>uWSGI和Gunicorn没法在Windows中运行，因此如果你在Windows上部署那就使用Apache + mod_wsgi。</p><h2 id="4-既然有了WSGI-Server，为什么我们还需要Nginx（Web-Server）"><a href="#4-既然有了WSGI-Server，为什么我们还需要Nginx（Web-Server）" class="headerlink" title="4. 既然有了WSGI Server，为什么我们还需要Nginx（Web Server）?"></a>4. 既然有了WSGI Server，为什么我们还需要Nginx（Web Server）?</h2><blockquote><p>如果只有一个应用，不需要负载均衡；只提供api服务，没有静态文件；不需要额外的访问控制等功能这样是不是就不需要nginx等反向代理？答案是需要。nginx可以缓冲请求和响应。如果让Gunicorn直接提供服务，浏览器发起一个请求，鉴于浏览器和网络情况都是未知的，http请求的发起过程可能比较慢，而Gunicorn只能等待请求发起完成后，才去真正处理请求，处理完成后，等客户端完全接收请求后，才继续下一个。nginx缓存客户端发起的请求，直到收完整个请求，转发给Gunicorn，等Gunicorn处理完成后，拿到响应，再发给客户端，这个流程是nginx擅长处理，而Gunicorn不擅长处理的。因此将Gunicorn置于nginx后面，可以有效提高Gunicorn的处理能力。  ——摘自知乎<a href="https://www.zhihu.com/question/38528616" target="_blank" rel="noopener">Nginx、Gunicorn在服务器中分别起什么作用？</a> 某回答</p></blockquote><p><img src="/images/wsgi/nginx+gunicorn.png" srcset="/img/loading.gif" alt="nginx+gunicorn"></p><p>当我们为Gunicorn运行我们的django应用程序而开心时，然而，最后，我们看到管理面板的样式已经消失了。原因是Gunicorn是一个应用程序服务器，只运行应用程序（在我们的例子中是django app）和django，正如我们所知，<strong>除了开发之外，它不提供静态文件</strong>。Nginx来救援！它将是Gunicorn的反向代理。到底是什么反向代理？好问题！我们都知道VPN是什么，对吧？我们使用它们访问某些因某种原因被阻止的网站。在这种情况下，我们通过VPN访问该网站：我们 - &gt; VPN - &gt;某些网站。这种代理称为正向代理。至于反向代理，可以将它们视为强制代理。例如，用户正在尝试访问我们在gunicorn中运行的django应用程序。它认为它正在直接访问该应用程序。然而，真正的过程是它首先访问Nginx服务器，该服务器决定下一步该做什么，如果用户正在访问静态文件，Nginx服务器将自行提供服务。否则，它会将其重定向到Gunicorn。简单来说，<strong>http请求将由Gunicorn处理，而静态处理则由Nginx处理。这就是我们需要Nginx的原因</strong>。<br>除此之外，<strong>Nginx还提高了性能，可靠性，安全性和规模</strong>。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>这几天晚上睡觉前花了一点时间来对这些概念进行了一些整理，收获颇多。要想真正的成为一名Web开发，并不是简单的套用框架写写逻辑层，而是框架背后的原理与流程，这才是重中之重，了解了这些，所有的类似框架以后上手都能快半分。接下去，会对Gunicorn，Nginx的配置文件做个记录（这中间也踩了点坑），再往后就是Nginx与docker的理解与实践了，加油～</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Wsgi</tag>
      
      <tag>Gunicorn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Revpi 重装系统以及本地化配置的注意项</title>
    <link href="/2019/06/24/revpi-install-img/"/>
    <url>/2019/06/24/revpi-install-img/</url>
    
    <content type="html"><![CDATA[<p>Revolution Pi是一个迷你工业PC，我一般叫它工业树莓派，产自德国。它的基础模块叫作 RevPi core，装有 Raspberry Pi 计算模块。该计算模块包含两个 IC：一个 Broadcom BCM2835 SoC 带 500 Mbyte RAM 和一个 4 Gbyte eMMC 闪存。该模块通过主板插座提供 1.8 V、3.3 V 和 5 V。采用单排200针宽插座，所有 IO 信号连接到主板。</p><p>系统跟树莓派一样，都是Raspbian（Debian变体)。但装系统起来却是很大不一样，相隔半年再装一次系统之前的操作都忘得差不多了，在这记录点坑</p><h2 id="1-关于重装系统"><a href="#1-关于重装系统" class="headerlink" title="1. 关于重装系统"></a>1. 关于重装系统</h2><p>这里主要对<a href="https://revolution.kunbus.com/tutorials/images/install-jessie/" target="_blank" rel="noopener">Revpi官方安装jessie手册</a> 某些“看似平淡的重点”（坑）做一些强调</p><ul><li><p>如果老镜像没有什么要保存的，为了节省时间，可以跳过教程里面的<strong><code>Saving old image</code></strong>，直接装新镜像</p></li><li><p>不同于树莓派的直接写入镜像，Revpi安装新系统需要在window上并依赖<strong><code>RPi Boot</code></strong>这个软件，软件加载时，重启下Revpi，就有反应了</p></li><li><p>将RevPi Core的迷你USB端口连接到PC上的USB时，如果插上磁盘系统显示时有两个磁盘，需要将两个磁盘合并下然后再写入镜像，不然会出错</p></li><li><p>镜像下载正确，写入的时候可以不需要校验</p></li></ul><h2 id="2-关于系统登录"><a href="#2-关于系统登录" class="headerlink" title="2. 关于系统登录"></a>2. 关于系统登录</h2><p>Revpi是德国的，所以装完系统默认都是符合德国人习惯的，需要蛮多方面的配置，配置的动作同样适用于树莓派</p><ul><li><p>写完镜像就可以直接进入系统，默认账户是pi，密码是raspberry，但默认是德国键盘，y跟z的按键互换下，这里注意下</p></li><li><p>之后会要求输入设备型号，serial code ，以及Mac address，这些都在设备外壳上写着，特别是serial code是一串数字，不太好分辨(在机器的左下角，五位数字，我的是13829)</p></li><li><p>进入系统之后的第一次重启之后，系统会将你的密码默认修改成你的设备特有的id号，raspberry这个密码已经没用了，切记～</p></li></ul><h2 id="3-关于本地化配置"><a href="#3-关于本地化配置" class="headerlink" title="3. 关于本地化配置"></a>3. 关于本地化配置</h2><p>用<strong><code>raspi-config</code></strong>进行设备本地化配置，包括语言键盘WIFI等</p><ul><li><p>Raspbian默认的是英国键盘布局，而我们在中国使用的键盘布局与美国的相同，直接选择Generic 105-key (Intl) PC键盘，里面在列表里选择English (US)，然后你会被问到关于辅助键的问题，选择默认的选项，并且在下一个画面中选择No compose key选项。同样，如果你需要更改这个设置，可以使用raspi-config来更改。最后一个选项为是否打开CTRL+ALT+BACKSPACE的组合键。它可以在你的图形界面崩溃时，不需重启而将图形界面进程结束掉</p></li><li><p>然后是设置你的“区域”，这个主要会决定系统使用的字符集和语言。这里保险起见，系统本身勾选的不动，再勾选下面几个选项，把中英文都涵盖：</p><div class="hljs"><pre><code>en_US.UTF-8 UTF-8zh_CN GB2312zh_CN.GBK GBKzh_CN.UTF-8 UTF-8</code></pre></div></li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>其实装系统这种没必要把操作记录下来，但是关于Revpi的相关资料网上资料都非常的少，极其罕见，而且坑较多，所以一步一步注意点写下来，以后做类似事情时可以节省点时间</p>]]></content>
    
    
    <categories>
      
      <category>RaspberryPi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RaspberryPi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 队列用法整理</title>
    <link href="/2019/06/13/python3-queue/"/>
    <url>/2019/06/13/python3-queue/</url>
    
    <content type="html"><![CDATA[<p>先进先出队列(或简称队列)是一种基于先进先出(FIFO)策略的集合类型.</p><p>队列的最简单的例子是我们平时不时会参与的列。排队等待电影，在杂货店的收营台等待，在自助餐厅排队等待（这样我们可以弹出托盘栈）。行为良好的线或队列是有限制的，因为它只有一条路，只有一条出路。不能插队，也不能离开。你只有等待了一定的时间才能到前面。下图展示了一个简单的 Python 对象队列。<br>    <img src="/images/queue.png" srcset="/img/loading.gif" alt="队列"></p><h2 id="1-队列"><a href="#1-队列" class="headerlink" title="1. 队列"></a>1. 队列</h2><blockquote><p>队列是有序数据集合，队列的特点，删除数据项是在头部，称为前端(front)，增加数据在尾部，称为后端(rear)</p></blockquote><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># 导入队列</span><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<span class="hljs-comment"># 最多接收3个数据</span>q = Queue(<span class="hljs-number">3</span>)<span class="hljs-comment"># put 向队列中添加数据</span>q.put(<span class="hljs-number">1</span>)q.put(<span class="hljs-number">2</span>)q.put(<span class="hljs-number">3</span>)<span class="hljs-comment"># 获取当前队列长度</span>print(q.qsize())<span class="hljs-comment"># 取出最前面的一个数据 1 , 还剩两个</span>print(q.get())<span class="hljs-comment"># 再加入数据</span>q.put(<span class="hljs-number">4</span>)<span class="hljs-comment">#超过三个了.如果没有timeout参数会处于阻塞状态,卡在那边.若设置2秒,2秒后会raise 一个 FULL的报错</span>q.put(<span class="hljs-number">5</span>, timeout=<span class="hljs-number">2</span>))<span class="hljs-comment"># 当然,也可以直接给个 block=False,强制设置为不阻塞(默认为会阻塞的)，一旦超出队列长度，立即抛出异常</span>q.put(<span class="hljs-number">6</span>, block=<span class="hljs-literal">False</span>)<span class="hljs-comment"># 同样的,当取值(get)的次数大于队列的长度的时候就会产生阻塞，设置超时时间意为最多等待x秒，队列中再没有数据，就抛出异常.</span><span class="hljs-comment"># 也可以使用block参数,跟上面一样</span></code></pre></div><p>其他常用方法:<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#empty: 检查队列是否为空，为空返回True，不为空返回False</span><span class="hljs-comment">#full : 判断队列是否已经满了</span><span class="hljs-comment">#join &amp; task_done : 阻塞与任务完成</span><span class="hljs-comment">#举例</span><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queueq = Queue(<span class="hljs-number">2</span>)q.put(<span class="hljs-string">'a'</span>)q.put(<span class="hljs-string">'b'</span>)<span class="hljs-comment"># 程序会一直卡在下面这一行，只要队列中还有值，程序就不会退出</span>q.join()<span class="hljs-comment">#-------------------------------------------------------------</span>q = Queue(<span class="hljs-number">2</span>)q.put(<span class="hljs-string">'a'</span>)q.put(<span class="hljs-string">'b'</span>)q.get()q.get()<span class="hljs-comment"># 插入两个元素之后再取出两个元素，执行后发现，程序还是卡在下面的那个join代码</span>q.join()<span class="hljs-comment">#-------------------------------------------------------------</span>q = Queue(<span class="hljs-number">2</span>)q.put(<span class="hljs-string">'a'</span>)q.put(<span class="hljs-string">'b'</span>)q.get()<span class="hljs-comment"># get取完队列中的一个值后，使用task_done方法告诉队列，我已经取出了一个值并处理完毕,下同</span>q.task_done()q.get()<span class="hljs-comment">#在每次get取值之后，还需要在跟队列声明一下，我已经取出了数据并处理完毕，这样执行到join代码的时候才不会被卡住</span>q.task_done()q.join()</code></pre></div></p><h2 id="2-双向队列"><a href="#2-双向队列" class="headerlink" title="2. 双向队列"></a>2. 双向队列</h2><p>接上面，删除列表的第一个元素（抑或是在第一个元素之前添加一个元素）之类的操作是很耗时的，因为这些操作会牵扯到移动列表里的所有元素。</p><p>collections.deque 类（双向队列）是一个线程安全、可以快速从两端添加或者删除元素的数据类型。而且如果想要有一种数据类型来存放“最近用到的几个元素”，deque 也是一个很好的选择。这是因为在新建一个双向队列的时候，你可以指定这个队列的大小，如果这个队列满员了，还可以从反向端删除过期的元素，然后在尾端添加新的元素.<br>使用示例如下:<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<span class="hljs-meta">&gt;&gt;&gt; </span>dq = deque(range(<span class="hljs-number">10</span>), maxlen=<span class="hljs-number">10</span>) ➊<span class="hljs-meta">&gt;&gt;&gt; </span>dqdeque([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], maxlen=<span class="hljs-number">10</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>dq.rotate(<span class="hljs-number">3</span>) ➋<span class="hljs-meta">&gt;&gt;&gt; </span>dqdeque([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], maxlen=<span class="hljs-number">10</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>dq.rotate(<span class="hljs-number">-4</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>dqdeque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>], maxlen=<span class="hljs-number">10</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>dq.appendleft(<span class="hljs-number">-1</span>) ➌<span class="hljs-meta">&gt;&gt;&gt; </span>dqdeque([<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], maxlen=<span class="hljs-number">10</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>dq.extend([<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]) ➍<span class="hljs-meta">&gt;&gt;&gt; </span>dqdeque([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>], maxlen=<span class="hljs-number">10</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>dq.extendleft([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]) ➎<span class="hljs-meta">&gt;&gt;&gt; </span>dqdeque([<span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>], maxlen=<span class="hljs-number">10</span>)</code></pre></div></p><p>❶ maxlen 是一个可选参数，代表这个队列可以容纳的元素的数量，而且一旦设定，这个属性就不能修改了。<br>❷ 队列的旋转操作接受一个参数 n，当 n &gt; 0 时，队列的最右边的 n 个元素会被移动到队列的左边。当 n &lt; 0 时，最左边的 n 个元素会被移动到右边。<br>❸ 当试图对一个已满（len(d) == d.maxlen）的队列做尾部添加操作的时候，它头部的元素会被删除掉。注意在下一行里，元素 0 被删除了。<br>❹ 在尾部添加 3 个元素的操作会挤掉 -1、1 和 2。<br>❺ extendleft(iter) 方法会把迭代器里的元素逐个添加到双向队列的左边，因此迭代器里的元素会逆序出现在队列里。</p><h2 id="3-其他队列"><a href="#3-其他队列" class="headerlink" title="3. 其他队列"></a>3. 其他队列</h2><p>Python提供的所有队列类型  </p><ol><li>先进先出队列 queue.Queue</li><li>后进先出队列 queue.LifoQueue (Queue的基础上进行的封装)</li><li>优先级队列 queue.PriorityQueue (Queue的基础上进行的封装)</li><li>双向队列 queue.deque  </li></ol><p>除了上述提到的队列与双端队列,还有两个用的比较少的:后进先出队列与优先级队列</p><h2 id="4-自己队列实现"><a href="#4-自己队列实现" class="headerlink" title="4. 自己队列实现"></a>4. 自己队列实现</h2><blockquote><p>在实际编码中不会自己来实现一个队列.因为python本身就有自带的队列库.如果想自己实现可以利用列表的一些特性,比如.append或者.pop来实现.也可以抛开列表重新定义一个队列.这里有一个很好的例子来实现，<a href="http://zhaochj.github.io/2016/05/15/2016-05-15-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E7%AB%AF%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">Python队列实现例子</a></p></blockquote><p><strong>相关链接</strong><br><a href="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.10.%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.10.%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97/</a><br><a href="https://docs.lvrui.io/2016/07/20/Python%E4%B8%AD%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">https://docs.lvrui.io/2016/07/20/Python%E4%B8%AD%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3.5+ subprocess用法概括以及使用场景分析</title>
    <link href="/2019/06/11/python3-subprocess/"/>
    <url>/2019/06/11/python3-subprocess/</url>
    
    <content type="html"><![CDATA[<p>Python是一门很给力的语言，可以完成想要的所有操作，但在极少数情况下，你可能需要调用外部程序。比如Linux命令或者运行Shell脚本。以前写Python脚本的时候，我最排斥的就是调用外部命令，可能因为出了错误不好处理，要么纯用Shell脚本，要么纯用Python脚本，“杂交算什么东西”！ 那我现在的想法呢，也很纠结，看下去吧。以前代码最常见的是使用Python的原始方法是使用<strong><code>os.system</code></strong>，但是后来被subprocess模块替代，也是这篇文章所要讲的。</p><h2 id="1-侃侃run-用法"><a href="#1-侃侃run-用法" class="headerlink" title="1. 侃侃run()用法"></a>1. 侃侃run()用法</h2><blockquote><p>我只用<strong><code>subprocess.run()</code></strong>，其他的都是垃圾？！</p></blockquote><p>Python中关于多进程协程异步等一些较新用法，官方一直在更新完善其用法，然后趋于稳定。<strong>subprocess</strong>模块旨在替换几个较旧的模块和功能，比如<strong><code>os.system</code></strong>，<strong><code>os.spawn*</code></strong>。而对于<strong>Python3.5 +</strong> <strong><code>subprocess.run()</code></strong>用来代替之前的call等几个老方法，万剑归一。</p><h3 id="1-1-示例1：运行命令并获取返回代码"><a href="#1-1-示例1：运行命令并获取返回代码" class="headerlink" title="1.1 示例1：运行命令并获取返回代码"></a>1.1 示例1：运行命令并获取返回代码</h3><p><strong>run()的行为与call()的行为大致相同，Python3.5+之后应该放弃使用call()，但是call()方法还是保留着，可以使用</strong></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocesscp = subprocess.run([<span class="hljs-string">"ls"</span>,<span class="hljs-string">"-lha"</span>])cp<span class="hljs-comment"># CompletedProcess(args=['ls', '-lha'], returncode=0)</span></code></pre></div><h3 id="1-2-示例2：运行命令，如果底层进程报错，强制抛出异常"><a href="#1-2-示例2：运行命令，如果底层进程报错，强制抛出异常" class="headerlink" title="1.2 示例2：运行命令，如果底层进程报错，强制抛出异常"></a>1.2 示例2：运行命令，如果底层进程报错，强制抛出异常</h3><p>加入<code>check=True</code>即可<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocesssubprocess.run([<span class="hljs-string">"ls"</span>,<span class="hljs-string">"foo bar"</span>], check=<span class="hljs-literal">True</span>)<span class="hljs-comment"># -------------------------------------------------------------------</span><span class="hljs-comment"># CalledProcessError                Traceback (most recent call last)</span><span class="hljs-comment"># ----&gt; 1 subprocess.run(["ls","foo bar"], check=True)</span><span class="hljs-comment"># /usr/lib/python3.6/subprocess.py in run(input, timeout, check, *popenargs, **kwargs)</span><span class="hljs-comment">#     416         if check and retcode:</span><span class="hljs-comment">#     417             raise CalledProcessError(retcode, process.args,</span><span class="hljs-comment"># --&gt; 418                                      output=stdout, stderr=stderr)</span><span class="hljs-comment">#     419     return CompletedProcess(process.args, retcode, stdout, stderr)</span><span class="hljs-comment">#     420 </span><span class="hljs-comment"># CalledProcessError: Command '['ls', 'foo bar']' returned non-zero exit status 2.</span></code></pre></div></p><h3 id="1-3-示例3：流畅使用shell"><a href="#1-3-示例3：流畅使用shell" class="headerlink" title="1.3 示例3：流畅使用shell"></a>1.3 示例3：流畅使用shell</h3><p>如果想要正常使用shell命令，只要加入<code>shell=True</code><br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocesscp = subprocess.run(<span class="hljs-string">"ls -lha"</span>,shell=<span class="hljs-literal">True</span>)cp<span class="hljs-comment"># CompletedProcess(args='ls -lha', returncode=0)</span></code></pre></div></p><blockquote><p>如果使用用户输入作为参数来构建命令字符串，加上shell = True的话可能有潜在的安全威胁（代码注入）</p></blockquote><h3 id="1-4-示例4：以字符串形式存储输出和错误消息"><a href="#1-4-示例4：以字符串形式存储输出和错误消息" class="headerlink" title="1.4 示例4：以字符串形式存储输出和错误消息"></a>1.4 示例4：以字符串形式存储输出和错误消息</h3><p>如果底层进程返回非零退出代码，则不会出现异常;可以通过CompletedProcess对象中的stderr属性访问错误消息。</p><p>不报错的例子：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocesscp = subprocess.run([<span class="hljs-string">"ls"</span>,<span class="hljs-string">"-lha"</span>], universal_newlines=<span class="hljs-literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)cp.stdout<span class="hljs-comment"># total 20K</span><span class="hljs-comment"># drwxrwxr-x  3 felipe felipe 4,0K Nov  4 15:28 .</span><span class="hljs-comment"># drwxrwxr-x 39 felipe felipe 4,0K Nov  3 18:31 ..</span><span class="hljs-comment"># drwxrwxr-x  2 felipe felipe 4,0K Nov  3 19:32 .ipynb_checkpoints</span><span class="hljs-comment"># -rw-rw-r--  1 felipe felipe 5,5K Nov  4 15:28 main.ipynb</span>cp.stderr<span class="hljs-comment"># '' (empty string)</span>cp.returncode<span class="hljs-comment"># 0</span></code></pre></div></p><p>报错的例子：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocesscp = subprocess.run([<span class="hljs-string">"ls"</span>,<span class="hljs-string">"foo bar"</span>], universal_newlines=<span class="hljs-literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)cp.output<span class="hljs-comment"># '' (empty string)</span>cp.stderr<span class="hljs-comment"># ls: cannot access 'foo bar': No such file or directory</span>cp.returncode<span class="hljs-comment"># 2</span></code></pre></div></p><p>命令不存在的例子：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<span class="hljs-keyword">try</span>:    cp = subprocess.run([<span class="hljs-string">"xxxx"</span>,<span class="hljs-string">"foo bar"</span>], universal_newlines=<span class="hljs-literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<span class="hljs-keyword">except</span> FileNotFoundError <span class="hljs-keyword">as</span> e:    print(e)    <span class="hljs-comment"># [Errno 2] No such file or directory: 'xxxx'</span></code></pre></div></p><h2 id="2-更底层的Popen用法"><a href="#2-更底层的Popen用法" class="headerlink" title="2. 更底层的Popen用法"></a>2. 更底层的Popen用法</h2><p>关于调用子进程，官方的推荐方法是用可以处理所有用例的run(函数。对于更高级的用例，可以直接使用底层的Popen接口。但这个方法在我看来用不太到（个人拙见），上面的run能满足99%的场景，理由我会在下面的使用场景中说出。</p><p><strong>这里推荐几篇好的文章,它们都在讲解subprocess的时候讲了popen方法：</strong><br><a href="http://queirozf.com/entries/python-3-subprocess-examples#run-example-run-command-and-get-return-code" target="_blank" rel="noopener">1. Python 3 Subprocess Examples</a><br><a href="https://pymotw.com/3/subprocess/" target="_blank" rel="noopener">2. subprocess — Spawning Additional Processes</a><br><a href="https://janakiev.com/til/python-shell-commands/" target="_blank" rel="noopener">3. How to Execute Shell Commands with Python</a></p><h2 id="3-使用场景分析与选择"><a href="#3-使用场景分析与选择" class="headerlink" title="3. 使用场景分析与选择"></a>3. 使用场景分析与选择</h2><p>我表达下我个人拙见。<br>Python能做很多事，大多数脚本都能胜任。但是对于Linux本身的操作，像是重启服务命令，一般系统特有命令，或者是Linux强大的三剑客（sed，awk，grep）在处理文本时有很大的优势，这些Python脚本都不好去代替。</p><ol><li>对于一些单条的管道命令，Python中最精确的是用Popen命令，但是我们完全可以用类似于run(‘grep python | wc &gt; out’, shell=True)来代替，虽然上面说这不安全，但是写在脚本内部，不把命令作为一个参数输入，是没有问题的。而且写之前肯定是要进行测试的，所以我上面才觉得底层的popen必要性不大。</li><li>对于一些麻烦的命令集合，类似于部署脚本、驱动类、开启关闭脚本，我们可以采用写shell脚本，把相关的一部分用shell脚本来代替，然后如果要在Python中调用的话只要<strong><code>run(&#39;./xx.sh&#39;,shell=True)</code></strong>（或者调皮一点bash中前嵌入运行python脚本），我不知道这优不优雅，有空去查查。</li></ol><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>如何在Python中运行外部命令，最有效的方法是使用子进程模块及其提供的所有功能。最值得注意的是，应该考虑使用subprocess.run。<br>还有其他有用的库支持Python中的shell命令，拓展了一些其他功能，比如与tty终端交互，获取系统CPU信息等，如plumbum，sh，psutils和pexpect，这里不做拓展。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用MCP2515芯片在树莓派上使用CAN BUS协议</title>
    <link href="/2019/06/10/MCP2515-CAN-BUS/"/>
    <url>/2019/06/10/MCP2515-CAN-BUS/</url>
    
    <content type="html"><![CDATA[<p>在树莓派上使用CAN_BUS（即CAN总线技术）来控制小物件对我来说很外行，概念也不深，只能按照小物件的说明来使用，但是使用之前需要进行与树莓派的连接，折腾了好多，这里简单做个梳理，但不过多介绍….因为自己对CAN协议也是一窍不通，囧～</p><p>我之前的完成过程基本依靠Google，贴上我参考的国外教程：</p><ol><li><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=141052" target="_blank" rel="noopener">[quick-guide] CAN bus on raspberry pi with MCP2515</a></li><li><a href="https://vimtut0r.com/2017/01/17/can-bus-with-raspberry-pi-howtoquickstart-mcp2515-kernel-4-4-x/" target="_blank" rel="noopener">CAN-Bus with Raspberry Pi: HowTo/Quickstart MCP2515 Kernel 4.4.x+</a></li><li><a href="https://harrisonsand.com/can-on-the-raspberry-pi/" target="_blank" rel="noopener">https://harrisonsand.com/can-on-the-raspberry-pi/</a></li></ol><h2 id="1-硬件相关问题"><a href="#1-硬件相关问题" class="headerlink" title="1. 硬件相关问题"></a>1. 硬件相关问题</h2><p>关于MCP2515 SPI转CAN的芯片，可能有多个“款式”的存在（有些教程里的跟我的芯片不一样），但是必要的针脚的插法都是一致的。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">RPi</span> <span class="hljs-comment">Pin</span>    <span class="hljs-comment">RPi</span> <span class="hljs-comment">Label</span>     <span class="hljs-comment">CAN</span> <span class="hljs-comment">Module</span><span class="hljs-comment">02</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">5V</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">VCC</span><span class="hljs-comment">06</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">GND</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">GND</span><span class="hljs-comment">19</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">GPIO10</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">MOSI</span> <span class="hljs-comment">(SI)</span><span class="hljs-comment">21</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">GPIO9</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">MISO</span> <span class="hljs-comment">(SO)</span><span class="hljs-comment">22</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">GPIO25</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">INT</span><span class="hljs-comment">23</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">GPIO11</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">SCK</span><span class="hljs-comment">24</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">GPIO8</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">CS</span></code></pre></div><blockquote><p>其他没什么的说的，在肯定自己接线没错误之后，我们需要怀疑芯片是不是坏的，我试的时候前面两个都是坏的，导致挂不上去</p></blockquote><h2 id="2-配置树莓派"><a href="#2-配置树莓派" class="headerlink" title="2. 配置树莓派"></a>2. 配置树莓派</h2><p><strong>编辑/boot/config.txt并添加以下行，将振荡器参数设置为模块上存在的振荡器参数。大多数模块使用16MHz振荡器作为时钟，但也有使用8MHz（即oscillator=8000000）。你可以通过查看芯片来确定频率。</strong></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">dtparam</span>=spi=<span class="hljs-literal">on</span><span class="hljs-attr">dtoverlay</span>=mcp2515-can0,oscillator=<span class="hljs-number">8000000</span>,interrupt=<span class="hljs-number">25</span><span class="hljs-attr">dtoverlay</span>=spi-bcm2835-overlay</code></pre></div><p>通过<strong><code>uname -a</code></strong>查看树莓派内核，如果内核为4.4.x往上（树莓派4B基本都是这个版本往上），则需要将最后一行配置修改：<br><div class="hljs"><pre><code class="hljs bash">dtparam=spi=ondtoverlay=mcp2515-can0,oscillator=8000000,interrupt=25dtoverlay=spi1-1cs</code></pre></div></p><h2 id="3-挂载CAN设备"><a href="#3-挂载CAN设备" class="headerlink" title="3. 挂载CAN设备"></a>3. 挂载CAN设备</h2><div class="hljs"><pre><code class="hljs bash">sudo apt-get updatesudo apt-get install can-utilssudo reboot</code></pre></div><p>等机器起来之后，我们可以先查看连接是否准确，有没有这个MCP2515设备，有了我们才能继续挂载。<br><div class="hljs"><pre><code class="hljs bash">pi@piv2:~ $ ls /sys/bus/spi/devices/spi0.0driver  modalias  net  of_node  subsystem  ueventpi@piv2:~ $ ls /sys/bus/spi/devices/spi0.0/netcan0</code></pre></div></p><blockquote><p>如果连接不准确基本上看不到上面的net文件夹，也就没有can0这个设备了</p></blockquote><p>之后，设置你想要的波特率挂载，我这里用的是125000(即你想要驱动的电机的波特率)，<strong><code>sudo ip link set can0 up type can bitrate 125000</code></strong>，挂载成功后，就能在<strong><code>ifconfig</code></strong>中看到：<br><div class="hljs"><pre><code class="hljs undefined">pi<span class="hljs-meta">@piv</span><span class="hljs-number">2:</span>~ $ sudo ifconfigcan0      Link <span class="hljs-string">encap:</span>UNSPEC  HWaddr <span class="hljs-number">00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span>          UP RUNNING NOARP  <span class="hljs-string">MTU:</span><span class="hljs-number">16</span>  <span class="hljs-string">Metric:</span><span class="hljs-number">1</span>          RX <span class="hljs-string">packets:</span><span class="hljs-number">0</span> <span class="hljs-string">errors:</span><span class="hljs-number">0</span> <span class="hljs-string">dropped:</span><span class="hljs-number">0</span> <span class="hljs-string">overruns:</span><span class="hljs-number">0</span> <span class="hljs-string">frame:</span><span class="hljs-number">0</span>          TX <span class="hljs-string">packets:</span><span class="hljs-number">0</span> <span class="hljs-string">errors:</span><span class="hljs-number">0</span> <span class="hljs-string">dropped:</span><span class="hljs-number">0</span> <span class="hljs-string">overruns:</span><span class="hljs-number">0</span> <span class="hljs-string">carrier:</span><span class="hljs-number">0</span><span class="hljs-symbol">          collisions:</span><span class="hljs-number">0</span> <span class="hljs-string">txqueuelen:</span><span class="hljs-number">10</span>          RX <span class="hljs-string">bytes:</span><span class="hljs-number">0</span> (<span class="hljs-number">0.0</span> B)  TX <span class="hljs-string">bytes:</span><span class="hljs-number">0</span> (<span class="hljs-number">0.0</span> B)etho      xxxx          ....          ....wlan0     xxxx          ....          ....</code></pre></div></p><blockquote><p>每当机器重启之后，这个挂载就会失效，需重新挂载。可以直接做成服务或者放在rc.local中，开机自动启动就行</p></blockquote><h2 id="4-发送CAN数据"><a href="#4-发送CAN数据" class="headerlink" title="4. 发送CAN数据"></a>4. 发送CAN数据</h2><p><strong><code>Usage: cansend &lt;device&gt; &lt;can_frame&gt;</code></strong><br><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">cansend</span> can0 <span class="hljs-number">127</span><span class="hljs-comment">#DEADBEEF</span></code></pre></div></p><p>具体的can_frame格式也不用担心，当你格式数据输的不准确时，命令会自动提示所需的格式。<br>同时可以再开个终端查看收到的数据：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">candump</span> can0</code></pre></div><blockquote><p>只有当线路完全接好形成回路时，才能用上面这个命令自发自收数据，当收到数据时，代表通信成功</p></blockquote><h2 id="5-使用Python第三方库向CAN发送数据"><a href="#5-使用Python第三方库向CAN发送数据" class="headerlink" title="5. 使用Python第三方库向CAN发送数据"></a>5. 使用Python第三方库向CAN发送数据</h2><p>当有需求要将功能写入Python脚本中时，可以使用<strong><code>python-can</code></strong>模块，具体的用法这里不多讲，看<a href="https://python-can.readthedocs.io/en/master/" target="_blank" rel="noopener">官方手册即可</a>。</p><h2 id="6-尾声"><a href="#6-尾声" class="headerlink" title="6.尾声"></a>6.尾声</h2><p><strong>对CAN BUS知之甚少，只能依葫芦画瓢，一步一步慢慢走验证结果，当觉得自己的操作都正确却没有得到正确结果时，怀疑一下硬件本身是否有问题！</strong></p>]]></content>
    
    
    <categories>
      
      <category>RaspberryPi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
      <tag>Linux</tag>
      
      <tag>CAN BUS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由DRF上传图片温习到的HTTP知识</title>
    <link href="/2019/06/05/drf-post-image/"/>
    <url>/2019/06/05/drf-post-image/</url>
    
    <content type="html"><![CDATA[<p>在前后端开发的时候，Djangorestframework（简称DRF）是个及其强大的附属于Django的第三方库，依赖于Model的CURD操作大大减少了代码量。之前使用DRF的时候基本都是跟前端json交互，非常容易，但是最近要上传以及跟新图片，遇到了一些小问题，期间不知不觉又拓展到了Http的知识，发现自己有在这方面有些薄弱，温习了一波，特在此记录一波。</p><h2 id="1-熟悉而又陌生的HTTP"><a href="#1-熟悉而又陌生的HTTP" class="headerlink" title="1. 熟悉而又陌生的HTTP"></a>1. 熟悉而又陌生的HTTP</h2><blockquote><p>某大佬云：学习Web开发不好好学习HTTP报文，将会“打拳不练功，到老一场空”，你花在犯迷糊上的时间比你沉下心来学习HTTP的时间肯定会多很多。</p></blockquote><p>这句话在我看来是及其正确的。作为一个后端开发，不仅仅在于空荡荡地写代码，单身三十年的手速来辅助粘贴，更重要的是在代码有问题进行调试时，了解代码在框架中的运行流程。心中对整个过程了如指掌的程序猿解决问题自然很快，反之，则会花大把时间犯糊涂。</p><p>刚实习的那会，大把大把的时间，看过一本<strong>思科网络技术学院教程</strong>，我是在当当买的，但是听同事说是大学教科书，囧，不过内容古镇的是不错，当时粗粗一读已经解决了大部分心中的疑惑，上网是怎样的过程，TCP/IP啥的。不过还是对细节掌握太少，不然也不会有今日的困惑，乃至回头要重新翻这本书。</p><p>教程这里就不说了，网上大把大把，图文并茂，生动地很，这里这是给出链接，自己整理下。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP状态码</a></li><li><a href="https://blog.csdn.net/u010256388/article/details/68491509" target="_blank" rel="noopener">HTTP请求行、请求头、请求体详解</a></li><li><a href="https://blog.csdn.net/hguisu/article/details/8680808" target="_blank" rel="noopener">HTTP详解(1)-工作原理</a>，当然还有两张图要贴出来方便自己直接看。</li></ul><p>一张是TCP/IP模型</p><p><img src="/images/TCP_IP.gif" srcset="/img/loading.gif" alt="TCP/IP"></p><p>另外一张是HTTP协议栈中各层数据流</p><p><img src="/images/TCP_IP.gif" srcset="/img/loading.gif" alt="HTTP协议栈中各层数据流"></p><p>为什么要贴出来，重要程度就不说了。</p><h2 id="2-让我从DRF瞬移到了HTTP的问题"><a href="#2-让我从DRF瞬移到了HTTP的问题" class="headerlink" title="2. 让我从DRF瞬移到了HTTP的问题"></a>2. 让我从DRF瞬移到了HTTP的问题</h2><p>假设有这样一个Models，</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeautifulGirl</span><span class="hljs-params">(models.Model)</span>:</span>    name = models.CharField(max_length=<span class="hljs-number">32</span>, null=<span class="hljs-literal">True</span>, unique=<span class="hljs-literal">True</span>)    img = models.ImageField(null=<span class="hljs-literal">True</span>, blank=<span class="hljs-literal">True</span>, upload_to=<span class="hljs-string">'beauty/'</span>)</code></pre></div><p>我View视图先按照传统写的，<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># 上传美女图片</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadBeauty2</span><span class="hljs-params">(APIView)</span>:</span>    <span class="hljs-comment"># parser_classes = (MultiPartParser,)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span><span class="hljs-params">(self, request)</span>:</span>        data = request.data        beauty_name = data[<span class="hljs-string">'name'</span>]        <span class="hljs-keyword">if</span> beauty_name <span class="hljs-keyword">in</span> BeautifulGirl.objects.values_list(<span class="hljs-string">'name'</span>, flat=<span class="hljs-literal">True</span>):            <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">'msg'</span>: <span class="hljs-string">'repeat name'</span>&#125;, status=<span class="hljs-number">500</span>)        image = data[<span class="hljs-string">'image'</span>]        img_name = image.name        girl = BeautifulGirl()        girl.name = beauty_name        girl.img.save(img_name, image, save=<span class="hljs-literal">False</span>)        girl.save()        <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">'msg'</span>: <span class="hljs-string">'upload ok'</span>&#125;, status=<span class="hljs-number">200</span>)</code></pre></div></p><p>刚开始没有<strong><code>parser_classes = (MultiPartParser,)</code></strong>这一行，而且我的DRF parser 只设置成了<strong><code>&#39;rest_framework.parsers.JSONParser&#39;,</code></strong>，好了找到问题，那我看看哪个合适，<strong><code>FileUploadParser</code></strong>看上去合适的，设置一下，报错<strong><code>Missing filename. Request should include a Content-Disposition header ....</code></strong><br>后来看到了<a href="https://stackoverflow.com/questions/46806335/fileuploadparser-doesnt-get-the-file-name" target="_blank" rel="noopener">解决方法</a>，OK了，但是我对这个<strong><code>MultiPartParser</code></strong>很懵逼，<strong><code>FileUploadParser</code></strong>不就是上传图片，为何不可行。</p><blockquote><p>其实遇到这个问题也是我设置的问题，DRF默认解析包好了这个MultiPartParser，但我觉得平常只用json，所以只设置成了JSONParser，尴尬，用默认设置即可</p></blockquote><h2 id="3-使用Django进行文件上传的基础知识"><a href="#3-使用Django进行文件上传的基础知识" class="headerlink" title="3. 使用Django进行文件上传的基础知识"></a>3. 使用Django进行文件上传的基础知识</h2><p>这节的内容翻译自<a href="https://simpleisbetterthancomplex.com/tutorial/2016/08/01/how-to-upload-files-with-django.html" target="_blank" rel="noopener">这里</a></p><ul><li><p>将文件提交到服务器时，文件数据最终会被放入request.FILES。</p></li><li><p>HTML表单必须使用<strong>enctype=”multipart/form-data”</strong>正确设置属性。否则<code>request.FILES</code>将是空的。</p></li><li><p>必须使用POST方法提交表单。</p></li><li><p>Django有适当的模型字段来处理上传的文件：FileField和ImageField。</p></li><li><p>上传到FileField或ImageField不存储在数据库中，存储在文件系统中的文件。</p></li><li><p>FileField和ImageField在数据库中创建为字符串字段（通常为VARCHAR），包含对实际文件的引用。</p></li><li><p>如果删除包含FileField或ImageField的模型实例，Django将不会删除物理文件，而只会删除对文件的引用。</p></li><li><p>这request.FILES是一个类字典的对象。request.FILES的键值的名称都是来自<code>&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;</code>。</p></li><li><p>每个值request.FILES都是一个UploadedFile实例。</p></li><li><p>你将需要设置MEDIA_URL并MEDIA_ROOT在项目的settings.py。</p></li></ul><div class="hljs"><pre><code class="hljs python">MEDIA_URL = <span class="hljs-string">'/media/'</span>MEDIA_ROOT = os.path.join(BASE_DIR, <span class="hljs-string">'media'</span>)</code></pre></div><ul><li>在开发服务器中，你可以使用<code>django.contrib.staticfiles.views.serve()</code> 视图为用户上载的文件（媒体）提供服务。</li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<span class="hljs-keyword">from</span> django.conf.urls.static <span class="hljs-keyword">import</span> staticurlpatterns = [    <span class="hljs-comment"># Project url patterns...</span>]<span class="hljs-keyword">if</span> settings.DEBUG:    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</code></pre></div><ul><li>要访问MEDIA_URL模板，你必须添加<code>django.template.context_processors.media</code>到您的 <strong>context_processeors</strong>内部TEMPLATES配置。</li></ul><h2 id="4-multipart-form-data-是什么"><a href="#4-multipart-form-data-是什么" class="headerlink" title="4 . multipart/form-data 是什么"></a>4 . multipart/form-data 是什么</h2><p>整理一下两篇极佳的科普文章：</p><ol><li><a href="https://imququ.com/post/four-ways-to-post-data-in-http.html" target="_blank" rel="noopener">四种常见的 POST 提交数据方式</a></li><li><a href="https://stackoverflow.com/questions/4526273/what-does-enctype-multipart-form-data-mean/4526286" target="_blank" rel="noopener">what-does-enctype-multipart-form-data-mean？</a></li></ol><h2 id="5-FileUploadParser是什么以及更简单的方式上传图片"><a href="#5-FileUploadParser是什么以及更简单的方式上传图片" class="headerlink" title="5. FileUploadParser是什么以及更简单的方式上传图片"></a>5. FileUploadParser是什么以及更简单的方式上传图片</h2><blockquote><p>FileUploadParser适用于可以将文件作为原始数据请求上载的本机客户端。对于基于Web的上载或具有分段上传支持的本机客户端，应该使用MultiPartParser</p></blockquote><p><strong>好了，建议是不应该使用 =。= </strong></p><p>其实更好Crete数据的方法还是用DRF的通用视图，贼方便<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadBeauty</span><span class="hljs-params">(ListCreateAPIView)</span>:</span>    queryset = BeautifulGirl.objects.all()    serializer_class = BeautifulGirlSerializers    parser_classes = (MultiPartParser,FormParser)</code></pre></div></p><h2 id="6-回过头看看"><a href="#6-回过头看看" class="headerlink" title="6. 回过头看看"></a>6. 回过头看看</h2><p>既然作为一个稳定的web框架，更多的是让开发者方便快速，不用过多地在意包括http以及更多协议中本身繁杂晦涩的概念与操作，封装地很完美，但是很多东西，比如设置文件里仅仅一行字段就能代表很多东西，预留了默认设置，让初学者更加方便快捷，上手即用，没有门槛。但其中很多通用的基础知识在代码运行流程内部体现，需要掌握并且动手不断地尝试，必要时读源码来了解原由。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>DRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django Class-Based Views vs. Function-Based Views</title>
    <link href="/2019/06/04/django-CBV-VS-FBV/"/>
    <url>/2019/06/04/django-CBV-VS-FBV/</url>
    
    <content type="html"><![CDATA[<p>从一开始学习Django时候的Hello world的函数视图，到自带的View视图，再到restframework的APIView以及viewset。回过头来看看，好像有种从稚嫩到成熟再到老奸巨猾的感觉，代码量越来越少了，第三方库封装的越来越多，但是真正包含在其中的实现和理解我们却愈发忽视。作为一个web框架，我们在使用时应该更多在于一个完整的流程的实现过程，所以，无论是CBV还是FBV本质都是一样的</p><p>本文翻译国外作者Vitor Freitas博客，<a href="https://simpleisbetterthancomplex.com/article/2017/03/21/class-based-views-vs-function-based-views.html" target="_blank" rel="noopener">原文地址</a>在这里。如有侵权，立即删除。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>在django很老的版本时候，只有<code>function-based views</code>，但问题是是基于函数的视图太过于简单，很难去拓展,自定义它们,没法达到视图重用的地步。<br>为了解决这个问题，<code>class-based views</code>诞生了。所以，现在的django有基于函数或者基于类这两种视图。<br>当我们将<code>class-based views</code>加入到路由配置的时候。通常使用<code>View.as_view()</code>类方法，它返回一个函数，跟<code>function-based views</code>类似。</p><p>下面是源码中<code>as_view</code>方法的实现，相去看完整源码可以去看django完整源码：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span>:</span><span class="hljs-meta">    @classonlymethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">as_view</span><span class="hljs-params">(cls, **initkwargs)</span>:</span>        <span class="hljs-string">"""Main entry point for a request-response process."""</span>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> initkwargs:            <span class="hljs-comment"># ...</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">view</span><span class="hljs-params">(request, *args, **kwargs)</span>:</span>            self = cls(**initkwargs)            <span class="hljs-keyword">if</span> hasattr(self, <span class="hljs-string">'get'</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> hasattr(self, <span class="hljs-string">'head'</span>):                self.head = self.get            self.request = request            self.args = args            self.kwargs = kwargs            <span class="hljs-keyword">return</span> self.dispatch(request, *args, **kwargs)        <span class="hljs-comment"># ...</span>        <span class="hljs-keyword">return</span> view</code></pre></div></p><p>所以如果你想明确调用一个<code>class-based views</code>，你需要：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">return</span> MyView.as_view()(request)</code></pre></div></p><p>为了让代码更清楚一点，你也可以赋值给一个变量：<br><div class="hljs"><pre><code class="hljs python">view_function = MyView.as_view()<span class="hljs-keyword">return</span> view_function(request)</code></pre></div></p><p><strong>通过<code>as_view()</code>返回的视图函数是每个<code>class-based view</code>的外面一部分。调用视图函数之后，它将传递请求（request）给<code>dispatch()</code>方法，<code>dispatch()</code>方法将会根据request type (GET, POST, PUT, etc)来执行正确的方法。</strong></p><h2 id="2-Class-Based-View-例子"><a href="#2-Class-Based-View-例子" class="headerlink" title="2. Class-Based View 例子"></a>2. Class-Based View 例子</h2><p>如果你通过<code>django.views.View</code>基类拓展一个视图，<code>dispatch()</code>方法会按照逻辑自动处理HTTP方法。如果请求是一个POST，它将在视图里执行<code>post()</code>方法  </p><p>views.py<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views <span class="hljs-keyword">import</span> View<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContactView</span><span class="hljs-params">(View)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(self, request)</span>:</span>        <span class="hljs-comment"># Code block for GET request</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span><span class="hljs-params">(self, request)</span>:</span>        <span class="hljs-comment"># Code block for POST request</span></code></pre></div></p><p>urls.py<br><div class="hljs"><pre><code class="hljs python">urlpatterns = [    url(<span class="hljs-string">r'contact/$'</span>, views.ContactView.as_view(), name=<span class="hljs-string">'contact'</span>),]</code></pre></div></p><h2 id="3-Function-Based-View-例子"><a href="#3-Function-Based-View-例子" class="headerlink" title="3. Function-Based View 例子"></a>3. Function-Based View 例子</h2><p>在<code>Function-Based View</code>中，通过表达式处理请求逻辑。</p><p>views.py<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">contact</span><span class="hljs-params">(request)</span>:</span>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">'POST'</span>:        <span class="hljs-comment"># Code block for POST request</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-comment"># Code block for GET request (will also match PUT, HEAD, DELETE, etc)</span></code></pre></div></p><p>urls.py<br><div class="hljs"><pre><code class="hljs python">urlpatterns = [    url(<span class="hljs-string">r'contact/$'</span>, views.contact, name=<span class="hljs-string">'contact'</span>),]</code></pre></div></p><p>这两张视图主要的区别就在这。但是通用类视图（<code>generic class-based views</code>）就有更多故事了。</p><h2 id="4-Generic-Class-Based-Views"><a href="#4-Generic-Class-Based-Views" class="headerlink" title="4. Generic Class-Based Views"></a>4. Generic Class-Based Views</h2><p>通用类视图在web应用中被用来解决一些常用操作，比如：创建一个新模型对象，表格处理，数据list，分页，档案视图等。<br>通用类视图包括在django核心包中，可以从<code>django.views.generic</code>导入。它们能很好地加快开发过程。下面大体列一下可用的视图：</p><p><strong>Simple Generic Views</strong>  </p><ul><li>View</li><li>TemplateView</li><li>RedirectView</li></ul><p><strong>Detail Views</strong>  </p><ul><li>DetailView  </li></ul><p><strong>List Views</strong>  </p><ul><li>ListView  </li></ul><p><strong>Editing Views</strong>    </p><ul><li>FormView</li><li>CreateView</li><li>UpdateView</li><li>DeleteView</li></ul><p><strong>Date-Based Views</strong>  </p><ul><li>ArchiveIndexView</li><li>YearArchiveView</li><li>MonthArchiveView</li><li>WeekArchiveView</li><li>DayArchiveView</li><li>TodayArchiveView</li><li>DateDetailView  </li></ul><p>你可以从django官方手册上寻找更加详细的内容。</p><p>看到那么多视图时可能有点头晕，因为通用类的实现用了大量混合类（minixs）。</p><p>django文档上有个很好的资源，写着每个通用类视图的属性跟方法：<a href="https://docs.djangoproject.com/en/2.0/ref/class-based-views/flattened-index/" title=" Class-based generic views - flattened index." target="_blank" rel="noopener">Class-based generic views - flattened index</a>，我一直放在书签中。</p><h2 id="5-关于django视图的见仁见智"><a href="#5-关于django视图的见仁见智" class="headerlink" title="5. 关于django视图的见仁见智"></a>5. 关于django视图的见仁见智</h2><p><strong>观点1： 使用所有的通用视图</strong>！ </p><p>这个观点认为.django提供常用的基础的视图让你用来减少工作量，为什么不用呢？我们可以尝试以这种观点来实践，能更快更成功地构建大量项目。</p><p><strong>观点2:仅使用<code>django.views.generic.View</code></strong></p><p>这个观点认为,django的通用视图函数都继承与一个<code>Generic CBV</code>,通吃所有,想怎么自定义就怎么自定义.</p><p><strong>观点3:避免使用通用类视图除非你想子类化这些视图</strong></p><p>这个观点认为初学者刚开始尽量使用函数视图,因为它们更容易写跟理解,只有当你想要重用大量重用视图时才用<code>Class-Based View</code></p><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">Function-Based Views</td><td style="text-align:center">容易实现跟理解；流程简单；直接使用装饰器</td><td style="text-align:center">代码难以重用；处理HTTP请求时要有分支表达式</td></tr><tr><td style="text-align:center">Class-Based Views</td><td style="text-align:center">易拓展跟代码重用；可以用混合类继承；单独用类方法处理HTTP请求；有许多内置的通用视图函数</td><td style="text-align:center">不容易去理解；代码流程负载；父类混合类中隐藏较多代码；使用装饰器时需要额外的导入或覆盖方法</td></tr></tbody></table><p> 对于这两种视图的使用没有对与错,完全取决于开发状况与需求。就像文章一开始所说的，类视图不能代替函数视图。两者各有千秋。如果你想实现一个list view，那么你只需要继承<code>ListView</code>然覆盖它们的属性就行了。当然，如果你想进行一个更复杂的操作，比如同时处理多个表单，那么函数视图将会更适合你。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这里是我本人（并非原作者）的一些想法。一开始学django的时候，只知道基于函数的视图，这对于初学者来说是友好的。后来写的东西复杂的时候，特别是HTTP 请求不止是一开始单一的GET时，我更偏向于继承<code>django.views.generic.View</code>，简单覆盖方法就可以处理请求了。而对于内置的通用类视图，以及一些混合类啥的，我有些难以理解，再加上平时的开发都是前后端分离，利用django自带的模版系统的机会越来越少，所以我基本不用通用类视图。但是当你构建restful api的时候，运用到DRF框架时，里面也有类似的通用类，这个不依赖模版，真的很好用，我会在以后的章节里讲解。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>supvisor和celery以及django+vue的配置整理</title>
    <link href="/2019/05/30/celery-supvisor-config/"/>
    <url>/2019/05/30/celery-supvisor-config/</url>
    
    <content type="html"><![CDATA[<p>supvisor经常用来打包服务（领导喜欢service这个词，无语），celery用来做异步任务以及定时任务。web项目常常使用前后端分离，django+vue的组合，但是也要做一些配置,这里对一些以往的配置做一些整理,省的每次都要翻以前的项目，权当记录手册。</p><h2 id="1-Supvisor-Celery配置"><a href="#1-Supvisor-Celery配置" class="headerlink" title="1. Supvisor+Celery配置"></a>1. Supvisor+Celery配置</h2><p>假设有个叫smartmp的项目，那么有如下配置。<br><strong>supvisor对celery beat的配置文件：</strong><br><div class="hljs"><pre><code class="hljs bash">[program:smartmpbeat]<span class="hljs-built_in">command</span>=/usr/<span class="hljs-built_in">local</span>/bin/celery -A smartmp beat -l infodirectory=/home/baird/PycharmProjects/smartmpuser=bairdnumprocs=1stdout_logfile=/var/<span class="hljs-built_in">log</span>/celery/smartmp_beat.logstderr_logfile=/var/<span class="hljs-built_in">log</span>/celery/smartmp_beat.logautostart= <span class="hljs-literal">false</span>autorestart=<span class="hljs-literal">true</span>stopwaitsecs = 600killasgroup=<span class="hljs-literal">true</span>priority=999</code></pre></div></p><p><strong>supvisor对celery workers的配置文件：</strong><br><div class="hljs"><pre><code class="hljs bash">[program:smartmpworker]<span class="hljs-built_in">command</span>=/usr/<span class="hljs-built_in">local</span>/bin/celery  -A smartmp worker -l infodirectory=/home/baird/PycharmProjects/smartmpuser=bairdnumprocs=1stdout_logfile=/var/<span class="hljs-built_in">log</span>/celery/smartmp_worker.logstderr_logfile=/var/<span class="hljs-built_in">log</span>/celery/smartmp_worker.logautostart= <span class="hljs-literal">false</span>autorestart=<span class="hljs-literal">true</span>stopwaitsecs = 600killasgroup=<span class="hljs-literal">true</span>priority=998</code></pre></div></p><p><strong>celery在django settings中的配置：</strong><br><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># celery</span>CELERY_BROKER_URL = <span class="hljs-string">'redis://localhost:6379'</span>CELERY_RESULT_BACKEND = <span class="hljs-string">'redis://localhost:6379'</span>CELERY_ACCEPT_CONTENT = [<span class="hljs-string">'application/json'</span>]CELERY_RESULT_SERIALIZER = <span class="hljs-string">'json'</span>CELERY_TASK_SERIALIZER = <span class="hljs-string">'json'</span>CELERY_TIMEZONE = <span class="hljs-string">'Asia/Shanghai'</span><span class="hljs-comment"># Other Celery settings</span>CELERY_BEAT_SCHEDULE = &#123;    <span class="hljs-string">'get_di_value'</span>: &#123;        <span class="hljs-string">'task'</span>: <span class="hljs-string">'di.tasks.get_di_value'</span>,        <span class="hljs-string">'schedule'</span>: <span class="hljs-number">5.0</span>,    &#125;,&#125;</code></pre></div></p><p><strong>这边虽然用Supvisor配置的celery，但是也可以当做是配置运行普通Python脚本，把command命令替换即可，<a href="http://liyangliang.me/posts/2015/06/using-supervisor/" target="_blank" rel="noopener">关于supvisor的其他参数可以看这里</a></strong>。<br><strong>关于celery的话，自从celery到了4.0之后，就可以不需要配合其他django插件集成到django中。那会网上的坑贼多，全是老教程，直到我找到了一篇<a href="https://medium.com/@yehandjoe/celery-4-periodic-task-in-django-9f6b5a8c21c7#--respond" target="_blank" rel="noopener">启蒙教程</a>，写的太好啦，一目了然。</strong></p><h2 id="2-整合Django和Vue-js"><a href="#2-整合Django和Vue-js" class="headerlink" title="2. 整合Django和Vue.js"></a>2. 整合Django和Vue.js</h2><p>对于前后端分离的项目，整合整个项目也属于后端的事情，有时候往往会遗漏掉点配置。所以也记录下<a href="https://cloud.tencent.com/developer/article/1005607" target="_blank" rel="noopener">这篇文章</a>比较好的说明了。<br>设置里注意以下几点：</p><ol><li>总的url中的对于<code>index.html</code>的模板视图</li><li>模板配置中添加模板路径</li><li>静态文件的搜索路径</li><li>对于部署到服务器上，如果是内部几乎没并发的小项目，可以使用supvisor配合python3 manage.py runserver来使用达到小服务器的作用</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Celery</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>血案后对python3.7最新字节字符编码解码知识整理</title>
    <link href="/2019/05/25/python-encode-decode2/"/>
    <url>/2019/05/25/python-encode-decode2/</url>
    
    <content type="html"><![CDATA[<p>之前因为工作上面的需要，查了好多字符串字节编码解码方面的资料，结果发现鱼龙混杂。本身由于Python3与Python2在这方面的改动很大，再加上从Python3开始，伴随着版本的迭代，一些方法也有了变化，很多以前的转换方法都不能用了，整个过程被折磨的脑壳疼，在此从自己本身的理解上面做个总结，以后方便自己来查阅。</p><h2 id="1-先从概念理解开始"><a href="#1-先从概念理解开始" class="headerlink" title="1. 先从概念理解开始"></a>1. 先从概念理解开始</h2><blockquote><p>某大佬云：人类使用文本，计算机使用字节序列</p></blockquote><p>我们先可以看一下<a href="https://zhuanlan.zhihu.com/p/29318105" target="_blank" rel="noopener">从ASCII到Unicode的发展历史</a>，然后理解下面的概念。</p><ul><li><strong>bit</strong>：二进制位， 是计算机内部数据储存的最小单位，11010100是一个8位二进制数</li><li><strong>byte</strong>：字节，是计算机中数据处理的基本单位，计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成，即1个字节等于8个比特（1Byte=8bit）。八位二进制数最小为00000000，最大为11111111；通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码</li><li><strong>Unicode</strong>：Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求</li><li><strong>字符</strong>：“字符”的最佳定义是Unicode字符，字符的具体表述取决于所用的编码</li><li><strong>字符串</strong>：一个字符串就是一个字符序列（多个字符组成）</li><li><strong>码位</strong>：字符的标识，是0~1114111（这个数字记着，下面有用）的数字，在Unicode中以4-6个十六进制数字表示，而且加前缀“U+”，比如字母A的码位就是<code>U+0041</code>，欧元符号€的码位就是<code>U+20AC</code></li><li><strong>编码</strong>：把码位转换成字节序列的过程就是编码</li><li><strong>解码</strong>：把字节序序列转换成码位的过程</li></ul><p>简单看一个书本上例子当下酒菜：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">'café'</span><span class="hljs-meta">&gt;&gt;&gt; </span>len(s) <span class="hljs-comment"># ➊</span><span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>b = s.encode(<span class="hljs-string">'utf8'</span>) <span class="hljs-comment"># ➋</span><span class="hljs-meta">&gt;&gt;&gt; </span>b<span class="hljs-string">b'caf\xc3\xa9'</span> <span class="hljs-comment"># ➌</span><span class="hljs-meta">&gt;&gt;&gt; </span>len(b) <span class="hljs-comment"># ➍</span><span class="hljs-number">5</span><span class="hljs-meta">&gt;&gt;&gt; </span>b.decode(<span class="hljs-string">'utf8'</span>) <span class="hljs-comment"># ➎</span><span class="hljs-string">'café'</span></code></pre></div></p><p>❶ ‘café’ 字符串有 4 个 Unicode 字符。<br>❷ 使用 UTF-8 把 str 对象编码成 bytes 对象。<br>❸ bytes 字面量以 b 开头。<br>❹ 字节序列 b 有 5 个字节(在 UTF-8 中,“é”的码位编码成两个字节)。<br>❺ 使用 UTF-8 把 bytes 对象解码成 str 对象</p><blockquote><p>如果想帮助自己记住 .decode() 和 .encode() 的区别,可以把字节序列想成晦涩难懂的机器磁芯转储,把 Unicode 字符串想成“人类可读”的文本。那么,把字节序列变成人类可读的文本字符串就是解码,而把字符串变成用于存储或传输的字节序列就是编码。</p></blockquote><h2 id="2-几个常会看到的函数"><a href="#2-几个常会看到的函数" class="headerlink" title="2. 几个常会看到的函数"></a>2. 几个常会看到的函数</h2><h3 id="2-1-数字转换"><a href="#2-1-数字转换" class="headerlink" title="2.1 数字转换"></a>2.1 数字转换</h3><p> <code>bin()</code>,<code>oct()</code>,<code>int()</code>,<code>hex()</code>，这些函数就不说了，数字转换手算算也是非常简单的。但是我们要知道Python中各种进制数据的表示，以十进制的23为例，二进制前缀为0b，<code>0b10111</code>，八进制前缀为0o，<code>0o27</code>，十六进制前缀为0x，<code>0x17</code>.</p><p>一个在转换进制的同时高位补零的小技巧：<br><div class="hljs"><pre><code class="hljs python">&gt;&gt;&gt; bin(2)0b10'&gt;&gt;&gt; '&#123;:08b&#125;'.format(2)'00000010'&gt;&gt;&gt; '&#123;:8b&#125;'.format()'      10'# 输出的都是字符串&gt;&gt;&gt; int('00000010',2)2</code></pre></div></p><h3 id="2-2-不起眼的主角"><a href="#2-2-不起眼的主角" class="headerlink" title="2.2 不起眼的主角"></a>2.2 不起眼的主角</h3><p><code>chr(i)</code>：<strong>返回 Unicode 码位为整数 i （ 0 &lt;= i &lt;= 0x10ffff）的字符的字符串格式。例如，chr(97) 返回字符串 ‘a’，chr(8364) 返回字符串 ‘€’。这是 ord() 的逆函数</strong>。</p><p><code>ord(c)</code>： <strong>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 ord(‘a’) 返回整数 97， ord(‘€’) （欧元符合）返回 8364 。这是 chr() 的逆函数。</strong></p><p>所以上面chr函数里面i的范围最大为0x10ffff，转换成十进制就是码位概念里字符标识数字的1114111，欧元符号转换也是同理，0x20AC就是8364。</p><h2 id="3-计算机所能理解的字节"><a href="#3-计算机所能理解的字节" class="headerlink" title="3. 计算机所能理解的字节"></a>3. 计算机所能理解的字节</h2><h3 id="3-1-Python中的字节对象"><a href="#3-1-Python中的字节对象" class="headerlink" title="3.1 Python中的字节对象"></a>3.1 Python中的字节对象</h3><p><strong>操作二进制数据的核心内置类型是 bytes 和 bytearray。 它们由 memoryview 提供支持，该对象使用 缓冲区协议 来访问其他二进制对象所在内存，不需要创建对象的副本。</strong>、<br><code>bytearray(）</code>:返回一个新的 bytes 数组。 bytearray 类是一个可变序列，包含范围为 0 &lt;= x &lt; 256 的整数。它有可变序列大部分常见的方法<br><code>bytes()</code>:返回一个新的“bytes”对象， 是一个不可变序列，包含范围为 0 &lt;= x &lt; 256 的整数,bytes 是 bytearray 的不可变版本 - 它有其中不改变序列的方法和相同的索引、切片操作。<br><strong>Python中bytes 字面值中只允许 ASCII 字符（无论源代码声明的编码为何）。 任何超出 127 的二进制值必须使用相应的转义序列形式加入 bytes 字面值。</strong></p><blockquote><p>bytearray和bytes不一样的地方在于，bytearray是可变的,它们的关系就相当于list与tuple</p></blockquote><p>还是来看书上例子<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>cafe = bytes(<span class="hljs-string">'café'</span>, encoding=<span class="hljs-string">'utf_8'</span>) ➊<span class="hljs-meta">&gt;&gt;&gt; </span>cafe<span class="hljs-string">b'caf\xc3\xa9'</span><span class="hljs-meta">&gt;&gt;&gt; </span>cafe[<span class="hljs-number">0</span>] ➋<span class="hljs-number">99</span><span class="hljs-meta">&gt;&gt;&gt; </span>cafe[:<span class="hljs-number">1</span>] ➌<span class="hljs-string">b'c'</span><span class="hljs-meta">&gt;&gt;&gt; </span>cafe_arr = bytearray(cafe)<span class="hljs-meta">&gt;&gt;&gt; </span>cafe_arr ➍bytearray(<span class="hljs-string">b'caf\xc3\xa9'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>cafe_arr[<span class="hljs-number">-1</span>:] ➎bytearray(<span class="hljs-string">b'\xa9'</span>)</code></pre></div></p><p>❶ bytes 对象可以从 str 对象使用给定的编码构建。<br>❷ 各个元素是 range(256) 内的整数。<br>❸ bytes 对象的切片还是 bytes 对象,即使是只有一个字节的切片。<br>❹ bytearray 对象没有字面量句法,而是以 bytearray() 和字节序列字面量参数的形式<br>显示。<br>❺ bytearray 对象的切片还是 bytearray 对象。</p><blockquote><p>my_bytes[0] 获取的是一个整数,而 my_bytes[:1] 返回的是一个长度为 1的 bytes 对象——这一点应该不会让人意外。s[0] == s[:1] 只对 str 这个序列类型成立。不过,str 类型的这个行为十分罕见。对其他各个序列类型来说,s[i] 返回一个元素,而 s[i:i+1] 返回一个相同类型的序列,里面是 s[i] 元素。</p></blockquote><h3 id="3-2-简单分析"><a href="#3-2-简单分析" class="headerlink" title="3.2 简单分析"></a>3.2 简单分析</h3><p>上面的例子中，我们看到Python中字节用的是<code>b&#39;caf\xc3\xa9&#39;</code>来表示，通过一个前缀b来表示字节，也是为了让人更明白，<code>cafe[0]</code>得到的是99，我们打开<a href="https://www.ascii-code.com/" target="_blank" rel="noopener">ascii码表</a>，或者用<code>ord(&#39;c&#39;)</code>知道了，99代表的就是’c’。从内部来看，这个字节在计算机中的真正存在方式是用<code>01100011</code>来表示，后面的af类似，而<code>é</code>在utf8编码中要用两个字节表示，而且这两个字节都大于127，所有只能使用十六进制转义。<br>那为什么要用十六进制呢，而不是二进制来表明字节？</p><blockquote><p>由于字节(byte)在计算机内部出现的频率较高，如果可以使用一种简洁的方式将它的内在含义准确表达出来，将会给我们带来很多方便。选择十六进制，是因为8位二进制的数字可以方便的转换为2个十六进制的数字。一个字节能且只能由一对十六进制来表示，比如10110110可以表示为B6。如果使用4进制的话则需要使用4个数字来表示一个字节，不够简洁；使用8进制的话，最靠左的8进制数是由2位二进制数字来表示的，相比于使用16进制有些美中不足。</p></blockquote><p>说到底，Python给我们返回来的字节形式还是<strong>“给人看的”</strong>，让我们以一种看字符的方式来看字节。</p><h3 id="3-3-字节的两个好用方法来应对十六进制"><a href="#3-3-字节的两个好用方法来应对十六进制" class="headerlink" title="3.3 字节的两个好用方法来应对十六进制"></a>3.3 字节的两个好用方法来应对十六进制</h3><p><code>fromhex(string) （与binascii.b2a_hex(string)类似）</code>:此 bytes 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略<br><code>hex(h)（与binascii.a2b_hex(string)类似））</code>：返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>cafe = bytes(<span class="hljs-string">'café'</span>, encoding=<span class="hljs-string">'utf_8'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>cafe<span class="hljs-string">b'caf\xc3\xa9'</span><span class="hljs-meta">&gt;&gt;&gt; </span>cafe.hex()<span class="hljs-string">'636166c3a9'</span>&gt;&gt;&gt;bytes.fromhex(<span class="hljs-string">'63 61 66 c3 a9'</span>)<span class="hljs-string">b'caf\xc3\xa9'</span><span class="hljs-comment"># 另一种写方法,用的不多，一些手册或者其他语言里的十六进制数据都是没有0x前缀，还要手动补，不靠谱</span><span class="hljs-meta">&gt;&gt;&gt; </span>bytes([<span class="hljs-number">0x63</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0xc3</span>,<span class="hljs-number">0xa9</span>])<span class="hljs-string">b'caf\xc3\xa9'</span></code></pre></div></p><p>查看下bytes用法</p><blockquote><p>Init signature: bytes(self, /, *args, **kwargs)<br>Docstring:<br>bytes(iterable_of_ints) -&gt; bytes<br>bytes(string, encoding[, errors]) -&gt; bytes<br>bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer<br>bytes(int) -&gt; bytes object of size given by the parameter initialized with null bytes<br>bytes() -&gt; empty bytes object</p></blockquote><p>好了，这下心里的结都理清楚了，特别是要给下位机发送一段十六进制的数字的组合，就可以这么转换了</p><h2 id="4-结构体与内存视图"><a href="#4-结构体与内存视图" class="headerlink" title="4. 结构体与内存视图"></a>4. 结构体与内存视图</h2><p><strong>struct 模块提供了一些函数,把打包的字节序列转换成不同类型字段组成的元组,还有一些函数用于执行反向转换,把元组转换成打包的bytes、bytearray 和 memoryview 对象。</strong></p><p>虽然网上找的时候好多遇到了<code>struct</code>模块，但这里不多说，留下两个链接<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" target="_blank" rel="noopener">内存试图</a>，<a href="https://docs.python.org/zh-cn/3/library/struct.html?highlight=struct#module-struct" target="_blank" rel="noopener">struct模块官方手册</a>。</p><h2 id="5-编码与解码"><a href="#5-编码与解码" class="headerlink" title="5. 编码与解码"></a>5. 编码与解码</h2><blockquote><p>Python 自带了超过 100 种编解码器(codec, encoder/decoder),用于在文本和字节之间相互转换。每个编解码器都有一个名称,如 ‘utf_8’,而且经常有几个别名,如’utf8’、’utf-8’ 和 ‘U8’。这些名称可以传给open()、str.encode()、bytes.decode() 等函数的 encoding 参数。</p></blockquote><p>终于到了编码与解码，其实万剑归一，那些科技大佬们在混沌的一片编码方式中劈开了一斧，创建了utf8，我们只要用它就行了。看下面一个例子。<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span> k = <span class="hljs-string">'欢'</span>.encode(<span class="hljs-string">'utf8'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span> k<span class="hljs-string">b'\xe6\xac\xa2'</span> <span class="hljs-comment"># ➊</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(bin(k[<span class="hljs-number">0</span>])+<span class="hljs-string">'    '</span>+bin(k[<span class="hljs-number">1</span>])+<span class="hljs-string">'    '</span>+bin(k[<span class="hljs-number">2</span>]))<span class="hljs-number">0b11100110</span>    <span class="hljs-number">0b10101100</span>    <span class="hljs-number">0b10100010</span>  <span class="hljs-comment"># ➋</span></code></pre></div></p><p>❶ 汉字‘欢’通过utf8编码程三个字节<br>❷ 打印这三个字节的二进制</p><p> 然后再来看Unicode字符代码与UTF-8编码的对应关系，发现与下面的第三条是对应的，所以编码也不是乱编的，你随便写一个字节再解码都是容易报错的，百分之九十九，除非你运气好。</p><div class="hljs"><pre><code>0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre></div><h2 id="6-尾声"><a href="#6-尾声" class="headerlink" title="6.尾声"></a>6.尾声</h2><p>在整理以上内容的过程中，又收获了新的知识，头脑里对这一块又清晰多了。字节字符编码解码无论在哪门语言中都是快让人头疼难啃的骨头，其实不在于Python中语法是怎样的，而是对概念的理解，人类对编码的越加完善，架设了这么一条人与计算机交流的的桥梁。科技的美妙在于此～</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Bytes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过串口发送16进制数据引发的Python3编码血案</title>
    <link href="/2019/05/23/python-encode-decode1/"/>
    <url>/2019/05/23/python-encode-decode1/</url>
    
    <content type="html"><![CDATA[<p>由于工作需要，通过rs232串口来连接一个超声波测距仪，通过应答的方式，发送数据然后读取数据从而得到值。厂家给了个定制版串口助手，直接输入串口参数然后打开串口，就能获取到超声波周边（左，中，右）的障碍物的距离（单位厘米）。但是呢，我需要用Python给串口传数据，这也好办，发送十六进制数据，网上那边看看这边找找，然后我就顺其自然地走进了个坑，Python的大坑…..</p><h2 id="1-按部就班"><a href="#1-按部就班" class="headerlink" title="1. 按部就班"></a>1. 按部就班</h2><p>设备手册里写的读距离命令是这样的： 68,04,01,01,06 ，发送后结果数据以数据输出格式输出。<br>数据一个十个字节，输出格式为=&gt;数据帧字头（1Byte）+数据长度（6Byte）+地址（1Byte）+数据（6Byte）+校验和（1Byte）。</p><blockquote><p> <strong>可先用python3 -m  serial.tools.list_ports 查看可用串口</strong></p></blockquote><div class="hljs"><pre><code class="hljs python">import serialimport timeser = serial.Serial(port='/dev/ttyUSB3',baudrate=9600)# 由于发送的是十六进制数据，应该这么写ser.write([0x68,0x04,0x01,0x01,0x06]）#然后过1秒钟（超声波传播不会很快）time.sleep(1)value = ser.read_all()[-10=&gt;]</code></pre></div><h2 id="2-发送十六进制数据的方式"><a href="#2-发送十六进制数据的方式" class="headerlink" title="2.发送十六进制数据的方式"></a>2.发送十六进制数据的方式</h2><p>像上面一样，发送一组16进制数据就这么简单。我刚开始的时候找了很多方式，各种python2的老方法，不起作用的方法充斥着网上，鱼龙混杂。后来，我发现，串口明明传输的是字节，这是个列表，怎么就可行了呢？来一波代码查看。<br><div class="hljs"><pre><code class="hljs python">def write(self, value)=&gt;    """Output the given byte string over the serial port."""    if not self.is_open=&gt;        raise portNotOpenError    d = to_bytes(value)# 然后我们继续查看to_bytes函数# all Python versions prior 3.x convert ``str([17])`` to '[17]' instead of '\x11'# so a simple ``bytes(sequence)`` doesn't work for all versionsdef to_bytes(seq)=&gt;    """convert a sequence to a bytes type"""    if isinstance(seq, bytes)=&gt;        return seq    elif isinstance(seq, bytearray)=&gt;        return bytes(seq)    elif isinstance(seq, memoryview)=&gt;        return seq.tobytes()    elif isinstance(seq, unicode)=&gt;        raise TypeError('unicode strings are not supported, please encode to bytes=&gt; &#123;!r&#125;'.format(seq))    else=&gt;        # handle list of integers and bytes (one or more items) for Python 2 and 3        return bytes(bytearray(seq))</code></pre></div></p><p>我们可以看到如果单纯传入列表参数，将会<code>return bytes(bytearray(seq))</code>，那我们来看看：<br><div class="hljs"><pre><code class="hljs python">bytes(bytearray([<span class="hljs-number">0x68</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x06</span>]))    <span class="hljs-comment"># b'h\x04\x01\x01\x06'</span></code></pre></div></p><blockquote><p><strong>bytearray和bytes不一样的地方在于，bytearray是可变的,它们的关系就相当于list与tuple</strong></p></blockquote><p><strong>源码里的写法应该是兼容了Python2与Python3</strong> ，在Python3将列表转换为字节，我们也可以这么写来达到转换的效果：<br><div class="hljs"><pre><code class="hljs python">bytes([<span class="hljs-number">0x68</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x06</span>]     <span class="hljs-comment">#b'h\x04\x01\x01\x06</span></code></pre></div></p><p>或者通过单纯的十六进制字符串（即没有0x前缀）来传递数据：<br><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># 空格可不需要</span>bytes.fromhex(<span class="hljs-string">'68 04 01 01 06'</span>)      <span class="hljs-comment">#b'h\x04\x01\x01\x06</span></code></pre></div></p><p>伴随着这个<strong>fromhex</strong>方法的是<strong>hex</strong>方法：<br><div class="hljs"><pre><code class="hljs python">d = bytes.fromhex(<span class="hljs-string">'68 04 01 01 06'</span>)d.hex()                                <span class="hljs-comment"># '6804010106'</span></code></pre></div></p><h2 id="3-那接收到了什么？"><a href="#3-那接收到了什么？" class="headerlink" title="3. 那接收到了什么？"></a>3. 那接收到了什么？</h2><div class="hljs"><pre><code class="hljs python">value = ser.read_all()[<span class="hljs-number">-10</span>]<span class="hljs-comment">#value的值为 b'h\t\x01\x01\xc2\x00,\x00JC'</span></code></pre></div><p>乍一看有点懵逼，我要的是超声波测量到的障碍物距离，你给我一串这茬看不懂的干啥？</p><blockquote><p><strong>bytes或bytearray的对象的各个元素是介于0~255（含）之间的整数</strong></p></blockquote><p>我们尝试下这样获取：<br><div class="hljs"><pre><code class="hljs python">value = b'h\t\x01\x01\xc2\x00,\x00JC'# len(value) is 10value[0] =&gt; 104 # ord('h')=104value[1] =&gt; 9           # ord('\t')=9value[2] =&gt; 1           # ord('\x01')=1value[3] =&gt; 1value[4] =&gt; 194         # ord('\xc2')=194value[5] =&gt; 0value[6] =&gt; 44          # ord(',')=44value[7] =&gt; 0value[8] =&gt; 74          # ord('J')=74value[9] =&gt; 67          # ord('C')=67</code></pre></div></p><p><strong>由此我们可以知道，字节就是代表的一串二进制，这是计算机懂的语言，然后我们将二进制转换为数字，通过拿到的值计算就好</strong></p><h2 id="4-思考几个问题？"><a href="#4-思考几个问题？" class="headerlink" title="4. 思考几个问题？"></a>4. 思考几个问题？</h2><ul><li><strong>既然字节是二进制，为什么要用十六进制表示呢？</strong></li><li><strong>我们查看返回的值<code>b&#39;h\t\x01\x01\xc2\x00,\x00JC&#39;</code>，为什么是一些字母与十六进制的混合使用？</strong></li><li><strong><code>\x04</code>与<code>0x04</code>有什么区别，不都是十六进制吗？</strong></li><li><strong>很多很多…..</strong></li></ul><p><strong>那么就可以接着看下面的编码详解,不见不散。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
      <tag>Serial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 Python 眼光看Nodejs（三），Nodejs灵性语法整理（保持更新）</title>
    <link href="/2019/05/17/nodejs3-jstips/"/>
    <url>/2019/05/17/nodejs3-jstips/</url>
    
    <content type="html"><![CDATA[<p>说到语法，翻一翻熟悉的js菜鸟教程，变量，if语句，函数定义啥的，都是老生长谈的东西，一看就能明白。但还是和Python有点偏差，比如分号啊括号啊，变量定义啊什么的，而且唰唰唰往下看了都懂，等真正自己写起来的时候，都忘得差不多了，还是要回头翻。但是仅仅能看懂语法也是有好处的，比如新学一个模块或者框架的时候，你能看得懂代码然后依葫芦画瓢照着写，遇到不懂得语法（比如箭头函数）就去找，学习量也比较少，能更容易接受，达到慢慢积累的效果。这对于自己写代码也有一定帮助，看的语法少，那就稳稳当当码代码，不搞花里胡哨的写法。</p><p><a href="https://juejin.im/post/5b9cb3336fb9a05d290ee47e" target="_blank" rel="noopener">ES6、ES7、ES8特性一锅炖</a>，这里是Js近几年来的新特性，其实新特性对于初学者还是很有好的，相关用法只用看新的就行，老的完全摒弃不闻不问，多清净。</p><h2 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1. 箭头函数"></a>1. 箭头函数</h2><p>类似于Python的匿名函数，lambda表达式，但又有一些不一样。lambda只能是一条单独的表达式，而箭头函数却可以有多个表达式，中间用分好隔开，我认为两者差异的原因很大程度上在于，<strong>匿名函数本身就是为回调函数量身定做的，而Js中回调用法真的是家常便饭，要是像Python那样仅仅是单行表达式，那真的是太不方便了。</strong></p><h3 id="1-1-基础用法"><a href="#1-1-基础用法" class="headerlink" title="1.1 基础用法"></a>1.1 基础用法</h3><div class="hljs"><pre><code class="hljs js">(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>, …, 参数N) =&gt; &#123; 函数声明 &#125;<span class="hljs-comment">//相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;</span>(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>, …, 参数N) =&gt; 表达式（单一）<span class="hljs-comment">// 当只有一个参数时，圆括号是可选的：</span>(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125;<span class="hljs-comment">// 没有参数的函数应该写成一对圆括号。</span>() =&gt; &#123;函数声明&#125;</code></pre></div><h3 id="1-2-高级用法"><a href="#1-2-高级用法" class="headerlink" title="1.2 高级用法"></a>1.2 高级用法</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//加括号的函数体返回对象字面表达式：</span>参数=&gt; (&#123;<span class="hljs-attr">foo</span>: bar&#125;)<span class="hljs-comment">//支持剩余参数和默认参数</span>(参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>, ...rest) =&gt; &#123;函数声明&#125;(参数<span class="hljs-number">1</span> = 默认值<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>, …, 参数N = 默认值N) =&gt; &#123;函数声明&#125;<span class="hljs-comment">//同样支持参数列表解构</span><span class="hljs-keyword">let</span> f = <span class="hljs-function">(<span class="hljs-params">[a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;f();  <span class="hljs-comment">// 6</span></code></pre></div><p>当然官方不太可能单单因为这一个简单的功能：<strong>更短的函数</strong> 而把它搬到新特性里来，看这边<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数与普通函数区别</a></p><h2 id="2-数组的迭代到数组的常用用法"><a href="#2-数组的迭代到数组的常用用法" class="headerlink" title="2. 数组的迭代到数组的常用用法"></a>2. 数组的迭代到数组的常用用法</h2><p>例子正好用到上面的箭头函数：<br><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> array1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];array1.forEach(<span class="hljs-function">(<span class="hljs-params">value,index,array</span>) =&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(value,index,array)&#125;)<span class="hljs-comment">//除了value，其他的参数是可选的</span><span class="hljs-comment">//可用for of代替，类似于Python中for... in</span><span class="hljs-keyword">for</span> (value <span class="hljs-keyword">of</span> array1) &#123;<span class="hljs-built_in">console</span>.log(value)&#125;</code></pre></div></p><p>大概浏览下<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">array数组的语法一览</a>，array的方法很多，基本上结合了Python中的list的内置函数以及itertools模块中的函数（<strong>包含过滤，映射，合并，元素拓展，重新排列等功能</strong>。当然，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="noopener">js语法中也有迭代器跟生成器的概念</a>，这里不拓展。</p><h2 id="3-解构"><a href="#3-解构" class="headerlink" title="3. 解构"></a>3. 解构</h2><p>刚看到结构的语法，有些懵逼，实在想不到跟Python的哪种语法相关。后来一看是<a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p01_unpack_sequence_into_separate_variables.html" target="_blank" rel="noopener">将序列分解为单独变量</a>，以及<a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p02_unpack_elements_from_iterables.html" target="_blank" rel="noopener">从任意长度的可迭代对象中分解元素</a>。<br><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//解构数组</span><span class="hljs-keyword">var</span> a, b, rest;[a, b] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>];<span class="hljs-comment">// 用三个点，python中是*</span>[a, b, ...rest] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];<span class="hljs-built_in">console</span>.log(rest);<span class="hljs-comment">// expected output: [30,40,50]</span><span class="hljs-comment">//使用扩展运算符（...）拷贝数组</span><span class="hljs-keyword">const</span> itemsCopy = [...items];<span class="hljs-comment">///解构对象，这个是python没有的，通过dict.values()然后再分解</span><span class="hljs-keyword">var</span> a, b;(&#123;a, b&#125; = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;);<span class="hljs-comment">//给新的变量赋值</span><span class="hljs-keyword">var</span> o = &#123;<span class="hljs-attr">p</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">q</span>: <span class="hljs-literal">true</span>&#125;;<span class="hljs-keyword">var</span> &#123;<span class="hljs-attr">p</span>: foo, <span class="hljs-attr">q</span>: bar&#125; = o;<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 42</span><span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">// true</span><span class="hljs-comment">// 提供默认值</span><span class="hljs-keyword">var</span> &#123;a = <span class="hljs-number">10</span>, b = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">3</span>&#125;;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 3</span><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 5</span><span class="hljs-comment">// 给新的变量命名并提供默认值</span><span class="hljs-keyword">var</span> &#123;<span class="hljs-attr">a</span>:aa = <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>:bb = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">3</span>&#125;;<span class="hljs-built_in">console</span>.log(aa); <span class="hljs-comment">// 3</span><span class="hljs-built_in">console</span>.log(bb); <span class="hljs-comment">// 5</span></code></pre></div></p><h2 id="4-模板字符串"><a href="#4-模板字符串" class="headerlink" title="4. 模板字符串"></a>4. 模板字符串</h2><blockquote><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。<br><code>const a = &#39;foobar&#39;;const b = `foo${a}bar`;</code></p></blockquote><p>打印字符串这种常用到语法,一定需要个优雅的写法,才有动力让程序员代码继续搞下去。跟<a href="http://ju.outofmemory.cn/entry/198922" target="_blank" rel="noopener">神一样的python的<code>format</code>语法</a>差不多，不过好像不能在格式化字符串的同时对传入变量进行一些转换操作，比如进制，小数点转换等。<br>还有种更高级的用法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener">带标签的模板字符串</a>，不展开。</p><h3 id="4-1-拓展：条件运算符"><a href="#4-1-拓展：条件运算符" class="headerlink" title="4.1 拓展：条件运算符"></a>4.1 拓展：条件运算符</h3><blockquote><p>条件（三元）运算符是 JavaScript 仅有的使用三个操作数的运算符。本运算符经常作为if语句的简短形式来使用。<br>condition ? expr1 : expr2</p></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">26</span>;<span class="hljs-keyword">var</span> canDrinkAlcohol = (age &gt; <span class="hljs-number">21</span>) ? <span class="hljs-string">"True, over 21"</span> : <span class="hljs-string">"False, under 21"</span>;<span class="hljs-built_in">console</span>.log(canDrinkAlcohol); <span class="hljs-comment">// "True, over 21"</span><span class="hljs-comment">// 三元运算符能够很好地用在函数返回值的表达式中，此时不需要 if/else 语句</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canDrinkAlcohol</span>(<span class="hljs-params">age</span>) </span>&#123;  <span class="hljs-keyword">return</span> (age &gt; <span class="hljs-number">21</span>) ? <span class="hljs-string">"True, over 21"</span> : <span class="hljs-string">"False, under 21"</span>;&#125;<span class="hljs-keyword">var</span> output = canDrinkAlcohol(<span class="hljs-number">26</span>);<span class="hljs-built_in">console</span>.log(output); <span class="hljs-comment">// "True, over 21"</span></code></pre></div><p>在Python中不存在三元表达式，可以用<strong>简洁版的if/else语句</strong>：<code>canDrinkAlcohol =   &quot;True, over 21&quot; if age&gt;21 else  &quot;False, under 21&quot;</code>，可以达到同样效果。</p><h2 id="5-let与const"><a href="#5-let与const" class="headerlink" title="5. let与const"></a>5. let与const</h2><blockquote><p>Python是强类型 + 动态类型 , JS是弱类型 + 动态类型<br>动态/静态类型，指的是声明一个变量之后，它是否可以存储（指向）不同类型的变量。隐式类型转换，只可能发生在弱类型语言中<br>关于更多这方面的了解可以看这个链接：<a href="https://github.com/muwenzi/Program-Blog/issues/34" target="_blank" rel="noopener">JS是动态弱类型语言的理解</a></p></blockquote><p>虽同为动态类型语言，但js还是有点小不同，要用var，let，const之类的。<a href="https://juejin.im/post/5bdedd42e51d450d810a897c" target="_blank" rel="noopener">浅谈var、let和const区别</a>这里已经说得很清楚了,编程对此的建议是：</p><blockquote><p>let完全可以取代var，因为两者语义相同，而且let没有副作用,在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。</p></blockquote><h2 id="6-this用法"><a href="#6-this用法" class="headerlink" title="6. this用法"></a>6. this用法</h2><p>关于this，见到的比较少，但对这个语法也是模糊不清，等真正接触到了在写心得。具体用法参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">官网手册</a></p><h2 id="7-async与await"><a href="#7-async与await" class="headerlink" title="7. async与await"></a>7. async与await</h2><p>有必要简单讲一下javascript的异步发展历程，异步主要经历了这么几个过程：<br>Es6之前：</p><ul><li>回调函数（callback）</li></ul><p>Es6</p><ul><li>Promise对象</li><li>Generator函数  </li></ul><p>Es7</p><ul><li>async/await语法</li></ul><blockquote><p>async用于声明一个function是异步的,await只能出现在用async修饰的function中</p></blockquote><p>这是个头疼的语法，无论是在Python还是js中。不过殊途同归，异步协程的语法在一系列更改迭代之后，从yield到了await，这才是真正的光明大陆，抛弃内部实现，直接用同步语法写异步吧，美滋滋。</p><blockquote><p>在Python中异步编程更多的体验是在高效率，替换多线程的作用，而在nodejs中，本身函数的异步性，我感觉这个语法的核心在于取代回调函数的地狱，重在更好代码书写方式，即用同步方式写异步编程 ; promise与future含义接近，都代表未来会完成的事物，尽量不要对它们进行手动实例化，很多都是内部实现的，我们做的只是理解异步，然后用专家们定义的“async”与“await”就好</p></blockquote><h2 id="8-杂谈"><a href="#8-杂谈" class="headerlink" title="8. 杂谈"></a>8. 杂谈</h2><p><strong>作为一门语言，繁多的语法是免不了的，真的很多，js中还看到了Python中见过的但是不怎么熟悉用不到的语法的影子，都是一一对应。对于这些，不可能一口吃成胖子,任重而道远。碰到新语法就先去揣测它的意思然后去翻阅官方手册更容易去记住它～</strong></p>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由npm而温故到的pipenv</title>
    <link href="/2019/05/14/pipenv-and-npm/"/>
    <url>/2019/05/14/pipenv-and-npm/</url>
    
    <content type="html"><![CDATA[<p>最近在学习Nodejs的npm工具时，很喜欢这个包管理器，非全局安装库，package.json以及lock文件的内容，突然让我联想到了Pipfile，对于这个文件我一般都只是打开，将里面的<code>source url</code>换成国内pip源，然后就关掉，下一步安装软件，我的目的只是单纯的想要个干净的软件，想着到最后小项目完成的时候还能用<code>pip freeze</code> 生成个requirement文件，多好。后来才发现自己的想法有多傻缺，既然是<a href="https://zhuanlan.zhihu.com/p/22332669" target="_blank" rel="noopener">Kenneth Reitz</a>（链接为题外话，程序员都是潜力股）大神造的轮子，怎能没有我们平常想不到的。</p><h2 id="1-Pipenv燥起来"><a href="#1-Pipenv燥起来" class="headerlink" title="1. Pipenv燥起来"></a>1. Pipenv燥起来</h2><p>pipenv 参考了其他语言的包管理工具（bundler, composer, npm, cargo, yarn, etc.），旨在将最好的包管理工具带入 python 世界。pipevn 可以解决哪些问题：</p><ul><li><p>使用 pipenv 就相当于同时使用了 pip 和 virtualenv ，即做到包管理又可以管理虚拟环境。</p></li><li><p>使用 pipenv 解决 requirement.txt 面临的问题，pipenv 使用 Pipfile 代替 requirement.txt 文件来记录项目依赖包。</p></li><li><p>新增了 Pipfile.lock 文件来锁定 python 软件的包名及版本，以及其依赖关系的列表。</p></li><li>让你深入了解库的依赖图（例如<code>$ pipenv graph</code>）</li><li>通过加载.env文件简化开发工作流程</li></ul><h3 id="1-1-基础用法"><a href="#1-1-基础用法" class="headerlink" title="1.1 基础用法"></a>1.1 基础用法</h3><p>这里不过多介绍用法，<code>pipenv --help</code>或者官网即可查询。只推荐两篇文章当做小手册快速查看<br><a href="https://www.jianshu.com/p/00af447f0005" target="_blank" rel="noopener">pipenv利器</a> ， 以及 <a href="https://crazygit.wiseturtles.com/2018/01/08/pipenv-tour/" target="_blank" rel="noopener">pipenv使用指南</a></p><h3 id="1-2-项目中如何使用"><a href="#1-2-项目中如何使用" class="headerlink" title="1.2 项目中如何使用"></a>1.2 项目中如何使用</h3><p>在pipenv的目录中，我我以前总是放弃用<code>pipenv install</code>而是<code>pipenv shell</code>进入虚拟环境然后<code>pip</code>，因为<code>pienv install</code>的时候会有lock这一个步骤导致很慢（<a href="https://github.com/pypa/pipenv/issues/1914" target="_blank" rel="noopener">因为lock文件中要记录哈希值等</a>），lock文件的作用上面说过就不说了。但是用pip后库的名称版本不会记录到Pipfile，所以如果想完全摒弃requirement就应该用<code>pipenv install</code>。（其实可以完全不用到pipenv 进入虚拟环境,用<strong><code>pipenv run python|pip</code> </strong>即可）</p><blockquote><p>以Django项目为例。生成虚拟环境之前设置PIPENV_PYPI_MIRROR环境变量为<code>https://pypi.tuna.tsinghua.edu.cn/simple</code>，<a href="https://pipenv.readthedocs.io/en/latest/advanced/#pipenv.environments.PIPENV_PYPI_MIRROR" target="_blank" rel="noopener">详情见这里</a>，目的是pipenv安装库的时候都会使用清华源，免得每次都要改。然后生成一个envdir，进入该目录，安装django，新建django。app等。项目完成之后，将与djang项目平级的Pipfile以及lock文件放入项目，然后版本控制，上传git。之后就是别人clone下来，进入django项目，pipenv install就能将python环境与Pipfile中的文件生成，方便省事。这是我暂时的想法，以后有更好的方案会换</p></blockquote><h3 id="1-3-Pipfile与Pipfile-lock"><a href="#1-3-Pipfile与Pipfile-lock" class="headerlink" title="1.3 Pipfile与Pipfile.lock"></a>1.3 Pipfile与Pipfile.lock</h3><p>那为什么有了Pipfile还有Pipfile.lock</p><blockquote><p>Python应用程序的具体要求来自Pipfile。这将包括应该从哪里获取包以及它们的松散版本约束。<br>Pipfile.lock为了再现性，将存储环境的详细信息（所有已安装的包含固定版本和其他详细信息的包）。该文件将自动生成，用户不应修改。</p></blockquote><p>这里有个比较明了的回答，<a href="https://stackoverflow.com/questions/52951316/why-does-pipenv-need-pipfile-and-pipfile-lock" target="_blank" rel="noopener">Why does pipenv need Pipfile and Pipfile.lock?</a>。<br>转而也可以逐渐理解npm中<code>package.json</code>与<code>package-lock.json</code>的作用了</p><p><strong>那我们是否要将这两个文件保持版本控制，官方的建议是：</strong></p><ul><li>通常，保持两者Pipfile和Pipfile.lock版本控制。</li><li>Pipfile.lock如果要定位多个版本的Python，请不要保留版本控制。</li><li>在Pipfile的[requires]部分中指定目标Python版本。理想情况下，你应该只有一个目标Python版本，因为这是一个部署工具。</li><li>pipenv install与语法完全兼容，可在此处找到完整的文档。pip install请注意，Pipfile使用TOML Spec。</li></ul><h2 id="2-顺便说说npm"><a href="#2-顺便说说npm" class="headerlink" title="2. 顺便说说npm"></a>2. 顺便说说npm</h2><p><a href="https://www.cnblogs.com/tzyy/p/5193811.html" target="_blank" rel="noopener">package.json的字段详解</a>在这里，同样的按上面的说法，lock文件应该也要放入版本控制，但有一篇文章写道<a href="https://www.codementor.io/johnkennedy/get-rid-of-that-npm-package-lock-json-e0bj7ai42" target="_blank" rel="noopener">package-lock.json文件是地狱</a>。哈哈哈23333</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 Python 眼光看Nodejs（二），安装及npm配置</title>
    <link href="/2019/05/08/nodejs-2/"/>
    <url>/2019/05/08/nodejs-2/</url>
    
    <content type="html"><![CDATA[<p>上一节说过，以搜集文章为主，然后自己总结一些常用的知识当做笔记，可能不完整与基础，更多的是给自己做记录。学习一门新的语言，从安装到简单用法开始。所以从Nodejs的安装，运行，代码的导入，以及一般项目的代码组织与部署开始，不用太过于深入，了解大概流程就行，不可能记住所有的命令与用法，只要知道有这个功能大概长什么样，然后去官网手册翻看一下最佳</p><h2 id="1-Nodejs安装"><a href="#1-Nodejs安装" class="headerlink" title="1. Nodejs安装"></a>1. Nodejs安装</h2><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># Using Ubuntu</span>curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -sudo apt-get install -y nodejs<span class="hljs-comment"># update npm</span>npm install npm -g<span class="hljs-comment"># show version</span>node -vnpm -v</code></pre></div><blockquote><p>其实我一开始直接下载官网编译好的nodejs，之后做命令的链接，如<a href="https://blog.csdn.net/tengxing007/article/details/78903807" target="_blank" rel="noopener">这边的安装教程</a>，也很好理解。但是后来发现一个问题，全局装一些带有命令行的库时，比如express-generator，命令行没有express该命令，需要将express库的bin文件手动连接到/usr/local/bin/express，略微麻烦<br>当然还有最稳妥的方法，源码安装，去nodejs官网下载source code，然后<code>./configure</code>,<code>make</code>,<code>make install</code>（我在命令前加sudo，然后发现npm install也需要加sudo，不太一样），源码安装有点耗时，我那破机器花了半小时</p></blockquote><h2 id="2-Nodejs模块包库的解释与代码的组织"><a href="#2-Nodejs模块包库的解释与代码的组织" class="headerlink" title="2. Nodejs模块包库的解释与代码的组织"></a>2. Nodejs模块包库的解释与代码的组织</h2><p>写到这边时，遇到一些基础概念，自己都有些蒙了，查了蛮久资料，理了一下</p><p><strong>先回味下Python的相关含义:</strong></p><blockquote><p>module：一个 .py 文件就是个 module<br> lib：抽象概念，和另外两个不是一类，只要你喜欢，什么都是 lib，就算只有个 hello world<br> package：就是个带 <strong>init</strong>.py 的文件夹，并不在乎里面有什么，不过一般来讲会包含一些    packages/modulesscrapy、flask、Django、numpy、scipy、NLTK、jieba 在你的语境下，一般都被认为是 lib，因为关注点不是他们的代码是怎么组织的。</p></blockquote><p>看了上面的解释,再结合这篇文章 <a href="https://liam.page/2017/07/23/modules-and-packages-of-python/" target="_blank" rel="noopener">Python 中的黑暗角落（三）：模块与包</a>我明白的更多了</p><p>再来说说Nodejs,其实也可以同样的理解,一个打印‘hello world’的js文件是一个模块（module），一个带有package.json的文件夹都是包（package）比如express框架，但是它们都是库（lib），因为都是给别人或者自己来用的，只是我们平常接触的一个些库都不是单个文件那么简单的，大多以包的形式存在。</p><p>接下来是<a href="https://nqdeng.github.io/7-days-nodejs/#2" target="_blank" rel="noopener">Nodejs代码组织与部署</a>中间有困惑记录下来</p><p><strong>Node.js模块里exports与module.exports的区别?</strong><br> <a href="https://www.zhihu.com/question/26621212http://" target="_blank" rel="noopener">相关笔记1</a>，<a href="https://liuzhichao.com/p/1669.html" target="_blank" rel="noopener">相关笔记2</a></p><h2 id="3-npm命令"><a href="#3-npm命令" class="headerlink" title="3. npm命令"></a>3. npm命令</h2><blockquote><p>npm之于Nodejs，如，pip之余Python</p></blockquote><p>所以这里把一些常用的命令记录下来，以后就方便翻了</p><h3 id="查看npm拥有的全部命令"><a href="#查看npm拥有的全部命令" class="headerlink" title="查看npm拥有的全部命令"></a>查看npm拥有的全部命令</h3><p><code>$ npm - -help</code><br><code>$ npm help</code></p><h3 id="查看某一个npm命令的详细用法"><a href="#查看某一个npm命令的详细用法" class="headerlink" title="查看某一个npm命令的详细用法"></a>查看某一个npm命令的详细用法</h3><p><code>$ npm &lt;command&gt; --help</code><br><code>$ npm help &lt;command&gt;</code></p><h3 id="与npmrc相关的三个文件："><a href="#与npmrc相关的三个文件：" class="headerlink" title="与npmrc相关的三个文件："></a>与npmrc相关的三个文件：</h3><p>npm项目配置文件：/path/to/my/project/.npmrc<br>用户配置文件：~/.npmrc (可通过<code>npm config get userconfig</code>查看)<br>全局配置文件：$PREFIX/etc/npmrc (可通过<code>npm config get globalconfig</code>查看)<br>npm内置配置文件：/path/to/npm/npmrc</p><h3 id="npm获取配置的6种方式（优先级从高到低）："><a href="#npm获取配置的6种方式（优先级从高到低）：" class="headerlink" title="npm获取配置的6种方式（优先级从高到低）："></a>npm获取配置的6种方式（优先级从高到低）：</h3><h4 id="1-命令行参数"><a href="#1-命令行参数" class="headerlink" title="1.命令行参数"></a>1.<strong>命令行参数</strong></h4><p><code>$ --proxy http://&lt;server&gt;:&lt;port&gt;</code></p><h4 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2.环境变量"></a>2.<strong>环境变量</strong></h4><p>以”npmconfig”为前缀的环境变量将会被认为是npm的配置属性。<br><code>$ npm_config_proxy=http://&lt;server&gt;:&lt;port&gt;</code></p><h4 id="3-用户配置文件"><a href="#3-用户配置文件" class="headerlink" title="3.用户配置文件"></a>3.<strong>用户配置文件</strong></h4><p>查看用户配置文件路径<br><code>$ npm config get userconfig</code><br>Linux系统默认路径<br><code>$HOME/.npmrc</code></p><h4 id="4-全局配置文件"><a href="#4-全局配置文件" class="headerlink" title="4.全局配置文件"></a>4.<strong>全局配置文件</strong></h4><p>查看文件路径<br><code>$ npm config get globalconfig</code><br>我的ubuntu文件路径<br><code>/usr/local/node-v10.15.3-linux-x64/etc/npmrc</code></p><h4 id="5-内置配置文件"><a href="#5-内置配置文件" class="headerlink" title="5.内置配置文件"></a>5.<strong>内置配置文件</strong></h4><p>安装npm的目录下的npmrc文件。</p><h4 id="6-默认配置"><a href="#6-默认配置" class="headerlink" title="6.默认配置"></a>6.<strong>默认配置</strong></h4><p>如果前5条均未设置，npm会使用默认配置参数。</p><blockquote><p>关于npm的配置主要命令可通过npm config - -help来查看（比如用npm config ls -l查看npm全部默认配置）。但是一样，作为简单用户我们没必要用的这么多，我们平常只要设置一个user config，我pip就是这么搞2333。设置也就换换npm注册源来增加下载速度（将registry=<a href="https://registry.npm.taobao.org放入~/.npmrc，没有这个文件则新建一个，npm" target="_blank" rel="noopener">https://registry.npm.taobao.org放入~/.npmrc，没有这个文件则新建一个，npm</a> c get registry来验证换了没，上传包记得换回来，不过基本用不到）</p></blockquote><h3 id="npm-info-命令可以查看每个模块的具体信息"><a href="#npm-info-命令可以查看每个模块的具体信息" class="headerlink" title="npm info 命令可以查看每个模块的具体信息"></a>npm info 命令可以查看每个模块的具体信息</h3><p><code>$ npm info &lt;package&gt;</code></p><h3 id="以树形结构列出当前项目安装的所有模块，以及它们依赖的模块"><a href="#以树形结构列出当前项目安装的所有模块，以及它们依赖的模块" class="headerlink" title="以树形结构列出当前项目安装的所有模块，以及它们依赖的模块"></a>以树形结构列出当前项目安装的所有模块，以及它们依赖的模块</h3><div class="hljs"><pre><code class="hljs bash">$ npm list<span class="hljs-comment"># 加上 global 参数，会列出全局安装的模块</span>$ npm list -global<span class="hljs-comment"># npm list 命令也可以列出单个模块</span>$ npm list express</code></pre></div><h3 id="使用-npm-安装包"><a href="#使用-npm-安装包" class="headerlink" title="使用 npm 安装包"></a>使用 npm 安装包</h3><p><code>npm install/i &lt;package_name&gt;</code></p><blockquote><p>在npm install部分，有很多东西值得注意的，比如全局与本地的区别，npm是默认本地安装，像极了python的虚拟环境，完全独立，不用了把文件夹删了就行，很赞。还有开发依赖，生产依赖。所以后来python的pipenv诞生了，吸取了其他包管理器比如npm等的一些优点，已被官方推荐使用</p></blockquote><h3 id="执行package-json中的脚本"><a href="#执行package-json中的脚本" class="headerlink" title="执行package.json中的脚本"></a>执行package.json中的脚本</h3><p><code>npm run</code></p><p><strong>以上都是些简单的概括，具体的看这<a href="https://neveryu.github.io/2017/04/10/npm/" target="_blank" rel="noopener">npm全面介绍</a></strong>以及官网手册，东西很多，挑你用得着的看</p><h3 id="推荐的npm库版本管理工具"><a href="#推荐的npm库版本管理工具" class="headerlink" title="推荐的npm库版本管理工具"></a>推荐的npm库版本管理工具</h3><p><a href="https://segmentfault.com/a/1190000011085967" target="_blank" rel="noopener">npm-check</a>,检查过期的不正确的和未使用的依赖项,版本神器，中文翻译<a href="https://www.helplib.com/GitHub/article_120756" target="_blank" rel="noopener">文档在这</a></p>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 Python 眼光看Nodejs（一）,杂谈</title>
    <link href="/2019/05/07/nodejs-1/"/>
    <url>/2019/05/07/nodejs-1/</url>
    
    <content type="html"><![CDATA[<p>说说自己为何要取这么个标题。最近在python的异步编程中挣扎，同步阻塞并发并行的概念让人头疼。在更加深入Django知识的过程中，也了解到了更多的web知识，比如轮询与长轮询（long polling），websokcet，然后到Django Channel，以及有名的异步的web框架tornado等，然后接触到了Nodejs。</p><h2 id="1-Nodejs为何与Python放在一起看待"><a href="#1-Nodejs为何与Python放在一起看待" class="headerlink" title="1. Nodejs为何与Python放在一起看待"></a>1. Nodejs为何与Python放在一起看待</h2><p>后端Nodejs基于服务端的javascript,前端js是基于浏览器端的 javascript。它们的语法不一样但是组成不一样。<br><strong>JavaScript</strong>：</p><ul><li>ECMAScript（语言基础，如：语法、数据类型结构以及一些内置对象） </li><li>DOM（一些操作页面元素的方法）</li><li>BOM（一些操作浏览器的方法）</li></ul><p><strong>Nodejs</strong>：</p><ul><li>ECMAScript（语言基础，如：语法、数据类型结构以及一些内置对象）</li><li>OS（操作系统）</li><li>file（文件系统）</li><li>net（网络系统）</li><li>database（数据库）</li></ul><p>其实说到底，前端js开发和nodejs开发，两者间除了js是重合的以外，其它技能互相之间完全没有半毛钱关系。自己以前没有学过JavaScript，但是学了Python也有三四年了，对一些web服务器原理、关系数据使用，以及稍微深一点的网络原理以及一些服务器方面的知识有一定的了解，虽然称不上多，但是有了一点基础，这些都是与Nodejs相关的。所以将两者放在一起来谈，比较相同点与不同点能更有兴趣地学习下去。</p><h2 id="2-Nodejs能用来干什么"><a href="#2-Nodejs能用来干什么" class="headerlink" title="2. Nodejs能用来干什么"></a>2. Nodejs能用来干什么</h2><p>如果Nodejs与Python没有什么大的差异化，那简直是没必要再白费精力学一门新语言，Nodejs当然有它自己闪亮的特性。</p><blockquote><p>NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器，他首先看重的是事件机制和异步IO模型的优越性，而不是JS。但是他需要选择一种编程语言实现他的想法，这种编程语言不能自带IO功能，并且需要能良好支持事件机制。JS没有自带IO功能，天生就用于处理浏览器中的DOM事件，并且拥有一大群程序员，因此就成为了天然的选择。</p></blockquote><p><strong>事件驱动</strong>与<strong>异步IO</strong>，这两个词在学习Python异步编程的时候遇到过，正如开头说的那样，很是折磨，很多概念模糊不清，对到底为何要这么<strong>重视异步</strong>不太懂，直到看了这篇文章 <a href="http://python.jobbole.com/88291/" target="_blank" rel="noopener">Python异步编程</a>，才有些理解为何平常我们觉得性能也就毫秒或者更小时间的差别咋要这么在意，多个几秒钟又没大事，何必异步这么麻烦。类似的还有这篇<a href="https://www.jianshu.com/p/486b0965c296" target="_blank" rel="noopener">Linux IO模型</a>，都是极佳的文章。人类总是一直在探求极致的运算速度，榨干CPU的性能，让它弹无虚发，哈哈！这就是进步。</p><blockquote><p>异步编程是以进程、线程、协程、函数/方法作为执行任务程序的基本单位，结合回调、事件循环、信号量等机制，以提高程序整体执行效率和并发能力的编程方式。</p></blockquote><p>那Nodejs到底能用来干什么或者说它的适用场景擅长领域在哪？就好比Python的科学计算，机器学习是一绝<br>，那Nodejs呢？<br><strong>Node.js特别适合于你希望保持从浏览器到服务器的持久连接的应用程序。使用称为“长轮询”的技术，你可以编写一个实时向用户发送更新的应用程序。对许多网络框架进行长时间轮询，比如Ruby on Rails或Django，会在服务器上产生巨大的负担，因为每个活动客户端都会占用一个服务器进程。这种情况相当于一个tarpit攻击。当你使用Node.js之类的东西时，服务器不需要为每个打开的连接维护单独的线程。</strong><br>所以Node.js最适合实时应用：<strong>在线游戏</strong>，<strong>协作工具</strong>，<strong>聊天室</strong>，或者其他用户需要立即看到一个用户对应用程序做的任何事情，而<strong>没有页面刷新</strong></p><blockquote><p>简而言之，Node.js非常适合具有大量并发连接的应用程序，并且每个请求只需要很少的CPU周期，因为在执行函数期间会阻止事件循环（包含所有其他客户端）</p></blockquote><h2 id="3-怎么学Nodejs"><a href="#3-怎么学Nodejs" class="headerlink" title="3. 怎么学Nodejs"></a>3. 怎么学Nodejs</h2><ol><li>先说js的语法，之前学习过一点，看着干巴巴的基础概念，用法、变量、函数等，这些看过一遍都懂，但是要用的时候就还得翻，很枯燥。但是有幸，js与python都是较为“动态的语言”，所以要用到的时候可以翻翻<a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">菜鸟教程上的js部分</a></li><li>关于Nodejs的那一部分主要还是语法api的应用，但是nodejs一直在修正，所以什么手册实体书没用，主要还是<a href="http://nodejs.cn/api/" target="_blank" rel="noopener">官方的手册</a>以及网上大佬的教程</li><li>我想，过程可以是这样的，先了解nodejs的运行方式与以及项目布局。Nodejs较重要的还是web开发，所以之后选择一个web框架去啃，在框架的教程中发现新知识或者新的语法就去查，去跟官方手册对照，去跟Python对照，解决了再继续下去，记录方式还是Google相关文章做整理为主，自己记录经典例子为辅</li><li>当然了，平常的工作中几乎没有用到高并发的时候，最终目的使用nodejs创建一个聊天室或者一个高并发的restful api，也算用到实际中了</li></ol><h2 id="4-未来"><a href="#4-未来" class="headerlink" title="4. 未来"></a>4. 未来</h2><p>用Nodejs的新知识来温故Python类似的旧知识，充实偶尔犯闲的上班时间，开始吧！</p>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于sed我常用的几个方法以及遇到坑的整理</title>
    <link href="/2019/04/25/sed-usage/"/>
    <url>/2019/04/25/sed-usage/</url>
    
    <content type="html"><![CDATA[<p>shell、grep、sed 和 awk 是 Unix 的基础。如果你不能非常轻松的使用它们，你将会被自己束缚住，因为它们构成了通过命令行和脚本与 Unix 系统交互的基础。<br>自己平常用到sed的场景一般都在shell中，自动化一些按部就班的东西，比如上一篇博文的自动生成django，在配置settings文件的时候难免修改或者增加一些设置。</p><p><strong>注：以下用法如果用到 </strong>-i<strong> 参数 ，直接修改读取的文件内容，而不是输出到终端（危险动作）</strong></p><h2 id="1-显示"><a href="#1-显示" class="headerlink" title="1. 显示"></a>1. 显示</h2><h3 id="1-1-以行为单位的显示"><a href="#1-1-以行为单位的显示" class="headerlink" title="1.1 以行为单位的显示"></a>1.1 以行为单位的显示</h3><div class="hljs"><pre><code class="hljs bash">sed -n <span class="hljs-string">'5,7p'</span> demo.txt</code></pre></div><h3 id="1-2-搜寻关键词显示"><a href="#1-2-搜寻关键词显示" class="headerlink" title="1.2 搜寻关键词显示"></a>1.2 搜寻关键词显示</h3><div class="hljs"><pre><code class="hljs bash">sed -n <span class="hljs-string">'/baird/p'</span> demo.txt</code></pre></div><p><strong>-n ：使用安静(silent)模式</strong><br><strong>p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行</strong><br>关于指定内容搜寻并显示也可尝试选择<strong>grep</strong>命令，更好明白一点，<a href="https://linux.cn/article-5453-1.html" target="_blank" rel="noopener">例子在这。</a></p><h2 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h2><p>两种方式与上面显示同理，只需将<strong> p </strong>改成<strong> d </strong></p><h2 id="3-新增"><a href="#3-新增" class="headerlink" title="3. 新增"></a>3. 新增</h2><p>增加有两种方式：<br><strong>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)</strong></p><h3 id="3-1-以行为单位的新增"><a href="#3-1-以行为单位的新增" class="headerlink" title="3.1 以行为单位的新增"></a>3.1 以行为单位的新增</h3><div class="hljs"><pre><code class="hljs bash">sed <span class="hljs-string">'2a  new_line'</span> demo.txt</code></pre></div><p>2表示第二行，也可用2,5a表示二到五行</p><h3 id="3-2-搜寻关键词新增"><a href="#3-2-搜寻关键词新增" class="headerlink" title="3.2 搜寻关键词新增"></a>3.2 搜寻关键词新增</h3><div class="hljs"><pre><code class="hljs bash">sed <span class="hljs-string">'/baird/i  new_line'</span> demo.txt</code></pre></div><h2 id="4-替换"><a href="#4-替换" class="headerlink" title="4. 替换"></a>4. 替换</h2><h4 id="4-1-以行为单位的替换"><a href="#4-1-以行为单位的替换" class="headerlink" title="4.1 以行为单位的替换"></a>4.1 以行为单位的替换</h4><p><strong>c ： 取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！倒是跟上面的新增差不多</strong><br><div class="hljs"><pre><code class="hljs bash">sed <span class="hljs-string">'2,5c No 2-5 number'</span> demo.txt</code></pre></div></p><h4 id="4-2-搜寻关键词替换"><a href="#4-2-搜寻关键词替换" class="headerlink" title="4.2 搜寻关键词替换"></a>4.2 搜寻关键词替换</h4><div class="hljs"><pre><code class="hljs bash">sed <span class="hljs-string">'s/要被取代的字串/新的字串/g</span></code></pre></div><p><strong>s: 每行，也可以选择固定在哪几行 <code>1,20s/old/new/g</code><br>g: 一行上替换所有的匹配，不加表示只替换第一个，2表示替换第二个（场景很少）</strong></p><h2 id="5-多点编辑"><a href="#5-多点编辑" class="headerlink" title="5. 多点编辑"></a>5. 多点编辑</h2><p>用的场景不多，sed写于shell脚本中，多写几行就是了</p><p><code>-e是编辑命令，用于sed执行多个编辑任务的情况下。在下一行开始编辑前，所有的编辑动作都将应用到模式缓冲区中的行上。因为是逐行进行多重编辑（即每个命令都在模式空间的当前行上执行），所以编辑命令的顺序会影响结果</code></p><div class="hljs"><pre><code class="hljs bash">sed -e action1 -e action2</code></pre></div><h2 id="6-记录自己遇到的几个坑问题"><a href="#6-记录自己遇到的几个坑问题" class="headerlink" title="6. 记录自己遇到的几个坑问题"></a>6. 记录自己遇到的几个坑问题</h2><h3 id="6-1-单双引号"><a href="#6-1-单双引号" class="headerlink" title="6.1 单双引号"></a>6.1 单双引号</h3><p>自己平常用到sed的场景一般都在shell中，自动化一些按部就班的东西，比如上一篇博文的自动生成django，在配置settings文件的时候难免修改或者增加一些设置。</p><div class="hljs"><pre><code class="hljs bash">sed -i <span class="hljs-string">'/ALLOWED_HOSTS/c ALLOWED_HOSTS = \['</span>\<span class="hljs-string">''</span>*<span class="hljs-string">'\'</span><span class="hljs-string">'\]'</span> setting.py</code></pre></div><p>注意到跟在sed后面的命令是用单引号的，如果我增加的文本中有本身有单引号，比如<code>ALLOWED_HOSTS = [&#39;*&#39;]</code>，那么我们需要用<code>&#39;\&#39;&#39;</code>来表示单引号，当然还有一些其他方法比如啥十六进制<code>\x27</code>，记不太清了，但是这个一些太乱了。后来发现个更好的方法：<br><code>sed -i &quot;/ALLOWED_HOSTS/c ALLOWED_HOSTS = \[\&#39;*\&#39;\]&quot; settings.py</code><br>用双引号括起来，这样里面的单引号用转义符号表示<code>\&#39;</code>,简洁多了。</p><p>双引号还有个好处，就是里面可以直接更shell中的变量$xx<br>比如之前我是这么写的：<br><div class="hljs"><pre><code class="hljs bash">sed -i <span class="hljs-string">'/MIDDLEWARE/i LOCAL_APPS = \['</span>\<span class="hljs-string">''</span><span class="hljs-string">'$app_name'</span><span class="hljs-string">'\'</span><span class="hljs-string">'\] \n'</span> <span class="hljs-variable">$Filename</span></code></pre></div></p><p>可以直接这么写：<br><div class="hljs"><pre><code class="hljs bash">sed -i <span class="hljs-string">"/MIDDLEWARE/i LOCAL_APPS = \[\'<span class="hljs-variable">$app_name</span>\'\] \n"</span> <span class="hljs-variable">$Filename</span></code></pre></div></p><p>上面的例子是替换的内容中包含引号，我们用<code>\&#39;</code>来转义，<strong>但是如果查询的字符带有引号呢，是否同样要转义呢，答案是不需要！</strong><br>比如下面这个例子，我们想要在唯一的<code>&#39;User&#39;:&#39;xxxx&#39;</code>下一行添加一行<code>&#39;PASSWORD&#39;:&#39;xxxx&#39;</code>,前面不需要转义，而后面需要，这就是区别：<br><div class="hljs"><pre><code class="hljs bash">sed -i  <span class="hljs-string">"/'USER': '<span class="hljs-variable">$p_user</span>'/a  \        \'PASSWORD\': \'<span class="hljs-variable">$p_password</span>\',"</span>  <span class="hljs-variable">$Filename</span></code></pre></div></p><p><strong>所以遇到修改单引号或者了要用变量时，尽量用双引号来操作<code>sed</code></strong></p><h3 id="6-2-新增一行时增加空格或者Tab"><a href="#6-2-新增一行时增加空格或者Tab" class="headerlink" title="6.2 新增一行时增加空格或者Tab"></a>6.2 新增一行时增加空格或者Tab</h3><div class="hljs"><pre><code class="hljs bash">sed -i <span class="hljs-string">"/common/i \    \'corsheaders.middleware.CorsMiddleware\',"</span> <span class="hljs-variable">$Filename</span></code></pre></div><p>需要在i后面加一个<code>\</code>然后在加<code>\t</code>或者按几个空格</p><h3 id="6-3-替换时如果变量里有"><a href="#6-3-替换时如果变量里有" class="headerlink" title="6.3 替换时如果变量里有/"></a>6.3 替换时如果变量里有/</h3><div class="hljs"><pre><code class="hljs bash">sed -i <span class="hljs-string">"s/youdir/<span class="hljs-variable">$Shell_folder</span>/g"</span></code></pre></div><p>达不到自己想要的状态，当遇到情况时可以选择整行替代!</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本自动生成django项目结构并添加常用插件</title>
    <link href="/2019/04/24/auto-django/"/>
    <url>/2019/04/24/auto-django/</url>
    
    <content type="html"><![CDATA[<p>时常需要新建一个django项目来做快速的Demo演示，自己也记不住一些基本配置与库的导入，常常去之前写的项目中拷贝，Pycharm切来切去有点麻烦，萌生出了简单写个shell脚本自动化生成django标准项目结构，简单配置了一些我平常用的插件，包括一个Hello Djago的测试视图，美滋滋！</p><p>生成一个新的django标准项目结构，简单配置了一些我平常用的插件，包括一个Hello Djago的测试视图，一劳永逸</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h2><p><code>只支持linux 测试环境为Ubuntu</code>,只支持linux 测试环境为Ubuntu，我这边用的是python虚拟环境，也可不需要</p><h3 id="Set-virtualenv"><a href="#Set-virtualenv" class="headerlink" title="Set virtualenv"></a>Set virtualenv</h3><div class="hljs"><pre><code class="hljs bash">$ mkdir envdir$ <span class="hljs-built_in">cd</span> envdir$ pipenv --python 3.x$ pipenv shell</code></pre></div><h3 id="Auto-create"><a href="#Auto-create" class="headerlink" title="Auto create"></a>Auto create</h3><div class="hljs"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/fantasyhh/MyAutoDjango$ <span class="hljs-built_in">cd</span> MyAutoDjango$ chmod u+x auto.sh$ ./auto.sh</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
